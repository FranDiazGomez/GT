// VisiWin.Application.modulVersion("VisiWinJS.js", "73.7.74.0", "2024-06-07"); 
// Type definitions for WinJS
// Project: http://msdn.microsoft.com/en-us/library/windows/apps/br229773.aspx
// Definitions by: TypeScript samples <https://www.typescriptlang.org/>, Adam Hewitt <https://github.com/adamhewitt627>, Craig Treasure <https://github.com/craigktreasure>
// Definitions: https://github.com/borisyankov/DefinitelyTyped

/* *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0  
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/**
 * Defines an Element object.
 **/
interface Element {
    winControl: any; // TODO: This should be control?
}

/**
 * Utility class for easy access to operations on application folders
 **/
interface IOHelper {
    /**
     * Determines whether the specified file exists in the folder.
     * @param filename The name of the file.
     * @returns A promise that completes with a value of either true (if the file exists) or false.
     **/
    exists(filename: string): WinJS.Promise<boolean>;

    /**
     * Reads the specified file. If the file doesn't exist, the specified default value is returned.
     * @param fileName The file to read from.
     * @param def The default value to be returned if the file failed to open.
     * @returns A promise that completes with a value that is either the contents of the file, or the specified default value.
     **/
    readText(fileName: string, def?: string): WinJS.Promise<string>;

    /**
     * Deletes a file from the folder.
     * @param fileName The file to be deleted.
     * @returns A promise that is fulfilled when the file has been deleted.
     **/
    remove(fileName: string): WinJS.Promise<void>;

    /**
     * Writes the specified text to the specified file.
     * @param fileName The name of the file.
     * @param text The content to be written to the file.
     * @returns A promise that completes with a value that is the number of characters written.
     **/
    writeText(fileName: string, text: string): WinJS.Promise<number>;
}

/**
 * Provides application-level functionality, for example activation, storage, and application events.
 **/
declare module WinJS.Application {
    //#region Objects

    /**
     * The local storage of the application.
     **/
    var local: IOHelper;

    /**
     * The roaming storage of the application.
     **/
    var roaming: IOHelper;

    /**
     * The temp storage of the application.
     **/
    var temp: IOHelper;

    /**
     * An object used for storing app information that can be used to restore the app's state after it has been suspended and then resumed. Data that can usefully be contained in this object includes the current navigation page or any information the user has added to the input controls on the page. You should not add information about customization (for example colors) or user-defined lists of content.
     **/
    var sessionState: any;

    //#endregion Objects

    //#region Methods

    /**
     * Informs the application object that asynchronous work is being performed, and that this event handler should not be considered complete until the promise completes. This function can be set inside the handlers for all WinJS.Application events: onactivated oncheckpoint onerror onloaded onready onsettings onunload.
     * @param promise The promise that should complete before processing is complete.
     **/
    function setPromise(promise: Promise<any>): void;

    //#endregion Methods

    //#region Functions

    /**
     * Adds an event listener for application-level events: activated, checkpoint, error, loaded, ready, settings, and unload.
     * @param type The type (name) of the event. You can use any of the following:"activated", "checkpoint", "error", "loaded", "ready", "settings", and" unload".
     * @param listener The listener to invoke when the event is raised.
     * @param capture true to initiate capture, otherwise false.
     **/
    function addEventListener(type: string, listener: Function, capture?: boolean): void;

    /**
     * Queues a checkpoint event.
     **/
    function checkpoint(): void;

    /**
     * Queues an event to be processed by the WinJS.Application event queue.
     * @param eventRecord The event object is expected to have a type property that is used as the event name when dispatching on the WinJS.Application event queue. The entire object is provided to event listeners in the detail property of the event.
     **/
    function queueEvent(eventRecord: any): void;

    /**
     * Removes an event listener from the control.
     * @param type The type (name) of the event.
     * @param listener The listener to remove.
     * @param useCapture Specifies whether or not to initiate capture.
     **/
    function removeEventListener(type: string, listener: Function, useCapture?: any): void;

    /**
     * Starts dispatching application events (the activated, checkpoint, error, loaded, ready, settings, and unload events).
     **/
    function start(): void;

    /**
     * Stops application event processing and resets WinJS.Application to its initial state. All WinJS.Application event listeners (for the activated, checkpoint, error, loaded, ready, settings, and unload events) are removed.
     **/
    function stop(): void;

    //#endregion Functions

    //#region Events

    /**
     * Occurs when WinRT activation has occurred. The name of this event is "activated" (and also "mainwindowactivated"). This event occurs after the loaded event and before the ready event.
     * @param eventInfo An object that contains information about the event. For more information about event arguments, see the WinRT event argument classes: WebUICachedFileUpdaterActivatedEventArgs, WebUICameraSettingsActivatedEventArgs, WebUIContactPickerActivatedEventArgs, WebUIDeviceActivatedEventArgs, WebUIFileActivatedEventArgs, WebUIFileOpenPickerActivatedEventArgs, WebUIFileSavePickerActivatedEventArgs, WebUILaunchActivatedEventArgs, WebUIPrintTaskSettingsActivatedEventArgs, WebUIProtocolActivatedEventArgs, WebUISearchActivatedEventArgs, WebUIShareTargetActivatedEventArgs.
     **/
    function onactivated(eventInfo: CustomEvent): void;

    /**
     * Occurs when receiving PLM notification or when the checkpoint function is called.
     * @param eventInfo An object that contains information about the event. The detail property of this object includes the following subproperties: type, setPromise.
     **/
    function oncheckpoint(eventInfo: CustomEvent): void;

    /**
     * Occurs when an unhandled error has been raised.
     * @param eventInfo An object that contains information about the event.
     **/
    function onerror(eventInfo: CustomEvent): void;

    /**
     * Occurs after the DOMContentLoaded event, which fires after the page has been parsed but before all the resources are loaded. This event occurs before the activated event and the ready event.
     * @param eventInfo An object that contains information about the event. The detail property of this object includes the following subproperties: type, setPromise.
     **/
    function onloaded(eventInfo: CustomEvent): void;

    /**
     * Occurs when the application is ready. This event occurs after the loaded event and the activated event.
     * @param eventInfo An object that contains information about the event. The detail property of this object includes the following sub-properties: type, setPromise.
     **/
    function onready(eventInfo: CustomEvent): void;

    /**
     * Occurs when the settings charm is invoked.
     * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: type, applicationcommands.
     **/
    function onsettings(eventInfo: CustomEvent): void;

    /**
     * Occurs when the application is about to be unloaded.
     * @param eventInfo An object that contains information about the event. The detail property of this object includes the following sub-properties: type, setPromise.
     **/
    function onunload(eventInfo: CustomEvent): void;

    //#endregion Events
}
/**
 * Provides functionality for data and template binding.
 **/
declare module WinJS.Binding {
    //#region Properties

    /**
     * Determines whether or not binding should automatically set the ID of an element. This property should be set to true in apps that use WinJS (WinJS) binding.
     **/
    var optimizeBindingReferences: boolean;

    //#endregion Properties

    //#region Objects

    /**
     * Allows you to add bindable properties dynamically.
     **/
    var dynamicObservableMixin: {
        //#region Methods

        /**
         * Adds a property with change notification to this object, including a ECMAScript5 property definition.
         * @param name The name of the property to add.
         * @param value This object is returned.
         **/
        addProperty(name: string, value: any): void;

        /**
         * Links the specified action to the property specified in the name parameter. This function is invoked when the value of the property may have changed. It is not guaranteed that the action will be called only when a value has actually changed, nor is it guaranteed that the action will be called for every value change. The implementation of this function coalesces change notifications, such that multiple updates to a property value may result in only a single call to the specified action.
         * @param name The name of the property to which to bind the action.
         * @param action The function to invoke asynchronously when the property may have changed.
         * @returns This object is returned.
         **/
        bind(name: string, action: any): Function;

        /**
         * Gets a property value by name.
         * @param name The name of the property to get.
         * @returns The value of the property as an observable object.
         **/
        getProperty(name: string): any;

        /**
         * Notifies listeners that a property value was updated.
         * @param name The name of the property that is being updated.
         * @param newValue The new value for the property.
         * @param oldValue The old value for the property.
         * @returns A promise that is completed when the notifications are complete.
         **/
        notify(name: string, newValue: string, oldValue: string): Promise<any>;

        /**
         * Removes a property value.
         * @param name The name of the property to remove.
         * @returns This object is returned.
         **/
        removeProperty(name: string): any;

        /**
         * Updates a property value and notifies any listeners.
         * @param name The name of the property to update.
         * @param value The new value of the property.
         * @returns This object is returned.
         **/
        setProperty(name: string, value: any): any;

        /**
         * Removes one or more listeners from the notification list for a given property.
         * @param name The name of the property to unbind. If this parameter is omitted, all listeners for all events are removed.
         * @param action The function to remove from the listener list for the specified property. If this parameter is omitted, all listeners are removed for the specific property.
         * @returns This object is returned.
         **/
        unbind(name: string, action: Function): any;

        /**
         * Updates a property value and notifies any listeners.
         * @param name The name of the property to update.
         * @param value The new value of the property.
         * @returns A promise that completes when the notifications for this property change have been processed. If multiple notifications are coalesced, the promise may be canceled or the value of the promise may be updated. The fulfilled value of the promise is the new value of the property for which the notifications have been completed.
         **/
        updateProperty(name: string, value: any): Promise<any>;

        //#endregion Methods
    };

    /**
     * Do not instantiate. A list returned by the createFiltered method.
     **/
    class FilteredListProjection<T> extends ListProjection<T> {
        //#region Methods

        /**
         * Returns a key/data pair for the specified index.
         * @param index The index of the value to retrieve.
         * @returns An object that has two properties: key and data.
         **/
        getItem(index: number): IKeyDataPair<T>;

        /**
         * Returns the index of the first occurrence of a key in a list.
         * @param key The key to locate in the list.
         * @returns The index of the first occurrence of a key in a list, or -1 if not found.
         **/
        indexOfKey(key: string): number;

        /**
         * Forces the list to send a itemmutated notification to any listeners for the value at the specified index.
         * @param index The index of the value that was mutated.
         **/
        notifyMutated(index: number): void;

        /**
         * Replaces the value at the specified index with a new value.
         * @param index The index of the value that was replaced.
         * @param newValue The new value.
         **/
        setAt(index: number, newValue: T): void;

        //#endregion Methods

        //#region Properties

        /**
         * The length of the list. Returns an integer value one higher than the highest element defined in an list.
         **/
        length: number;

        //#endregion Properties
    }

    /**
     * Do not instantiate. A list of groups.
     **/
    class GroupsListProjection<T> extends ListBase<T> {
        //#region Methods

        /**
         * Gets a key/data pair for the specified index.
         * @param index The index of the value to retrieve.
         * @returns An object that has two properties: key and data.
         **/
        getItem(index: number): IKeyDataPair<T>;

        /**
         * Gets a key/data pair for the specified key.
         * @param key The key of the value to retrieve.
         * @returns An object with two properties: key and data.
         **/
        getItemFromKey(key: string): IKeyDataPair<T>;

        /**
         * Returns the index of the first occurrence of a key in a list.
         * @param key The key to locate in the list.
         * @returns The index of the first occurrence of a key in a list, or -1 if not found.
         **/
        indexOfKey(key: string): number;

        //#endregion Methods

        //#region Properties

        /**
         * The length of the list. Returns an integer value one higher than the highest element defined in an list.
         **/
        length: number;

        //#endregion Properties
    }

    /**
     * Do not instantiate. Sorts the underlying list by group key and within a group respects the position of the item in the underlying list. Returned by createGrouped.
     **/
    class GroupedSortedListProjection<T> extends SortedListProjection<T> {
        //#region Properties

        /**
         * Gets a List, which is a projection of the groups that were identified in this list.
         **/
        groups: GroupsListProjection<T>;

        //#endregion Properties
    }

    /**
     * Represents a list of objects that can be accessed by index or by a string key. Provides methods to search, sort, filter, and manipulate the data.
     **/
    class List<T> extends ListBaseWithMutators<T> {
        //#region Constructors

        /**
         * Creates a List object.
         * @constructor
         * @param list The array containing the elements to initalize the list.
         * @param options You can set two Boolean options: binding and proxy. If options.binding is true, the list contains the result of calling as on the element values. If options.proxy is true, the list specified as the first parameter is used as the storage for the List. This option should be used with care, because uncoordinated edits to the data storage may result in errors.
         **/
        constructor(list?: T[], options?: any);

        //#endregion Constructors

        //#region Methods

        /**
         * Gets a key/data pair for the specified list index.
         * @param index The index of value to retrieve.
         * @returns An object with .key and .data properties.
         **/
        getItem(index: number): IKeyDataPair<T>;

        /**
         * Gets a key/data pair for the list item key specified.
         * @param key The key of the value to retrieve.
         * @returns An object with .key and .data properties.
         **/
        getItemFromKey(key: string): IKeyDataPair<T>;

        /**
         * Gets the index of the first occurrence of a key in a list.
         * @param key The key to locate in the list.
         * @returns The index of the first occurrence of a key in a list, or -1 if not found.
         **/
        indexOfKey(key: string): number;

        /**
         * Moves the value at index to the specified position.
         * @param index The original index of the value.
         * @param newIndex The index of the value after the move.
         **/
        move(index: number, newIndex: number): void;

        /**
         * Forces the list to send a itemmutated notification to any listeners for the value at the specified index.
         * @param index The index of the value that was mutated.
         **/
        notifyMutated(index: number): void;

        /**
         * Returns a list with the elements reversed. This method reverses the elements of a list object in place. It does not create a new list object during execution.
         **/
        reverse(): void;

        /**
         * Replaces the value at the specified index with a new value.
         * @param index The index of the value that was replaced.
         * @param newValue The new value.
         **/
        setAt(index: number, newValue: T): void;

        /**
         * Returns a list with the elements sorted. This method sorts the elements of a list object in place. It does not create a new list object during execution.
         * @param sortFunction The function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order. This function must always return the same results, given the same inputs. The results should not depend on values that are subject to change. You must call notifyMutated each time an item changes. Do not batch change notifications.
         **/
        sort(sortFunction: (left: T, right: T) => number): void;

        /**
         * Removes elements from a list and, if necessary, inserts new elements in their place, returning the deleted elements.
         * @param start The zero-based location in the list from which to start removing elements.
         * @param howMany The number of elements to remove.
         * @param item The elements to insert into the list in place of the deleted elements.
         * @returns The deleted elements.
         **/
        splice(start: number, howMany?: number, ...item: T[]): T[];

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets the length of the list, which is an integer value one higher than the highest element defined in the list.
         **/
        length: number;

        //#endregion Properties
    }

    /**
     * Represents a base class for lists.
     **/
    class ListBase<T> {
        //#region Events

        /**
         * An item in the list has changed its value.
         * @param eventInfo An object that contains information about the event. The detail contains the following information: index, key, newItem, newValue, oldItem, oldValue.
         **/
        onitemchanged(eventInfo: CustomEvent): void;

        /**
         * A new item has been inserted into the list.
         * @param eventInfo An object that contains information about the event. The detail contains the following information: index, key, value.
         **/
        oniteminserted(eventInfo: CustomEvent): void;

        /**
         * An item has been changed locations in the list.
         * @param eventInfo An object that contains information about the event. The detail contains the following information: index, key, value.
         **/
        onitemmoved(eventInfo: CustomEvent): void;

        /**
         * An item has been mutated. This event occurs as a result of calling the notifyMutated method.
         * @param eventInfo An object that contains information about the event. The detail contains the following information: index, key, value.
         **/
        onitemmutated(eventInfo: CustomEvent): void;

        /**
         * An item has been removed from the list.
         * @param eventInfo An object that contains information about the event. The detail contains the following information: index, key, value.
         **/
        onitemremoved(eventInfo: CustomEvent): void;

        /**
         * The list has been refreshed. Any references to items in the list may be incorrect.
         * @param eventInfo An object that contains information about the event. The detail property of this object is null.
         **/
        onreload(eventInfo: CustomEvent): void;

        //#endregion Events

        //#region Methods

        /**
         * Adds an event listener to the control.
         * @param type The type (name) of the event.
         * @param listener The listener to invoke when the event gets raised.
         * @param useCapture If true, initiates capture, otherwise false.
         **/
        addEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Links the specified action to the property specified in the name parameter. This function is invoked when the value of the property may have changed. It is not guaranteed that the action will be called only when a value has actually changed, nor is it guaranteed that the action will be called for every value change. The implementation of this function coalesces change notifications, such that multiple updates to a property value may result in only a single call to the specified action.
         * @param name The name of the property to which to bind the action.
         * @param action The function to invoke asynchronously when the property may have changed.
         * @returns A reference to this observableMixin object.
         **/
        bind(name: string, action: Function): any;

        /**
         * Returns a new list consisting of a combination of two arrays.
         * @param item Additional items to add to the end of the list.
         * @returns An array containing the concatenation of the list and any other supplied items.
         **/
        concat(...item: T[]): T[];

        /**
         * Creates a live filtered projection over this list. As the list changes, the filtered projection reacts to those changes and may also change.
         * @param predicate A function that accepts a single argument. The createFiltered function calls the callback with each element in the list. If the function returns true, that element will be included in the filtered list. This function must always return the same results, given the same inputs. The results should not depend on values that are subject to change. You must call notifyMutated each time an item changes. Do not batch change notifications.
         * @returns A filtered projection over the list.
         **/
        createFiltered(predicate: (x: T) => boolean): FilteredListProjection<T>;

        /**
         * Creates a live grouped projection over this list. As the list changes, the grouped projection reacts to those changes and may also change. The grouped projection sorts all the elements of the list to be in group-contiguous order. The grouped projection also contains a .groups property, which is a List representing the groups that were found in the list.
         * @param groupKey A function that accepts a single argument. The function is called with each element in the list, the function should return a string representing the group containing the element. This function must always return the same results, given the same inputs. The results should not depend on values that are subject to change. You must call notifyMutated each time an item changes. Do not batch change notifications.
         * @param groupData A function that accepts a single argument. The function is called once, on one element per group. It should return the value that should be set as the data of the .groups list element for this group. The data value usually serves as summary or header information for the group.
         * @param groupSorter A function that accepts two arguments. The function is called with pairs of group keys found in the list. It must return one of the following numeric values: negative if the first argument is less than the second (sorted before), zero if the two arguments are equivalent, positive if the first argument is greater than the second (sorted after).
         * @returns A grouped projection over the list.
         **/
        createGrouped(groupKey: (x: T) => string, groupData: (x: T) => any, groupSorter: (left: string, right: string) => number): GroupedSortedListProjection<T>;

        /**
         * Creates a live sorted projection over this list. As the list changes, the sorted projection reacts to those changes and may also change.
         * @param sorter A function that accepts two arguments. The function is called with elements in the list. It must return one of the following numeric values: negative if the first argument is less than the second, zero if the two arguments are equivalent, positive if the first argument is greater than the second. This function must always return the same results, given the same inputs. The results should not depend on values that are subject to change. You must call notifyMutated each time an item changes. Do not batch change notifications.
         * @returns A sorted projection over the list.
         **/
        createSorted(sorter: (left: T, right: T) => number): SortedListProjection<T>;

        /**
         * Raises an event of the specified type and with the specified additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event.
         **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Checks whether the specified callback function returns true for all elements in a list.
         * @param callback A function that accepts up to three arguments. This function is called for each element in the list until it returns false or the end of the list is reached.
         * @param thisArg An object to which the this keyword can refer in the callback function. If thisArg is omitted, undefined is used.
         * @returns true if the callback returns true for all elements in the list.
         **/
        every(callback: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;

        /**
         * Returns the elements of a list that meet the condition specified in a callback function.
         * @param callback A function that accepts up to three arguments. The function is called for each element in the list. This function must always return the same results, given the same inputs. The results should not depend on values that are subject to change. You must call notifyMutated each time an item changes. Do not batch change notifications.
         * @param thisArg An object to which the this keyword can refer in the callback function. If thisArg is omitted, undefined is used.
         * @returns An array containing the elements that meet the condition specified in the callback function.
         **/
        filter(callback: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];

        /**
         * Calls the specified callback function for each element in a list.
         * @param callback A function that accepts up to three arguments. The function is called for each element in the list. The arguments are as follows: value, index, array.
         * @param thisArg An object to which the this keyword can refer in the callback function. If thisArg is omitted, undefined is used.
         **/
        forEach(callback: (value: T, index: number, array: T[]) => void, thisArg?: any): void;

        /**
         * Gets the value at the specified index.
         * @param index The index of the value to get.
         * @returns The value at the specified index.
         **/
        getAt(index: number): T;

        /**
         * Gets the index of the first occurrence of the specified value in a list.
         * @param searchElement The value to locate in the list.
         * @param fromIndex The index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
         * @returns The index of the first occurrence of a value in a list or -1 if not found.
         **/
        indexOf(searchElement: T, fromIndex?: number): number;

        /**
         * Returns a string consisting of all the elements of a list separated by the specified separator string.
         * @param separator A string used to separate the elements of a list. If this parameter is omitted, the list elements are separated with a comma.
         * @returns The elements of a list separated by the specified separator string.
         **/
        join(separator: string): string;

        /**
         * Gets the index of the last occurrence of the specified value in a list.
         * @param searchElement The value to locate in the list.
         * @param fromIndex The index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the list.
         * @returns The index of the last occurrence of a value in a list, or -1 if not found.
         **/
        lastIndexOf(searchElement: T, fromIndex: number): number;

        /**
         * Calls the specified callback function on each element of a list, and returns an array that contains the results.
         * @param callback A function that accepts up to three arguments. The function is called for each element in the list.
         * @param thisArg n object to which the this keyword can refer in the callback function. If thisArg is omitted, undefined is used.
         * @returns An array containing the result of calling the callback function on each element in the list.
         **/
        map<G>(callback: (value: T, index: number, array: T[]) => G, thisArg?: any): G[];

        /**
         * Notifies listeners that a property value was updated.
         * @param name The name of the property that is being updated.
         * @param newValue The new value for the property.
         * @param oldValue The old value for the property.
         * @returns A promise that is completed when the notifications are complete.
         **/
        notify(name: string, newValue: any, oldValue: any): Promise<any>;

        /**
         * Forces the list to send a reload notification to any listeners.
         **/
        notifyReload(): void;

        /**
         * Accumulates a single result by calling the specified callback function for all elements in a list. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callback A function that accepts up to four arguments. These arguments are: previousValue, currentValue, currentIndex, array. The function is called for each element in the list.
         * @param initiallValue If initialValue is specified, it is used as the value with which to start the accumulation. The first call to the function provides this value as an argument instead of a list value.
         * @returns The return value from the last call to the callback function.
         **/
        reduce(callback: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => T, initiallValue?: T): T;

        /**
         * Accumulates a single result by calling the specified callback function for all elements in a list, starting with the last member of the list. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callback A function that accepts up to four arguments. These arguments are: previousValue, currentValue, currentIndex, array. The function is called for each element in the list.
         * @param initialValue If initialValue is specified, it is used as the value with which to start the accumulation. The first call to the callback function provides this value as an argument instead of a list value.
         * @returns The return value from the last call to callback function.
         **/
        reduceRight(callback: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => T, initialValue?: T): T;

        /**
         * Removes an event listener from the control.
         * @param type The type (name) of the event.
         * @param listener The listener to remove.
         * @param useCapture true if capture is to be initiated, otherwise false.
         **/
        removeEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Extracts a section of a list and returns a new list.
         * @param begin The index that specifies the beginning of the section.
         * @param end The index that specifies the end of the section.
         * @returns Returns a section of list.
         **/
        slice(begin: number, end: number): T[];

        /**
         * Checks whether the specified callback function returns true for any element of a list.
         * @param callback A function that accepts up to three arguments. The function is called for each element in the list until it returns true, or until the end of the list.
         * @param thisArg An object to which the this keyword can refer in the callback function. If thisArg is omitted, undefined is used.
         * @returns true if callback returns true for any element in the list.
         **/
        some(callback: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;

        /**
         * Removes one or more listeners from the notification list for a given property.
         * @param name The name of the property to unbind. If this parameter is omitted, all listeners for all events are removed.
         * @param action The function to remove from the listener list for the specified property. If this parameter is omitted, all listeners are removed for the specific property.
         * @returns This object is returned.
         **/
        unbind(name: string, action: Function): any;

        //#endregion Methods

        //#region Properties

        /**
         * Gets the IListDataSource for the list. The only purpose of this property is to adapt a List to the data model that is used by ListView and FlipView.
         **/
        dataSource: WinJS.UI.IListDataSource<T>;

        /**
         * Indicates that the object is compatibile with declarative processing.
         **/
        static supportedForProcessing: boolean;

        //#endregion Properties
    }

    /**
     * Represents a base class for normal list modifying operations.
     **/
    class ListBaseWithMutators<T> extends ListBase<T> {
        //#region Methods

        /**
         * Removes the last element from a list and returns it.
         * @returns The last element from the list.
         **/
        pop(): T;

        /**
         * Appends new element(s) to a list, and returns the new length of the list.
         * @param value The element to insert at the end of the list.
         * @returns The new length of the list.
         **/
        push(value: T): number;

        /**
         * Removes the first element from a list and returns it.
         * @returns The first element from the list.
         **/
        shift(): T;

        /**
         * Appends new element(s) to a list, and returns the new length of the list.
         * @param value The element to insert at the start of the list.
         * @returns The new length of the list.
         **/
        unshift(value: T): number;

        //#endregion Methods
    }

    /**
     * Represents a base class for list projections.
     **/
    class ListProjection<T> extends ListBaseWithMutators<T> {
        //#region Methods

        /**
         * Disconnects a WinJS.Binding.List projection from its underlying WinJS.Binding.List. It's only important to call this method when the WinJS.Binding.List projection and the WinJS.Binding.List have different lifetimes. (Call this method on the WinJS.Binding.List projection, not the underlying WinJS.Binding.List.)
         **/
        dispose(): void;

        /**
         * Gets a key/data pair for the specified key.
         * @param key The key of the value to retrieve.
         * @returns An object with two properties: key and data.
         **/
        getItemFromKey(key: string): IKeyDataPair<T>;

        /**
         * Moves the value at index to position newIndex.
         * @param index The original index of the value.
         * @param newIndex The index of the value after the move.
         **/
        move(index: number, newIndex: number): void;

        /**
         * Removes elements from a list and, if necessary, inserts new elements in their place, returning the deleted elements.
         * @param start The zero-based location in the list from which to start removing elements.
         * @param howMany The number of elements to remove.
         * @param item The elements to insert into the list in place of the deleted elements.
         * @returns The deleted elements.
         **/
        splice(start: number, howMany?: number, ...item: T[]): T[];

        //#endregion Methods
    }

    /**
     * Provides a standard implementation of the bindable contract, as well as a basic storage mechanism that participates in change notification and an asynchronous notification implementation.
     **/
    var mixin: {
        //#region Methods

        /**
         * Adds a property to the object. The property includes change notification and an ECMAScript 5 property definition .
         * @param name The name of the property to add.
         * @param value The value of the property.
         * @returns This object is returned.
         **/
        addProperty(name: string, value: any): any;

        /**
         * Links the specified action to the property specified in the name parameter. This function is invoked when the value of the property may have changed. It is not guaranteed that the action will be called only when a value has actually changed, nor is it guaranteed that the action will be called for every value change. The implementation of this function coalesces change notifications, such that multiple updates to a property value may result in only a single call to the specified action.
         * @param name The name of the property to which to bind the action.
         * @param action The function to invoke asynchronously when the property may have changed.
         * @returns This object is returned.
         **/
        bind(name: string, action: any): Function;

        /**
         * Gets a property value by name.
         * @param name The name of the property to get.
         * @returns The value of the property as an observable object.
         **/
        getProperty(name: string): any;

        /**
         * Notifies listeners that a property value was updated.
         * @param name The name of the property that is being updated.
         * @param newValue The new value for the property.
         * @param oldValue The old value for the property.
         * @returns A promise that is completed when the notifications are complete.
         **/
        notify(name: string, newValue: string, oldValue: string): Promise<any>;

        /**
         * Removes a property value.
         * @param name The name of the property to remove.
         * @returns This object is returned.
         **/
        removeProperty(name: string): any;

        /**
         * Updates a property value and notifies any listeners.
         * @param name The name of the property to update.
         * @param value The new value of the property.
         * @returns This object is returned.
         **/
        setProperty(name: string, value: any): any;

        /**
         * Removes one or more listeners from the notification list for a given property.
         * @param name The name of the property to unbind. If this parameter is omitted, all listeners for all events are removed.
         * @param action The function to remove from the listener list for the specified property. If this parameter is omitted, all listeners are removed for the specific property.
         * @returns This object is returned.
         **/
        unbind(name: string, action: Function): any;

        /**
         * Updates a property value and notifies any listeners.
         * @param name The name of the property to update.
         * @param value The new value of the property.
         * @returns A promise that completes when the notifications for this property change have been processed. If multiple notifications are coalesced, the promise may be canceled or the value of the promise may be updated. The fulfilled value of the promise is the new value of the property for which the notifications have been completed.
         **/
        updateProperty(name: string, value: any): Promise<any>;

        //#endregion Methods
    };

    /**
     * Provides functions that can make an object observable.
     **/
    var observableMixin: {
        //#region Methods

        /**
         * Links the specified action to the property specified in the name parameter. This function is invoked when the value of the property may have changed. It is not guaranteed that the action will be called only when a value has actually changed, nor is it guaranteed that the action will be called for every value change. The implementation of this function coalesces change notifications, such that multiple updates to a property value may result in only a single call to the specified action.
         * @param name The name of the property to which to bind the action.
         * @param action The function to invoke asynchronously when the property may have changed.
         * @returns A reference to this observableMixin object.
         **/
        bind(name: string, action: Function): any;

        /**
         * Notifies listeners that a property value was updated.
         * @param name The name of the property that is being updated.
         * @param newValue The new value for the property.
         * @param oldValue The old value for the property.
         * @returns A promise that is completed when the notifications are complete.
         **/
        notify(name: string, newValue: any, oldValue: any): Promise<any>;

        /**
         * Removes one or more listeners from the notification list for a given property.
         * @param name The name of the property to unbind. If this parameter is omitted, all listeners for all events are removed.
         * @param action The function to remove from the listener list for the specified property. If this parameter is omitted, all listeners are removed for the specific property.
         * @returns This object is returned.
         **/
        unbind(name: string, action: Function): any;

        //#endregion Methods
    };

    /**
     * Do not instantiate. Returned by the createSorted method.
     **/
    class SortedListProjection<T> extends ListProjection<T> {
        //#region Methods

        /**
         * Returns a key/data pair for the specified index.
         * @param index The index of the value to retrieve.
         * @returns An object that has two properties: key and data.
         **/
        getItem(index: number): IKeyDataPair<T>;

        /**
         * Returns the index of the first occurrence of a key.
         * @param key The key to locate in the list.
         * @returns The index of the first occurrence of a key in a list, or -1 if not found.
         **/
        indexOfKey(key: string): number;

        /**
         * Forces the list to send a itemmutated notification to any listeners for the value at the specified index.
         * @param index The index of the value that was mutated.
         **/
        notifyMutated(index: number): void;

        /**
         * Replaces the value at the specified index with a new value.
         * @param index The index of the value to be replaced.
         * @param newValue The new value.
         **/
        setAt(index: number, newValue: T): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets the length of the list. Returns an integer value one higher than the highest element defined in a list.
         **/
        length: number;

        //#endregion Properties
    }

    /**
     * Provides a reusable declarative binding element.
     **/
    class Template {
        //#region Constructors

        /**
         * Creates a template that provides a reusable declarative binding element.
         * @constructor
         * @param element The DOM element to convert to a template.
         * @param options If this parameter is supplied, the template is loaded from the URI and the content of the element parameter is ignored. You can add the following options: href.
         **/
        constructor(element: HTMLElement, options?: string);

        //#endregion Constructors

        //#region Methods

        render: {
            /**
             * Binds values from the specified data context to elements that are descendants of the specified root element that have the declarative binding attributes specified (data-win-bind).
             * @param dataContext The object to use for default data binding.
             * @param container The element to which to add this rendered template. If this parameter is omitted, a new DIV is created.
             * @returns A Promise that will be completed after binding has finished. The value is either container or the created DIV. promise that is completed after binding has finished.
             **/
            (dataContext: any, container?: HTMLElement): Promise<HTMLElement>;

            /**
             * Renders a template based on the specified URI (static method).
             * @param href The URI from which to load the template.
             * @param dataContext The object to use for default data binding.
             * @param container The element to which to add this rendered template. If this parameter is omitted, a new DIV is created.
             * @returns A promise that is completed after binding has finished. The value is either the object in the container parameter or the created DIV.
             **/
            value(href: string, dataContext: any, container?: HTMLElement): Promise<HTMLElement>;
        };

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets the default binding initializer for the template.
         **/
        bindingInitializer: any;

        /**
         * Gets or sets a value that specifies whether a debug break is inserted into the first rendering of each template. This property only has an effect when the app is in debug mode.
         **/
        debugBreakOnRender: boolean;

        /**
         * This property is deprecated and might not be available in future versions of the WinJS. Gets or sets a value that specifies whether optimized template processing has been disabled.
         **/
        disableOptimizedProcessing: boolean;

        /**
         * Gets the DOM element that is used as the template.
         **/
        element: HTMLElement;

        /**
         * Gets a value that specifies whether templates should be instantiated without the creation of an additional child element.
         **/
        extractChild: boolean;

        /**
         * Determines whether the Template contains declarative controls that must be processed separately. This property is always true. The controls that belong to a Template object's children are instantiated when a Template instance is rendered.
         **/
        isDeclarativeControlContainer: boolean;

        //#endregion Properties
    }

    //#endregion Objects

    //#region Functions

    /**
     * Adds a CSS class from the specified path of the source object to a destination object.
     * @param source The source object that has the class to copy.
     * @param sourceProperties The path on the source object to the source class.
     * @param dest The destination object.
     **/
    function addClassOneTime(source: any, sourceProperties: any[], dest: HTMLElement): void;

    /**
     * Returns an observable object. This may be an observable proxy for the specified object, an existing proxy, or the specified object itself if it directly supports observation.
     * @param data The object to observe.
     * @returns The observable object.
     **/
    function as<U>(data: U): U;

    /**
     * Binds to one or more properties on the observable object or or on child values of that object.
     * @param observable The object to bind to.
     * @param bindingDescriptor An object literal containing the binding declarations. Binding declarations take the form: { propertyName: (function | bindingDeclaration), ... }.
     * @returns An object that contains at least a "cancel" field, which is a function that removes all bindings associated with this bind request.
     **/
    function bind(observable: any, bindingDescriptor: any): any;

    /**
     * Creates a default binding initializer for binding between a source property and a destination property with the specified converter function that is executed on the value of the source property.
     * @param convert The conversion function that takes the source property and produces a value that is set to the destination property. This function must be accessible from the global namespace.
     * @returns The binding initializer.
     **/
    function converter(convert: Function): Function;

    /**
     * Creates a one-way binding between the source object and the destination object. Warning Do not attempt to bind data to the ID of an HTML element.
     * @param source The source object.
     * @param sourceProperties The path on the source object to the source property.
     * @param dest The destination object.
     * @param destProperties The path on the destination object to the destination property.
     * @returns An object with a cancel method that is used to coalesce bindings.
     **/
    function defaultBind(source: any, sourceProperties: any, dest: any, destProperties: any): any;

    /**
     * Creates a new constructor function that supports observability with the specified set of properties.
     * @param data The object to use as the pattern for defining the set of properties.
     * @returns A constructor function with 1 optional argument that is the initial state of the properties.
     **/
    function define(data: any): Function;

    /**
     * Wraps the specified object so that all its properties are instrumented for binding. This is meant to be used in conjunction with the binding mixin.
     * @param shape The specification for the bindable object.
     * @returns An object with a set of properties all of which are wired for binding.
     **/
    function expandProperties(shape: any): any;

    /**
     * Marks a custom initializer function as being compatible with declarative data binding.
     * @param customInitializer The custom initializer to be marked as compatible with declarative data binding.
     * @returns The input customInitializer.
     **/
    function initializer(customInitializer: Function): Function;

    /**
     * Notifies listeners that a property value was updated.
     * @param name The name of the property that is being updated.
     * @param newValue The new value for the property.
     * @param oldValue The old value for the property.
     * @returns A promise that is completed when the notifications are complete.
     **/
    function notify(name: string, newValue: string, oldValue: string): Promise<any>;

    /**
     * Sets the destination property to the value of the source property.
     * @param source The source object.
     * @param sourceProperties The path on the source object to the source property.
     * @param dest The destination object.
     * @param destProperties The path on the destination object to the destination property.
     * @returns An object with a cancel method that is used to coalesce bindings.
     **/
    function oneTime(source: any, sourceProperties: any, dest: any, destProperties: any): any;

    /**
     * Binds the values of an object to the values of a DOM element that has the data-win-bind attribute. If multiple DOM elements are to be bound, you must set the attribute on all of them. See the example below for details.
     * @param rootElement Optional. The element at which to start traversing to find elements to bind to. If this parameter is omitted, the entire document is searched.
     * @param dataContext The object that contains the values to which the DOM element should be bound.
     * @param skipRoot If true, specifies that only the children of rootElement should be bound, otherwise rootElement should be bound as well.
     * @param bindingCache The cached binding data.
     * @param defaultInitializer The binding initializer to use in the case that one is not specified in a binding expression. If not provided, the behavior is the same as Binding.defaultBind.
     * @returns A Promise that completes when every item that contains the data-win-bind attribute has been processed and the update has started.
     **/
    function processAll(rootElement?: Element, dataContext?: any, skipRoot?: boolean, bindingCache?: any, defaultInitializer?: Function): Promise<void>;

    /**
     * Creates a one-way binding between the source object and an attribute on the destination element.
     * @param source The source object.
     * @param sourceProperties The path on the source object to the source property.
     * @param dest The destination object.
     * @param destProperties The path on the destination object to the destination property. This must be a single name.
     * @returns An object with a cancel() method that is used to coalesce bindings.
     **/
    function setAttribute(source: any, sourceProperties: any[], dest: Element, destProperties: any[]): any;

    /**
     * Sets an attribute on the destination element to the value of the source property.
     * @param source The source object.
     * @param sourceProperties The path on the source object to the source property.
     * @param dest The destination object.
     * @param destProperties The path on the destination object to the destination property. This must be a single name.
     **/
    function setAttributeOneTime(source: any, sourceProperties: any[], dest: Element, destProperties: any[]): void;

    /**
     * Returns the original (non-observable) object is returned if the specified object is an observable proxy,
     * @param data The object for which to retrieve the original value.
     * @returns If the specified object is an observable proxy, the original object is returned, otherwise the same object is returned.
     **/
    function unwrap(data: any): any;

    //#endregion Functions

    //#region Interfaces

    interface IKeyDataPair<T> {
        key: string;
        data: T;
    }

    //#endregion Interfaces
}
/**
 * Provides helper functions for defining Classes.
 **/
declare module WinJS.Class {
    //#region Functions

    /**
     * Defines a class using the given constructor and the specified instance members.
     * @param constructor A constructor function that is used to instantiate this type.
     * @param instanceMembers The set of instance fields, properties, and methods made available on the type.
     * @param staticMembers The set of static fields, properties, and methods made available on the type.
     * @returns The newly-defined type.
     **/
    function define(constructor: Function, instanceMembers?: any, staticMembers?: any): any;

    /**
     * Creates a sub-class based on the specified baseClass parameter, using prototype inheritance.
     * @param baseClass The type to inherit from.
     * @param constructor A constructor function that is used to instantiate this type.
     * @param instanceMembers The set of instance fields, properties, and methods to be made available on the type.
     * @param staticMembers The set of static fields, properties, and methods to be made available on the type.
     * @returns The newly-defined type.
     **/
    function derive(baseClass: any, constructor: Function, instanceMembers?: any, staticMembers?: any): any;

    /**
     * Defines a class using the given constructor and the union of the set of instance members specified by all the mixin objects. The mixin parameter list is of variable length. For more information, see Adding functionality with WinJS mixins.
     * @param constructor A constructor function that will be used to instantiate this class.
     * @param mixin An object declaring the set of instance members. The mixin parameter list is of variable length.
     * @returns The newly defined class.
     **/
    function mix(constructor: Function, ...mixin: any[]): any;

    //#endregion Functions
}
/**
 * The WinJS namespace provides special Windows Library for JavaScript functionality, including Promise and xhr.
 **/
declare module WinJS {
    //#region Properties

    /**
     * Can be set to show the results of a validation process.
     **/
    var validation: boolean;

    //#endregion Properties

    //#region Objects

    /**
     * An error object.
     **/
    class ErrorFromName {
        //#region Constructors

        /**
         * Creates an Error object with the specified name and message properties.
         * @constructor
         * @param name The name of this error. The name is meant to be consumed programmatically and should not be localized.
         * @param message The message for this error. The message is meant to be consumed by humans and should be localized.
         **/
        constructor(name: string, message?: string);

        //#endregion Constructors
    }

    /**
     * Provides a mechanism to schedule work to be done on a value that has not yet been computed. It is an abstraction for managing interactions with asynchronous APIs. For more information about asynchronous programming, see Asynchronous programming. For more information about promises in JavaScript, see Asynchronous programming in JavaScript. For more information about using promises, see the WinJS Promise sample.
     **/
    class Promise<T> {
        //#region Constructors

        /**
         * A promise provides a mechanism to schedule work to be done on a value that has not yet been computed. It is a convenient abstraction for managing interactions with asynchronous APIs. For more information about asynchronous programming, see Asynchronous programming. For more information about promises in JavaScript, see Asynchronous programming in JavaScript. For more information about using promises, see the WinJS Promise sample.
         * @constructor
         * @param init The function that is called during construction of the Promise that contains the implementation of the operation that the Promise will represent. This can be synchronous or asynchronous, depending on the nature of the operation. Note that placing code within this function does not automatically run it asynchronously; that must be done explicitly with other asynchronous APIs such as setImmediate, setTimeout, requestAnimationFrame, and the Windows Runtime asynchronous APIs. The init function is given three arguments: completeDispatch, errorDispatch, progressDispatch. This parameter is optional.
         * @param onCancel The function to call if a consumer of this promise wants to cancel its undone work. Promises are not required to support cancellation.
         **/
        constructor(init?: (completeDispatch: any, errorDispatch: any, progressDispatch: any) => void, onCancel?: Function);

        //#endregion Constructors

        //#region Events

        /**
         * Occurs when there is an error in processing a promise.
         * @param eventInfo An object that contains information about the event.
         **/
        onerror(eventInfo: CustomEvent): void;

        //#endregion Events

        //#region Methods

        /**
         * Adds an event listener for the promise.
         * @param type The type (name) of the event.
         * @param listener The listener to invoke when the event is raised.
         * @param capture true to initiate capture, otherwise false.
         **/
        addEventListener(type: string, listener: Function, capture?: boolean): void;

        /**
         * Returns a promise that is fulfilled when one of the input promises has been fulfilled.
         * @param value An array that contains Promise objects or objects whose property values include Promise objects.
         * @returns A promise that on fulfillment yields the value of the input (complete or error).
         **/
        static any(value: Promise<any>[]): Promise<any>;

        /**
         * Returns a promise. If the object is already a Promise it is returned; otherwise the object is wrapped in a Promise. You can use this function when you need to treat a non-Promise object like a Promise, for example when you are calling a function that expects a promise, but already have the value needed rather than needing to get it asynchronously.
         * @param value The value to be treated as a Promise.
         * @returns The promise.
         **/
        static as<U>(value?: U): Promise<U>;

        /**
         * Attempts to cancel the fulfillment of a promised value. If the promise hasn't already been fulfilled and cancellation is supported, the promise enters the error state with a value of Error("Canceled").
         **/
        cancel(): void;

        /**
         * Raises an event of the specified type and properties.
         * @param type The type (name) of the event.
         * @param details The set of additional properties to be attached to the event object.
         * @returns true if preventDefault was called on the event; otherwise, false.
         **/
        dispatchEvent(type: string, details: any): boolean;

        /**
         * Allows you to specify the work to be done on the fulfillment of the promised value, the error handling to be performed if the promise fails to fulfill a value, and the handling of progress notifications along the way. After the handlers have finished executing, this function throws any error that would have been returned from then as a promise in the error state. For more information about the differences between then and done, see the following topics: Quickstart: using promises in JavaScript How to handle errors when using promises in JavaScript Chaining promises in JavaScript.
         * @param onComplete The function to be called if the promise is fulfilled successfully with a value. The fulfilled value is passed as the single argument. If the value is null, the fulfilled value is returned. The value returned from the function becomes the fulfilled value of the promise returned by then. If an exception is thrown while executing the function, the promise returned by then moves into the error state.
         * @param onError The function to be called if the promise is fulfilled with an error. The error is passed as the single argument. If it is null, the error is forwarded. The value returned from the function is the fulfilled value of the promise returned by then.
         * @param onProgress The function to be called if the promise reports progress. Data about the progress is passed as the single argument. Promises are not required to support progress.
         **/
        done<U>(onComplete?: (value: T) => any, onError?: (error: any) => any, onProgress?: (progress: any) => void): void;

        /**
         * Determines whether a value fulfills the promise contract.
         * @param value A value that may be a promise.
         * @returns true if the object conforms to the promise contract (has a then function), otherwise false.
         **/
        static is(value: any): boolean;

        /**
         * Creates a Promise that is fulfilled when all the values are fulfilled.
         * @param values An object whose members contain values, some of which may be promises.
         * @returns A Promise whose value is an object with the same field names as those of the object in the values parameter, where each field value is the fulfilled value of a promise.
         **/
        static join(values: any): Promise<any>;

        /**
         * Removes an event listener from the control.
         * @param eventType The type (name) of the event.
         * @param listener The listener to remove.
         * @param capture Specifies whether or not to initiate capture.
         **/
        removeEventListener(eventType: string, listener: Function, capture?: boolean): void;

        /**
         * Allows you to specify the work to be done on the fulfillment of the promised value, the error handling to be performed if the promise fails to fulfill a value, and the handling of progress notifications along the way. For more information about the differences between then and done, see the following topics: Quickstart: using promises in JavaScript How to handle errors when using promises in JavaScript Chaining promises in JavaScript.
         * @param onComplete The function to be called if the promise is fulfilled successfully with a value. The value is passed as the single argument. If the value is null, the value is returned. The value returned from the function becomes the fulfilled value of the promise returned by then. If an exception is thrown while this function is being executed, the promise returned by then moves into the error state.
         * @param onError The function to be called if the promise is fulfilled with an error. The error is passed as the single argument. In different cases this object may be of different types, so it is necessary to test the object for the properties you expect. If the error is null, it is forwarded. The value returned from the function becomes the value of the promise returned by the then function.
         * @param onProgress The function to be called if the promise reports progress. Data about the progress is passed as the single argument. Promises are not required to support progress.
         * @returns The promise whose value is the result of executing the onComplete function.
         **/
        then<U>(onComplete?: (value: T) => Promise<U>, onError?: (error: any) => Promise<U>, onProgress?: (progress: any) => void): Promise<U>;

        /**
         * Allows you to specify the work to be done on the fulfillment of the promised value, the error handling to be performed if the promise fails to fulfill a value, and the handling of progress notifications along the way. For more information about the differences between then and done, see the following topics: Quickstart: using promises in JavaScript How to handle errors when using promises in JavaScript Chaining promises in JavaScript.
         * @param onComplete The function to be called if the promise is fulfilled successfully with a value. The value is passed as the single argument. If the value is null, the value is returned. The value returned from the function becomes the fulfilled value of the promise returned by then. If an exception is thrown while this function is being executed, the promise returned by then moves into the error state.
         * @param onError The function to be called if the promise is fulfilled with an error. The error is passed as the single argument. In different cases this object may be of different types, so it is necessary to test the object for the properties you expect. If the error is null, it is forwarded. The value returned from the function becomes the value of the promise returned by the then function.
         * @param onProgress The function to be called if the promise reports progress. Data about the progress is passed as the single argument. Promises are not required to support progress.
         * @returns The promise whose value is the result of executing the onComplete function.
         **/
        then<U>(onComplete?: (value: T) => Promise<U>, onError?: (error: any) => U, onProgress?: (progress: any) => void): Promise<U>;

        /**
         * Allows you to specify the work to be done on the fulfillment of the promised value, the error handling to be performed if the promise fails to fulfill a value, and the handling of progress notifications along the way. For more information about the differences between then and done, see the following topics: Quickstart: using promises in JavaScript How to handle errors when using promises in JavaScript Chaining promises in JavaScript.
         * @param onComplete The function to be called if the promise is fulfilled successfully with a value. The value is passed as the single argument. If the value is null, the value is returned. The value returned from the function becomes the fulfilled value of the promise returned by then. If an exception is thrown while this function is being executed, the promise returned by then moves into the error state.
         * @param onError The function to be called if the promise is fulfilled with an error. The error is passed as the single argument. In different cases this object may be of different types, so it is necessary to test the object for the properties you expect. If the error is null, it is forwarded. The value returned from the function becomes the value of the promise returned by the then function.
         * @param onProgress The function to be called if the promise reports progress. Data about the progress is passed as the single argument. Promises are not required to support progress.
         * @returns The promise whose value is the result of executing the onComplete function.
         **/
        then<U>(onComplete?: (value: T) => U, onError?: (error: any) => Promise<U>, onProgress?: (progress: any) => void): Promise<U>;

        /**
         * Allows you to specify the work to be done on the fulfillment of the promised value, the error handling to be performed if the promise fails to fulfill a value, and the handling of progress notifications along the way. For more information about the differences between then and done, see the following topics: Quickstart: using promises in JavaScript How to handle errors when using promises in JavaScript Chaining promises in JavaScript.
         * @param onComplete The function to be called if the promise is fulfilled successfully with a value. The value is passed as the single argument. If the value is null, the value is returned. The value returned from the function becomes the fulfilled value of the promise returned by then. If an exception is thrown while this function is being executed, the promise returned by then moves into the error state.
         * @param onError The function to be called if the promise is fulfilled with an error. The error is passed as the single argument. In different cases this object may be of different types, so it is necessary to test the object for the properties you expect. If the error is null, it is forwarded. The value returned from the function becomes the value of the promise returned by the then function.
         * @param onProgress The function to be called if the promise reports progress. Data about the progress is passed as the single argument. Promises are not required to support progress.
         * @returns The promise whose value is the result of executing the onComplete function.
         **/
        then<U>(onComplete?: (value: T) => U, onError?: (error: any) => U, onProgress?: (progress: any) => void): Promise<U>;

        /**
         * Performs an operation on all the input promises and returns a promise that has the shape of the input and contains the result of the operation that has been performed on each input.
         * @param values A set of values (which could be either an array or an object) of which some or all are promises..
         * @param complete The function to be called if the promise is fulfilled with a value. This function takes a single argument, which is the fulfilled value of the promise.
         * @param error The function to be called if the promise is fulfilled with an error. This function takes a single argument, which is the error value of the promise.
         * @param progress The function to be called if the promise reports progress. This function takes a single argument, which is the data about the progress of the promise. Promises are not required to support progress.
         * @returns A Promise that is the result of calling join on the values parameter.
         **/
        static thenEach(values: any, complete?: (value: any) => void, error?: (error: any) => void, progress?: (progress: any) => void): Promise<any>;

        /**
         * This method has two forms: WinJS.Promise.timeout(timeout) and WinJS.Promise.timeout(timeout, promise). WinJS.Promise.timeout(timeout) creates a promise that is completed asynchronously after the specified timeout, essentially wrapping a call to setTimeout within a promise. WinJS.Promise.timeout(timeout, promise) sets a timeout period for completion of the specified promise, automatically canceling the promise if it is not completed within the timeout period.
         * @param timeout The timeout period in milliseconds. If this value is zero or not specified, msSetImmediate is called, otherwise setTimeout is called.
         * @param promise Optional. A promise that will be canceled if it doesn't complete within the timeout period.
         * @returns If the promise parameter is omitted, returns a promise that will be fulfilled after the timeout period. If the promise paramater is provided, the same promise is returned.
         **/
        static timeout(timeout: number, promise?: Promise<any>): Promise<any>;

        /**
         * Wraps a non-promise value in a promise. This method is like wrapError, which allows you to produce a Promise in error conditions, in that it allows you to return a Promise in success conditions.
         * @param value Some non-promise value to be wrapped in a promise.
         * @returns A promise that is successfully fulfilled with the specified value.
         **/
        static wrap<U>(value: U): Promise<U>;

        /**
         * Wraps a non-promise error value in a promise. You can use this function if you need to pass an error to a function that requires a promise.
         * @param error A non-promise error value to be wrapped in a promise.
         * @returns A promise that is in an error state with the specified value.
         **/
        static wrapError<U>(error: U): Promise<U>;

        //#endregion Methods
    }

    //#endregion Objects

    //#region Functions

    /**
     * You can provide an implementation of this method yourself, or use WinJS.Utilities.startLog to create one that logs to the JavaScript console.
     * @param message The message to log.
     * @param tags The tag or tags to categorize the message (winjs, winjs controls, etc.).
     * @param type The type of message (error, warning, info, etc.).
     **/
    function log(message: string, tags: string, type: string): void;

    /**
     * This method has been deprecated. Strict processing is always on; you don't have to call this method to turn it on.
     **/
    function strictProcessing(): void;

    /**
     * Wraps calls to XMLHttpRequest in a promise.
     * @param options The options that are applied to the XMLHttpRequest object, as follows: type, url, user, password, responseType, headers, data, customRequestInitializer.
     * @returns A promise that returns the XMLHttpRequest object when it completes.
     **/
    function xhr(options: IXHROptions): Promise<XMLHttpRequest>;

    //#endregion Functions

    //#region Interfaces

    interface IXHROptions {
        type?: string;
        url: string;
        user?: string;
        password?: string;
        headers?: any;
        data: any;
        responseType?: string;
    }

    //#endregion Interfaces
}
/**
 * Provides helper functions for defining namespaces. For more information, see Organizing your code with WinJS.Namespace.
 **/
declare module WinJS.Namespace {
    //#region Functions

    /**
     * Defines a new namespace with the specified name. For more information, see Organizing your code with WinJS.Namespace.
     * @param name The name of the namespace. This could be a dot-separated name for nested namespaces.
     * @param members The members of the new namespace.
     * @returns The newly-defined namespace.
     **/
    function define(name?: string, members?: any): any;

    /**
     * Defines a new namespace with the specified name under the specified parent namespace. For more information, see Organizing your code with WinJS.Namespace.
     * @param parentNamespace The parent namespace.
     * @param name The name of the new namespace.
     * @param members The members of the new namespace.
     * @returns The newly-defined namespace.
     **/
    function defineWithParent(parentNamespace?: any, name?: string, members?: any): any;

    //#endregion Functions
}
/**
 * Provides functionality for dealing with basic navigation, including the navigation stack.
 **/
declare module WinJS.Navigation {
    //#region Properties

    /**
     * Determines whether it is possible to navigate backwards.
     **/
    var canGoBack: boolean;

    /**
     * Determines if it is possible to navigate forwards.
     **/
    var canGoForward: boolean;

    /**
     * Gets or sets the navigation history.
     **/
    var history: any;

    /**
     * Gets or sets the current location.
     **/
    var location: string;

    /**
     * Gets or sets a user-defined object that represents the state associated with the current location.
     **/
    var state: any;

    //#endregion Properties

    //#region Functions

    /**
     * Adds an event listener to the control.
     * @param eventType The type (name) of the event.
     * @param listener The listener to invoke when the event gets raised.
     * @param capture If true, specifies that capture should be initiated, otherwise false.
     **/
    function addEventListener(eventType: string, listener: Function, capture?: boolean): void;

    /**
     * Navigates backwards.
     * @param distance The number of entries to go back into the history.
     * @returns A promise that is completed with a value that indicates whether or not the navigation was successful.
     **/
    function back(distance?: number): Promise<boolean>;

    /**
     * Navigates forwards.
     * @param distance The number of entries to go forward.
     * @returns A promise that is completed with a value that indicates whether or not the navigation was successful.
     **/
    function forward(distance?: number): Promise<boolean>;

    /**
     * Navigates to a location.
     * @param location The location to navigate to. Generally the location is a string containing the URL, but it may be anything.
     * @param initialState A user-defined object that represents the navigation state that may be accessed through state.
     * @returns A promise that is completed with a value that indicates whether or not the navigation was successful (true if successful, otherwise false).
     **/
    function navigate(location: any, initialState?: any): Promise<boolean>;

    /**
     * Removes an event listener from the control.
     * @param eventType The type (name) of the event.
     * @param listener The listener to remove.
     * @param useCapture Specifies whether or not to initiate capture.
     **/
    function removeEventListener(eventType: string, listener: Function, useCapture?: boolean): void;

    //#endregion Functions

    //#region Events

    /**
     * Occurs before navigation.
     * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: location, state.
     **/
    function onbeforenavigate(eventInfo: CustomEvent): void;

    /**
     * Occurs after navigation has taken place.
     * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: location, state.
     **/
    function onnavigated(eventInfo: CustomEvent): void;

    /**
     * Occurs when navigation is taking place.
     * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: location, state.
     **/
    function onnavigating(eventInfo: CustomEvent): void;

    //#endregion Events
}
/**
 * Provides functions for accessing resources and localizing content.
 **/
declare module WinJS.Resources {
    //#region Functions

    /**
     * Registers an event handler for the specified event. Use this method to register for events that are related to resources, such as when the app's language, scale, or contrast changes.
     * @param type The name of the event to handle.
     * @param listener The listener (event handler function) to associate with the event.
     * @param useCapture Set to true to register the listener for the capturing phase; otherwise, set to false to register the listener for the bubbling phase.
     **/
    function addEventListener(type: string, listener: Function, useCapture?: boolean): void;

    /**
     * Raises an event of the specified type and with the specified additional properties.
     * @param type The name of the event to raise.
     * @param details The set of additional properties to attach to the event object.
     **/
    function dispatchEvent(type: string, details: any): void;

    /**
     * Retrieves the resource string that has the specified resource identifier.
     * @param resourceId The resource ID of the string to retrieve.
     * @returns An object that can contain these properties: value, empty, lang.
     **/
    function getString(resourceId: string): { value: string; empty?: boolean; lang?: string };

    /**
     * Processes data-win-res attributes on elements and replaces attributes and properties with resource strings.
     * @param rootElement The element to process. The element and its child elements will be processed. If an element isn't specified, the entire document is processed.
     **/
    function processAll(rootElement?: HTMLElement): void;

    /**
     * Removes an event listener that the addEventListener method registered.
     * @param type The name of the event that the event listener is registered for.
     * @param listener The listener (event handler function) to remove.
     * @param useCapture Set to true to remove the capturing phase listener; set to false to remove the bubbling phase listener.
     **/
    function removeEventListener(type: string, listener: Function, useCapture?: boolean): void;

    //#endregion Functions

    //#region Events

    /**
     * Occurs when the user changes the system's language or contrast, or the scale of the display, or when the user changes any of the items in the current context's qualifier values list. For more info about the current context's qualifier values list, see the Remarks section.
     * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.qualifier, detail.changed.
     **/
    function oncontextchanged(eventInfo: CustomEvent): void;

    //#endregion Events
}
/**
 * Provides access to the Windows animations. These functions provide developers with the ability to use animations in their custom controls that are consistent with animations used by Windows controls.
 **/
declare module WinJS.UI.Animation {
    //#region Functions

    /**
     * Creates an object that performs an animation that adds an item or items to a list.
     * @param added Element or elements to add to the list.
     * @param affected Element or elements affected by the added items.
     * @returns An object whose execute method is used to execute the animation. The execute method returns a Promise that completes when the animation is finished.
     **/
    function createAddToListAnimation(added: any, affected: any): IAnimationMethodResponse;

    /**
     * Creates an object that performs an animation that adds an item or items to a list of search results.
     * @param added Element or elements to add to the list.
     * @param affected Element or elements affected by the added items.
     * @returns An object whose execute method is used to execute the animation. The execute method returns a Promise that completes when the animation is finished.
     **/
    function createAddToSearchListAnimation(added: any, affected: any): IAnimationMethodResponse;

    /**
     * Creates an object that performs an animation that collapses a list.
     * @param hidden Element or elements hidden as a result of the collapse.
     * @param affected Element or elements affected by the hidden items.
     * @returns An object whose execute method is used to execute the animation. The execute method returns a Promise that completes when the animation is finished.
     **/
    function createCollapseAnimation(hidden: any, affected: any): IAnimationMethodResponse;

    /**
     * Creates an object that performs an animation that removes an item or items from a list.
     * @param deleted Element or elements to delete from the list.
     * @param remaining Element or elements affected by the removal of the deleted items.
     * @returns An object whose execute method is used to execute the animation. The execute method returns a Promise that completes when the animation is finished.
     **/
    function createDeleteFromListAnimation(deleted: any, remaining: any): IAnimationMethodResponse;

    /**
     * Creates an object that performs an animation that removes an item or items from a list of search results.
     * @param deleted Element or elements to delete from the list.
     * @param remaining Element or elements affected by the removal of the deleted items.
     * @returns An object whose execute method is used to execute the animation. The execute method returns a Promise that completes when the animation is finished.
     **/
    function createDeleteFromSearchListAnimation(deleted: any, remaining: any): IAnimationMethodResponse;

    /**
     * Creates an object that performs an animation that expands a list.
     * @param revealed Element or elements revealed by the expansion.
     * @param affected Element or elements affected by the newly revealed items.
     * @returns An object whose execute method is used to execute the animation. The execute method returns a Promise that completes when the animation is finished.
     **/
    function createExpandAnimation(revealed: any, affected: any): IAnimationMethodResponse;

    /**
     * Creates an object that performs a peek animation.
     * @param element Element or elements involved in the peek.
     * @returns An object whose execute method is used to execute the animation. The execute method returns a Promise that completes when the animation is finished.
     **/
    function createPeekAnimation(element: any): IAnimationMethodResponse;

    /**
     * Creates an object that performs an animation that moves an item or items.
     * @param element Element or elements involved in the reposition.
     * @returns An object whose execute method is used to execute the animation. The execute method returns a Promise object that completes when the animation is finished.
     **/
    function createRepositionAnimation(element: any): IAnimationMethodResponse;

    /**
     * Performs an animation that fades an item or items in, fading out existing items that occupy the same space.
     * @param incoming Element or elements being faded in.
     * @param outgoing Element or elements being replaced.
     * @returns An object that completes when the animation has finished.
     **/
    function crossFade(incoming: any, outgoing: any): Promise<any>;

    /**
     * Performs an animation when a dragged object is moved such that dropping it in that position would move other items. The potentially affected items are animated out of the way to show where the object would be dropped.
     * @param target Element or elements that the dragged object would cause to be moved if it were dropped.
     * @param offset Initial offsets where the animated objects begin relative to their final position at the end of the animation. Set this parameter to null to use the recommended default offset. Note When the incoming parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @returns An object that completes when the animation is finished.
     **/
    function dragBetweenEnter(target: any, offset: any): Promise<any>;

    /**
     * Performs an animation when a dragged object is moved away from items that it had previously involved in a dragBetweenEnter animation. The affected objects are animated back to their original positions.
     * @param target Element or elements that the dragged object would no longer cause to be displaced, due to its moving away. This should be the same element or element collection passed as the target parameter in the dragBetweenEnter animation.
     * @returns An object that completes when the animation is finished.
     **/
    function dragBetweenLeave(target: any): Promise<any>;

    /**
     * Performs an animation when the user finishes dragging an object.
     * @param dragSource Element or elements that were dragged.
     * @param offset Initial offset from the drop point. The dropped object begins at the offset and animates to its final position at the drop point. Note When the element parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @param affected Element or elements whose position the dropped object affects. Typically, this is all other items in a reorderable list. This should be the same element or element collection passed as the affected parameter in the dragSourceStart animation.
     * @returns An object that completes when the animation is finished.
     **/
    function dragSourceEnd(dragSource: any, offset: any, affected?: any): Promise<any>;

    /**
     * Performs an animation when the user begins to drag an object.
     * @param dragSource Element or elements being dragged.
     * @param affected Element or elements whose position is affected by the movement of the dragged object. Typically, this is all other items in a reorderable list.
     * @returns An object that completes when the animation is finished.
     **/
    function dragSourceStart(dragSource: any, affected?: any): Promise<any>;

    /**
     * Performs an animation that displays one or more elements on a page.
     * @param incoming Element or elements that compose the incoming content.
     * @param offset Initial offsets where the animated objects begin relative to their final position at the end of the animation. Set this parameter to null to use the recommended default offset. Note When the incoming parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @param options Optional. Set this value to { mechanism: "transition" } to play the animation using CSS transitions instead of the default CSS animations. In some cases this can result in improved performance.
     * @returns An object that completes when the animation is finished.
     **/
    function enterContent(incoming: any, offset: any, options?: any): Promise<any>;

    /**
     * Performs an animation that shows a new page of content, either when transitioning between pages in a running app or when displaying the first content in a newly launched app.
     * @param element Element or an array of elements that represent the content. If element refers to an array of elements, the elements enter in array order.
     * @param offset An initial offset where the element or elements begin relative to their final position at the end of the animation. Set this parameter to null to use the recommended default offset. Note When the element parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @returns An object that completes when the animation is finished.
     **/
    function enterPage(element: any, offset: any): Promise<any>;

    /**
     * Performs an animation that hides one or more elements on a page.
     * @param outgoing Element or elements that compose the outgoing content.
     * @param offset Initial offsets where the animated objects begin relative to their final position at the end of the animation. Set this parameter to null to use the recommended default offset. Note When the incoming parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @returns An object that completes when the animation is finished.
     **/
    function exitContent(outgoing: any, offset: any): Promise<any>;

    /**
     * Performs an animation that dismisses the current page when transitioning between pages in an app.
     * @param outgoing Element or elements that compose the outgoing page.
     * @param offset Initial offsets where the animated objects begin relative to their final position at the end of the animation. Set this parameter to null to use the recommended default offset. Note When the incoming parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @returns An object that completes when the animation is finished.
     **/
    function exitPage(outgoing: any, offset: any): Promise<any>;

    /**
     * Performs an animation that fades an item or set of items into view.
     * @param shown Element or elements being faded in.
     * @returns An object that completes when the animation has finished. Use this object when subsequent actions need this animation to finish before they take place.
     **/
    function fadeIn(shown: any): Promise<any>;

    /**
     * Performs an animation that fades an item or set of items out of view.
     * @param hidden Element or elements being faded out.
     * @returns An object that completes when the animation is finished.
     **/
    function fadeOut(hidden: any): Promise<any>;

    /**
     * Performs an animation that hides edge-based user interface (UI).
     * @param element Element or elements that are being hidden.
     * @param offset Initial offsets where the animated objects begin relative to their final position at the end of the animation. Offsets should be the chosen so that the elements end the animation just off-screen. Note When the element parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @param options Optional. Set this value to { mechanism: "transition" } to play the animation using CSS transitions instead of the default CSS animations. In some cases this can result in improved performance.
     * @returns An object that completes when the animation is finished.
     **/
    function hideEdgeUI(element: any, offset: any, options?: any): Promise<any>;

    /**
     * Performs an animation that hides a panel.
     * @param element Element or elements that are being hidden.
     * @param offset Initial offsets where the animated objects begin relative to their final position at the end of the animation. Offsets should be the chosen so that the elements end the animation just off-screen. Note When the element parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @returns An object that completes when the animation is finished.
     **/
    function hidePanel(element: any, offset: any): Promise<any>;

    /**
     * Performs an animation that removes pop-up user interface (UI).
     * @param element Element or elements that are being hidden.
     * @returns An object that completes when the animation is finished.
     **/
    function hidePopup(element: any): Promise<any>;

    /**
     * Performs an animation when a pointer is pressed on an object.
     * @param element Element or elements on which the pointer is pressed.
     * @returns An object that completes when the animation is finished.
     **/
    function pointerDown(element: any): Promise<any>;

    /**
     * Performs an animation when a pointer is released.
     * @param element Element or elements that the pointer was pressed on.
     * @returns An object that completes when the animation is finished.
     **/
    function pointerUp(element: any): Promise<any>;

    /**
     * Performs an animation that slides a narrow, edge-based user interface (UI) into view.
     * @param element Element or elements that are being shown.
     * @param offset Initial offsets where the animated objects begin relative to their final position at the end of the animation. Offsets should be the chosen so that the elements begin the animation from just off-screen. Note When the element parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @param options Optional. Set this value to { mechanism: "transition" } to play the animation using CSS transitions instead of the default CSS animations. In some cases this can result in improved performance.
     * @returns An object that completes when the animation is finished.
     **/
    function showEdgeUI(element: any, offset: any, options?: any): Promise<any>;

    /**
     * Performs an animation that slides a large panel user interface (UI) into view.
     * @param element Element or elements that are being shown.
     * @param offset Initial offsets where the animated objects begin relative to their final position at the end of the animation. Offsets should be the chosen so that the elements begin the animation from just off-screen. Note When the element parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @returns An object that completes when the animation is finished.
     **/
    function showPanel(element: any, offset: any): Promise<any>;

    /**
     * Performs an animation that displays a pop-up user interface (UI).
     * @param element Element or elements that are being shown.
     * @param offset Initial offsets where the animated objects begin relative to their final position at the end of the animation. Offsets should be the chosen so that the elements begin the animation from just off-screen. Set this parameter to null to use the recommended default offset. Note When the element parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @returns An object that completes when the animation is finished.
     **/
    function showPopup(element: any, offset: any): Promise<any>;

    /**
     * Performs a deselection animation in response to a swipe interaction.
     * @param deselected Element or elements that become unselected.
     * @param selection Element or elements that represent the selection, typically a check mark.
     * @returns An object that completes when the animation is finished.
     **/
    function swipeDeselect(deselected: any, selection: any): Promise<any>;

    /**
     * Performs an animation that reveals an item or items in response to a swipe interaction.
     * @param target Element or elements being revealed.
     * @param offset An initial offset where the animated objects begin relative to their final position at the end of the animation. Set this parameter to null to use the recommended default offset. Note When the incoming parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @returns An object that completes when the animation is finished.
     **/
    function swipeReveal(target: any, offset: any): Promise<any>;

    /**
     * Performs a selection animation in response to a swipe interaction.
     * @param selected Element or elements being selected.
     * @param selection Element or elements that show that something is selected, typically a check mark.
     * @returns An object that completes when the animation is finished.
     **/
    function swipeSelect(selected: any, selection: any): Promise<any>;

    /**
     * Performs an animation that updates a badge.
     * @param incoming Element or elements that comprise the new badge.
     * @param offset Initial offsets where incoming animated objects begin relative to their final position at the end of the animation. Set this parameter to null to use the recommended default offset. Note When the incoming parameter specifies an array of elements, the offset parameter can specify an offset array with each item specified for its corresponding element array item. If the array of offsets is smaller than the array of elements, the last offset is applied to all remaining elements.
     * @returns An object that completes when the animation is finished.
     **/
    function updateBadge(incoming: any, offset: any): Promise<any>;

    //#endregion Functions

    //#region Interfaces

    interface IAnimationMethodResponse {
        execute(): Promise<any>;
    }

    //#endregion Interfaces
}
/**
 * Provides controls and objects that manipulate data.
 **/
declare module WinJS.UI {
    //#region Enumerations

    /**
     * Specifies an icon that appears in an AppBarCommand object.
     **/
    enum AppBarIcon {
        previous,
        next,
        play,
        pause,
        edit,
        save,
        clear,
        delete,
        remove,
        add,
        cancel,
        accept,
        more,
        redo,
        undo,
        home,
        up,
        forward,
        right,
        back,
        left,
        favorite,
        camera,
        settings,
        video,
        sync,
        download,
        mail,
        find,
        help,
        upload,
        emoji,
        twopage,
        leavechat,
        mailforward,
        clock,
        send,
        crop,
        rotatecamera,
        people,
        closepane,
        openpane,
        world,
        flag,
        previewlink,
        globe,
        trim,
        attachcamera,
        zoomin,
        bookmarks,
        document,
        protecteddocument,
        page,
        bullets,
        comment,
        mail2,
        contactinfo,
        hangup,
        viewall,
        mappin,
        phone,
        videochat,
        switch,
        contact,
        rename,
        pin,
        musicinfo,
        go,
        keyboard,
        dockleft,
        dockright,
        dockbottom,
        remote,
        refresh,
        rotate,
        shuffle,
        list,
        shop,
        selectall,
        orientation,
        import,
        importall,
        browsephotos,
        webcam,
        pictures,
        savelocal,
        caption,
        stop,
        showresults,
        volume,
        repair,
        message,
        page2,
        calendarday,
        calendarweek,
        calendar,
        characters,
        mailreplyall,
        read,
        link,
        accounts,
        showbcc,
        hidebcc,
        cut,
        attach,
        paste,
        filter,
        copy,
        emoji2,
        important,
        mailreply,
        slideshow,
        sort,
        manage,
        allapps,
        disconnectdrive,
        mapdrive,
        newwindow,
        openwith,
        contactpresence,
        priority,
        uploadskydrive,
        gototoday,
        font,
        fontcolor,
        contact2,
        folder,
        audio,
        placeholder,
        view,
        setlockscreen,
        settile,
        cc,
        stopslideshow,
        permissions,
        highlight,
        disableupdates,
        unfavorite,
        unpin,
        openlocal,
        mute,
        italic,
        underline,
        bold,
        movetofolder,
        likedislike,
        dislike,
        like,
        alignright,
        aligncenter,
        alignleft,
        zoom,
        zoomout,
        openfile,
        otheruser,
        admin,
        street,
        map,
        clearselection,
        fontdecrease,
        fontincrease,
        fontsize,
        cellphone,
        reshare,
        tag,
        repeatone,
        repeatall,
        outlinestar,
        solidstar,
        calculator,
        directions,
        target,
        library,
        phonebook,
        memo,
        microphone,
        postupdate,
        backtowindow,
        fullscreen,
        newfolder,
        calendarreply,
        unsyncfolder,
        reporthacked,
        syncfolder,
        blockcontact,
        switchapps,
        addfriend,
        touchpointer,
        gotostart,
        zerobars,
        onebar,
        twobars,
        threebars,
        fourbars,
        scan,
        preview,
    }

    /**
     * Indicates whether the IListDataAdapter was able to provide a count.
     **/
    enum CountResult {
        /**
         * Indicates no count is available.
         **/
        unknown,
    }

    /**
     * Indicates that the IListDataAdapter was unable to provide a count.
     **/
    enum CountError {
        /**
         * An attempt to count items timed out.
         **/
        noResponse,
    }

    /**
     * Describes the status of an IListDataSource.
     **/
    enum DataSourceStatus {
        /**
         * The IListDataSource is ready.
         **/
        ready,
        /**
         * The IListDataSource is still loading.
         **/
        waiting,
        /**
         * The IListDataSource failed to load.
         **/
        failure,
    }

    /**
     * Specifies the type of error that occurred during an edit operation on a IListDataSource or an IListDataAdapter.
     **/
    enum EditError {
        /**
         * The edit operation timed out.
         **/
        noResponse,
        /**
         * The data source cannot be written to.
         **/
        notPermitted,
        /**
         * The item has changed.
         **/
        noLongerMeaningful,
    }

    /**
     * Specifies the type of error encountered when retrieving items from an IListDataAdapter.
     **/
    enum FetchError {
        /**
         * The fetch operation timed out.
         **/
        noResponse,
        /**
         * The specified item could not be located.
         **/
        doesNotExist,
    }

    /**
     * Specifies how group headers in a ListView respond to the tap interaction.
     **/
    enum GroupHeaderTapBehavior {
        /**
         * The group is invoked.
         **/
        invoke,
        /**
         * Nothing happens.
         **/
        none,
    }

    /**
     * Specifies the position of group headers relative to their items in a ListView.
     **/
    enum HeaderPosition {
        /**
         * Group headers appear to the left of items.
         **/
        left,
        /**
         * Group headers appear above items.
         **/
        top,
    }

    /**
     * Specifies that type of animation for which a contentanimating event was raised.
     **/
    enum ListViewAnimationType {
        /**
         * The animation plays when the ListView is first displayed.
         **/
        entrance,
        /**
         * The animation plays when the ListView is changing its content.
         **/
        contentTransition,
    }

    /**
     * Describes the type of object in a ListView.
     **/
    enum ObjectType {
        /**
         * The object is a group header in the list.
         **/
        groupHeader,
        /**
         * The object is an item in the list.
         **/
        item,
    }

    /**
     * Specifies the orientation of a control.
     **/
    enum Orientation {
        /**
         * A horizontal layout.
         **/
        horizontal,
        /**
         * A vertical layout.
         **/
        vertical,
    }

    /**
     * Specifies the selection mode of a ListView.
     **/
    enum SelectionMode {
        /**
         * Items cannot be selected.
         **/
        none,
        /**
         * A single item may be selected.
         **/
        single,
        /**
         * Multiple items may be selected. Clicking additional items adds them to the selection.
         **/
        multi,
    }

    /**
     * Specifies whether elements are selected when the user performs a swipe interaction.
     **/
    enum SwipeBehavior {
        /**
         * The swipe interaction selects the elements touched by the swipe.
         **/
        select,
        /**
         * The swipe interaction does not change which elements are selected.
         **/
        none,
    }

    /**
     * Specifies how items in a ListView respond to the tap interaction.
     **/
    enum TapBehavior {
        /**
         * The item is selected and invoked.
         **/
        directSelect,
        /**
         * The item is selected if was not already selected, and its deselected if it was already selected.
         **/
        toggleSelect,
        /**
         * The item is invoked but not selected.
         **/
        invokeOnly,
        /**
         * Nothing happens.
         **/
        none,
    }

    //#endregion Enumerations

    //#region Interfaces

    /**
     * Contains items that were requested from an IListDataAdapter and provides some information about those items.
     **/
    interface IFetchResult<T> {
        //#region Properties

        /**
         * Gets or sets the index of the requested item in the IListDataAdapter object's data source.
         **/
        absoluteIndex: number;

        /**
         * Gets or sets a value that indicates whether this IFetchResult contains the last items at the end of the IListDataAdapter object's data source.
         **/
        atEnd: boolean;

        /**
         * Gets or sets a value that indicates whether this IFetchResult contains the first items at the beginning of the IListDataAdapter object's data source.
         **/
        atStart: boolean;

        /**
         * Gets or sets the items returned by the fetch operation.
         **/
        items: T[];

        /**
         * Gets or sets the location of the requested item within the items array.
         **/
        offset: number;

        /**
         * Gets or sets the number of items in the IListDataAdapter object's underlying data source.
         **/
        totalCount: number;

        //#endregion Properties
    }

    /**
     * Represents an item in a list.
     **/
    interface IItem<T> {
        //#region Properties

        /**
         * Gets or sets the item's data.
         **/
        data: T;

        /**
         * Gets the group key for the item. This property is only available for items that belong to a grouped data source.
         **/
        groupKey: string;

        /**
         * Gets the temporary ID of the item.
         **/
        handle: string;

        /**
         * Gets the item's index in the IListDataSource.
         **/
        index: number;

        /**
         * Gets or sets the key the identifies the item.
         **/
        key: string;

        //#endregion Properties
    }

    /**
     * Provides a mechanism for retrieving IItem objects asynchronously.
     **/
    interface IItemPromise<T> {
        //#region Events

        /**
         * Occurs when there is an error in processing.
         * @param eventInfo An object that contains information about the event.
         **/
        onerror(eventInfo: CustomEvent): void;

        //#endregion Events

        //#region Methods

        /**
         * Attempts to cancel the fulfillment of a promised value. If the promise hasn't already been fulfilled and cancellation is supported, the promise enters the error state with a value of Error("Canceled").
         **/
        cancel(): void;

        /**
         * Allows you to specify the work to be done on the fulfillment of the promised value, the error handling to be performed if the promise fails to fulfill a value, and the handling of progress notifications along the way. After the handlers have finished executing, this function throws any error that would have been returned from then as a promise in the error state.
         * @param onComplete The function to be called if the promise is fulfilled successfully with a value. The fulfilled value is passed as the single argument. If the value is null, the fulfilled value is returned. The value returned from the function becomes the fulfilled value of the promise returned by then. If an exception is thrown while executing the function, the promise returned by then moves into the error state.
         * @param onError The function to be called if the promise is fulfilled with an error. The error is passed as the single argument. If it is null, the error is forwarded. The value returned from the function is the fulfilled value of the promise returned by then.
         * @param onProgress The function to be called if the promise reports progress. Data about the progress is passed as the single argument. Promises are not required to support progress.
         **/
        done(onComplete: (item: T) => void, onError?: (error: Error) => void, onProgress?: (progressData: any) => void): void;

        /**
         * Stops change notification tracking for the IItem that fulfills this IItemPromise.
         **/
        release(): void;

        /**
         * Begins change notification tracking for the IItem that fulfills this IItemPromise.
         **/
        retain(): void;

        /**
         * Allows you to specify the work to be done on the fulfillment of the promised value, the error handling to be performed if the promise fails to fulfill a value, and the handling of progress notifications along the way.
         * @param onComplete The function to be called if the promise is fulfilled successfully with a value. The value is passed as the single argument. If the value is null, the value is returned. The value returned from the function becomes the fulfilled value of the promise returned by then. If an exception is thrown while this function is being executed, the promise returned by then moves into the error state.
         * @param onError The function to be called if the promise is fulfilled with an error. The error is passed as the single argument. If it is null, the error is forwarded. The value returned from the function becomes the fulfilled value of the promise returned by then.
         * @param onProgress The function to be called if the promise reports progress. Data about the progress is passed as the single argument. Promises are not required to support progress.
         * @returns The promise whose value is the result of executing the complete or error function.
         **/
        then(onComplete: (item: T) => void, onError?: (error: Error) => void, onProgress?: (progressData: any) => void): IItemPromise<T>;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets the temporary ID of the IItem that fulfills this promise.
         **/
        handle: string;

        /**
         * Gets or sets the index of the IItem contained by this IItemPromise.
         **/
        index: number;

        //#endregion Properties
    }

    /**
     * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface. Represents a layout for the ListView.
     **/
    interface ILayout {
        //#region Methods

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param beginScrollPosition The first visible pixel in the ListView. For horizontal layouts, this is the x-coordinate of the pixel. For vertical layouts, this is the y-coordinate.
         * @param wholeItem true if the item must be completely visible; otherwise, false if its ok for the item to be partially visible. Promise.
         * @returns A Promise for the index of the first visible item at the specified point.
         **/
        calculateFirstVisible(beginScrollPosition: number, wholeItem: boolean): Promise<any>;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param endScrollPosition The last visible pixel in the ListView. For horizontal layouts, this is the x-coordinate of the pixel. For vertical layouts, this is the y-coordinate.
         * @param wholeItem true if the item must be completely visible; otherwise, false if its ok for the item to be partially visible. Promise.
         * @returns A Promise for the index of the last visible item at the specified point.
         **/
        calculateLastVisible(endScrollPosition: number, wholeItem: boolean): Promise<any>;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @returns A object that has these properties: animationPromise, newEndIndex.
         **/
        endLayout(): any;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param itemIndex The index of the item.
         * @returns A Promise that returns an object with these properties: left, top, contentWidth, contentHeight, totalWidth, totalHeight.
         **/
        getItemPosition(itemIndex: number): Promise<any>;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param itemIndex The data source index of the current item.
         * @param element The element for the current item.
         * @param keyPressed The key that was pressed. This function must check for the arrow keys (leftArrow, upArrow, rightArrow, downArrow), pageDown, and pageUp and determine which item the user navigated to.
         * @returns A Promise that contains the index of the next item (This item becomes the current item).
         **/
        getKeyboardNavigatedItem(itemIndex: number, element: HTMLElement, keyPressed: WinJS.Utilities.Key): Promise<number>;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @returns A Promise that returns an object that has these properties: beginScrollPosition, endScrollPosition.
         **/
        getScrollBarRange(): Promise<any>;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param x The x-coordinate to test.
         * @param y The y-coordinate to test.
         **/
        hitTest(x: number, y: number): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param elements The elements that represent the items that were added.
         **/
        itemsAdded(elements: HTMLElement[]): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         **/
        itemsMoved(): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param elements The elements that represent the items that were removed.
         **/
        itemsRemoved(elements: HTMLElement[]): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param groupIndex The index of the group in the group data source.
         * @param element The element to render for the group header.
         **/
        layoutHeader(groupIndex: number, element: HTMLElement): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param itemIndex The index of the item in the data source.
         * @param element The element to render for the item.
         **/
        layoutItem(itemIndex: number, element: HTMLElement): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param element The element that represents a header in the data source.
         **/
        prepareHeader(element: HTMLElement): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param element An element that represents an item in the data source.
         **/
        prepareItem(element: HTMLElement): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param element The element being released.
         **/
        releaseItem(element: HTMLElement): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         **/
        reset(): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param site The layout site for the layout. You can use this object to query the hosting ListView for info you might need to lay out items.
         **/
        setSite(site: ILayoutSite): void;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         * @param beginScrollPosition The starting pixel of the area to which the items are rendered.
         * @param endScrollPosition The last pixel of the area to which the items are rendered.
         * @param count The upper bound of the number of items to render.
         * @returns A Promise that returns an object that has these properties: beginIndex, endIndex.
         **/
        startLayout(beginScrollPosition: number, endScrollPosition: number, count: number): Promise<any>;

        //#endregion Methods

        //#region Properties

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayout2 interface.
         **/
        horizontal: boolean;

        //#endregion Properties
    }

    /**
     * Represents a layout for the ListView.
     **/
    interface ILayout2 {
        //#region Methods

        /**
         * Called when the ListView finishes a drag operation.
         **/
        dragLeave(): void;

        /**
         * Called when the ListView initiates a drag operation.
         * @param x The x-coordinate of the drag.
         * @param y The y-coordinate of the drag.
         * @param dragInfo An object that indicates whether the item is selected.
         **/
        dragOver(x: number, y: number, dragInfo: number): void;

        /**
         * Called when the ListView requests that the ILayout2 execute animations.
         **/
        executeAnimations(): void;

        /**
         * Determines the next item to receive keyboard focus.
         * @param currentItem An object that describes the current item. It has these properties: index, type.
         * @param pressedKey The key that was pressed.
         * @returns An object that describes the next item that should receive focus. It has these properties: index, type.
         **/
        getAdjacent(currentItem: any, pressedKey: WinJS.Utilities.Key): any;

        /**
         * Gets the item at the specified hit-test coordinates. These coordinates are absolute coordinates (they are not relative to the layout's content area).
         * @param x The x-coordinate to test for.
         * @param y The y-coordinate to test for.
         * @returns An object that describes the item at the hit test coordinates. It has these properties: type, index.
         **/
        hitTest(x: number, y: number): any;

        /**
         * Sets the rendering site and specifies whether the layout supports groups. This method is called by the ListView to initialize the layout.
         * @param site The rendering site for the layout.
         * @param groupsEnabled Set to true if this layout supports groups; set to false if it does not.
         **/
        initialize(site: ILayoutSite2, groupsEnabled: boolean): void;

        /**
         * Retrieves the indexes of the items in the specified pixel range.
         * @param firstPixel The first pixel the range of items falls between.
         * @param lastPixel The last pixel the range of items falls between.
         **/
        itemsFromRange(firstPixel: number, lastPixel: number): void;

        /**
         * Performs a layout pass.
         * @param tree A structure representing the layout tree that is returned from the ListView.
         * @param changedRange An object that lists the index of the first item in the changed item range. This object has these properties: startIndex.
         * @param modifiedItems An object that contains the old and new indexes of the items that have been modified in the tree.
         * @param modifiedGroups An object that contains the old and new indexes of the group elements that have been modified in the tree.
         * @returns A Promise that executes after layout is complete, or an object that contains two Promise objects: realizedRangeComplete, layoutComplete.
         **/
        layout(tree: any, changedRange: any, modifiedItems: any, modifiedGroups: any): any;

        /**
         * Called when the ListView requests that the ILayout2 set up animations.
         **/
        setupAnimations(): void;

        /**
         * Releases resources that were obtained during the call to initialize.
         **/
        uninitialize(): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets the orientation of the layout.
         **/
        orientation: any;

        //#endregion Properties
    }

    /**
     * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use the ILayoutSite2 interface. Represents a rendering site for an ILayout.
     **/
    interface ILayoutSite {
        //#region Properties

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use a the ILayoutSite2 interface.
         **/
        animationsDisabled: boolean;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use a the ILayoutSite2 interface.
         **/
        itemSurface: HTMLElement;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use a the ILayoutSite2 interface.
         **/
        rtl: boolean;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use a the ILayoutSite2 interface.
         **/
        scrollbarPos: number;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use a the ILayoutSite2 interface.
         **/
        surface: HTMLElement;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use a the ILayoutSite2 interface.
         **/
        viewport: HTMLElement;

        /**
         * This API is no longer supported. Starting with the Windows Library for JavaScript 2.0 Preview, use a the ILayoutSite2 interface.
         **/
        viewportSize: any;

        //#endregion Properties
    }

    /**
     * Represents a rendering site for an ILayout2.
     **/
    interface ILayoutSite2 {
        //#region Properties

        /**
         * Gets the number of groups in the site.
         **/
        groupCount: number;

        /**
         * Gets the number of items in the site.
         **/
        itemCount: Promise<number>;

        /**
         * Gets the pixel range of the realization area.
         **/
        realizedRange: any;

        /**
         * Gets the tree for use by an object that implements the ILayout2 interface.
         **/
        tree: any;

        /**
         * Gets the pixel range of visible items in the site.
         **/
        visibleRange: any;

        //#endregion Properties
    }

    /**
     * Retrieves items from a IListDataSource, enumerates the contents of a IListDataSource, and can optionally register for change notifications.
     **/
    interface IListBinding<T> {
        //#region Methods

        /**
         * Retrieves the current item.
         * @returns An IItemPromise that contains the current item. If the cursor has moved past the start or end of the list, the promise completes with a value of null. If the current item has been moved or deleted, the promise returns an error.
         **/
        current(): IItemPromise<IItem<T>>;

        /**
         * Gets the first item from the IListDataSource and makes it the current item.
         * @returns An IItemPromise that contains the requested IItem. If the list is empty, the promise completes with a value of null.
         **/
        first(): IItemPromise<IItem<T>>;

        /**
         * Retrieves the item from the IListDataSource that has the specified description and makes it the current item.
         * @param description A domain-specific description, to be interpreted by the IListDataAdapter, that identifies the item to retrieve.
         * @returns An IItemPromise that contains the requested IItem object. If the item wasn't found, the promise completes with a value of null.
         **/
        fromDescription(description: string): IItemPromise<IItem<T>>;

        /**
         * Retrieves the item from the IListDataSource that has the specified index and makes it the current item.
         * @param index A value greater than or equal to 0 that is the index of the item to retrieve.
         * @returns An IItemPromise that contains the requested IItem. If the item wasn't found, the promise completes with a value of null.
         **/
        fromIndex(index: number): IItemPromise<IItem<T>>;

        /**
         * Retrieves the item from the IListDataSource that has the specified key and makes it the current item.
         * @param key The key that identifies the item to retrieve. This value must be a non-empty string.
         * @param hints Domain-specific information that provides additional information to the IListDataAdapter to improve retrieval time.
         * @returns An IItemPromise that contains the requested IItem. If they item couldn't be found, the promise completes with a value of null.
         **/
        fromKey(key: string, hints?: any): IItemPromise<IItem<T>>;

        /**
         * Makes the specified IItem or IItemPromise the current item.
         * @param item The IItem or IItemPromise that will become the current item.
         * @returns An IItemPromise that contains the specified item, if it exists. If the specified item is not in the list, the promise completes with a value of null.
         **/
        jumpToItem(item: IItem<T>): IItemPromise<IItem<T>>;

        /**
         * Retrieves the last item in the IListDataSource and makes it the current item.
         * @returns An IItemPromise that contains the requested IItem. f the list is empty, the promise completes with a value of null.
         **/
        last(): IItemPromise<IItem<T>>;

        /**
         * Retrieves the item after the current item and makes it the current item.
         * @returns An IItemPromise that contains the item after the current item. If the cursor moves past the end of the list, the promise completes with a value of null.
         **/
        next(): IItemPromise<IItem<T>>;

        /**
         * Retrieves the item before the current item and makes it the current item.
         * @returns An IItemPromise that contains the item before the current item. If the cursor moves past the start of the list, the promise completes with a value of null.
         **/
        previous(): IItemPromise<IItem<T>>;

        /**
         * Releases resources, stops notifications, and cancels outstanding promises for all tracked items returned by this IListBinding.
         **/
        release(): void;

        /**
         * Creates a request to stop change notifications for the specified item. The change notifications stop when the number of releaseItem calls matches the number of IIItemPromise.retain calls.
         * @param item The IItem or IItemPromise that should stop receiving notifications.
         **/
        releaseItem(item: IItem<T>): void;

        //#endregion Methods
    }

    /**
     * Accesses data for an IListDataSource.
     **/
    interface IListDataAdapter<T> {
        //#region Methods

        /**
         * Overwrites the data of the specified item.
         * @param key The key of the item to overwrite.
         * @param newData The new data for the item.
         * @param indexHint The index of the item, if known.
         * @returns A Promise that returns null or undefined when the operation completes.
         **/
        change(key: string, newData: T, indexHint: number): Promise<void>;

        /**
         * Gets the number of items in the IListDataAdapter object's data source.
         * @returns A Promise that contains the number of items the IListDataAdapter contains, or an approximate value if the actual number is unknown.
         **/
        getCount(): Promise<number>;

        /**
         * Inserts the specified data after the specified item.
         * @param key A key that can be used to retrieve the new data.
         * @param data The new data to add to the IListDataAdapter object's data source.
         * @param previousKey The key of an item in the IListDataAdapter object's data source. The new data will be inserted after this item.
         * @param previousIndexHint The index of the item to insert the new data after, if known.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        insertAfter(key: string, data: T, previousKey: string, previousIndexHint: number): Promise<IItem<T>>;

        /**
         * Adds the specified key and data to the end of the IListDataAdapter object's data source.
         * @param key A key that can be used to retrieve the new data.
         * @param data The new data to add to the IListDataAdapter object's data source.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        insertAtEnd(key: string, data: T): Promise<IItem<T>>;

        /**
         * Adds the specified key and data to the beginning of the IListDataAdapter object's data source.
         * @param key A key that can be used to retrieve the new data.
         * @param data The new data to add to the IListDataAdapter object's data source.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        insertAtStart(key: string, data: T): Promise<IItem<T>>;

        /**
         * Inserts the specified data before the specified item.
         * @param key A key that can be used to retrieve the new data.
         * @param data The new data to add to the IListDataAdapter object's data source.
         * @param nextKey The key of an item in the IListDataAdapter object's data source. The new data will be inserted before this item.
         * @param nextIndexHint The index of the item to insert the new data before, if known.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        insertBefore(key: string, data: T, nextKey: string, nextIndexHint: number): Promise<IItem<T>>;

        /**
         * Retrieves the item that matches the specified description and also retrieves the specified number of items before and after the matched item.
         * @param description A description of the item to locate.
         * @param countBefore The number of items before the matched item to retrieve.
         * @param countAfter The number of items after the matched item to retrieve.
         * @returns A Promise that provides an IFetchResult that contains the selected items or a FetchError if an error was encountered.
         **/
        itemsFromDescription(description: string, countBefore: number, countAfter: number): Promise<IFetchResult<T>>;

        /**
         * Retrieves the specified number of items from the end of the IListDataAdapter object's data source.
         * @param count The number of items to retrieve.
         * @returns A Promise that provides an IFetchResult that contains the selected items or a FetchError if an error was encountered.
         **/
        itemsFromEnd(count: number): Promise<IFetchResult<T>>;

        /**
         * Retrieves the item at the specified index and also retrieves the specified number of items before and after the selected item.
         * @param index The index of the item to retrieve.
         * @param countBefore The number of items to retrieve from before the selected item.
         * @param countAfter The number of items to retrieve from after the selected item.
         * @returns A Promise that provides an IFetchResult that contains the selected items or a FetchError if an error was encountered.
         **/
        itemsFromIndex(index: number, countBefore: number, countAfter: number): Promise<IFetchResult<T>>;

        /**
         * Retrieves the item that has the specified key and also retrieves the specified number of items before and after the selected item.
         * @param key The key of the item to retrieve.
         * @param countBefore The number of items to retrieve from before the selected item.
         * @param countAfter The number of items to retrieve from after the selected item.
         * @returns A Promise that provides an IFetchResult that contains the selected items or a FetchError if an error was encountered.
         **/
        itemsFromKey(key: string, countBefore: number, countAfter: number): Promise<IFetchResult<T>>;

        /**
         * Retrieves the specified number of items from the beginning of the IListDataAdapter object's data source.
         * @param count The number of items to retrieve.
         * @returns A Promise that provides an IFetchResult that contains the selected items or a FetchError if an error was encountered.
         **/
        itemsFromStart(count: number): Promise<IFetchResult<T>>;

        /**
         * Returns a string representation of the specified item that can be used for comparisons.
         * @param item The item for which to generate a signature.
         * @returns The signature representation of the specified item.
         **/
        itemSignature(item: IItem<T>): string;

        /**
         * Moves the specified item to just after another item.
         * @param key A key of the item to move.
         * @param previousKey The key of another item. The item to move will be moved to just after this item.
         * @param indexHint The index of the item to move, if known.
         * @param previousIndexHint The index to move the item after, if known.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        moveAfter(key: string, previousKey: any, indexHint: string, previousIndexHint: number): Promise<IItem<T>>;

        /**
         * Moves the specified item to just before another item.
         * @param key A key of the item to move.
         * @param nextKey The key of another item. The item to move will be moved to just before this item.
         * @param indexHint The index of the item to move, if known.
         * @param nextIndexHint The index to move the item before, if known.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        moveBefore(key: string, nextKey: any, indexHint: string, nextIndexHint: number): Promise<IItem<T>>;

        /**
         * Moves the specified item to the end of the IListDataAdapter object's data source.
         * @param key The key for the item to move.
         * @param indexHint The index of the item to move, if known.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        moveToEnd(key: string, indexHint: number): Promise<IItem<T>>;

        /**
         * Moves the specified item to the beginning of the IListDataAdapter object's data source.
         * @param key The key for the item to move.
         * @param indexHint The index of the item to move, if known.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        moveToStart(key: string, indexHint: number): Promise<IItem<T>>;

        /**
         * Removes the specified item from the IListDataAdapter object's data source.
         * @param key The key of the item to remove.
         * @param data The new data for the item.
         * @param indexHint The index of the item.
         * @returns A Promise that returns null or undefined when the operation completes.
         **/
        remove(key: string, data: T, indexHint: number): Promise<void>;

        /**
         * Registers a notification handler. The IListDataAdapter uses the handler to notify listening objects when its data changes.
         * @param notificationHandler The notification handler that the IListDataAdapter will use to provide change notifications. .
         **/
        setNotificationHandler(notificationHandler: IListDataNotificationHandler<T>): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets a value that specifies whether to use an object's identity to determine if an item has changed.
         **/
        compareByIdentity: boolean;

        //#endregion Properties
    }

    /**
     * Notifies clients when an IListDataAdapter object's data changes.
     **/
    interface IListDataNotificationHandler<T> {
        //#region Methods

        /**
         * Indicates the start of a notification batch. Objects that are listening for notifications should defer making updates until endNotifications is called.
         **/
        beginNotifications(): void;

        /**
         * Raises a notification that an item in the IListDataAdapter object's data source has changed.
         * @param item The item that changed.
         **/
        changed(item: IItem<T>): void;

        /**
         * Indicates the end of a notification batch. When the beginNotifications method is called, objects listening for notifications should defer making updates until endNotifications is called.
         **/
        endNotifications(): void;

        /**
         * Raises a notification that an item has been added to the IListDataAdapter object's data source.
         * @param newItem The new item added to the IListDataAdapter object's data source.
         * @param previousKey The key of the item that now precedes the new item, or null if the item was inserted at the start of the list. If nextKey is provided, this parameter may be null.
         * @param nextKey The key of the item that now follows the new item, or null if the item was inserted at the end of the list. If previousKey is provided, this parameter may be null.
         * @param index The index of the new item.
         **/
        inserted(newItem: IItem<T>, previousKey: string, nextKey: string, index?: number): void;

        /**
         * Indicates that all previous data obtained from the IListDataAdapter is invalid and should be refreshed.
         * @returns A Promise that completes when the data has been completely refreshed and all change notifications have been sent.
         **/
        invalidateAll(): Promise<any>;

        /**
         * Raises a notification that an item was moved within the IListDataAdapter object's data source.
         * @param item The item that was moved.
         * @param previousKey The key of the item that now precedes the new item, or null if the item was moved to the beginning of the list. If nextKey is provided, this parameter may be null.
         * @param nextKey The key of the item that now follows the new item, or null if the item was moved to the end of the list. If previousKey is provided, this parameter may be null.
         * @param oldIndex The item's original index.
         * @param newIndex The item's new index.
         **/
        moved(item: IItem<T>, previousKey: string, nextKey: string, oldIndex?: number, newIndex?: number): void;

        /**
         * Reloads data from the IListDataAdapter.
         **/
        reload(): void;

        /**
         * Raises a notification that an item was removed from the IListDataAdapter object's data source.
         * @param key The key of the item that was removed.
         * @param index The index of the item that was removed.
         **/
        removed(key: string, index?: number): void;

        //#endregion Methods
    }

    /**
     * Provides access to a data source and enables you to bind, change, add, remove, and move items in that data source.
     **/
    interface IListDataSource<T> {
        //#region Events

        /**
         * Occurs when the status of the IListDataSource changes.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: status.
         **/
        statuschanged(eventInfo: CustomEvent): void;

        //#endregion Events

        //#region Methods

        /**
         * Notifies the IListDataSource that a sequence of edits is about to begin. The IListDataSource will defer notifications until endEdits is called.
         **/
        beginEdits(): void;

        /**
         * Overwrites the data of the specified item.
         * @param key The key for the item to replace.
         * @param newData The new data for the item.
         * @returns A Promise that contains the IItem that was updated or an EditError if an error was encountered.
         **/
        change(key: string, newData: T): Promise<IItem<T>>;

        /**
         * Creates an IListBinding that can retrieve items from the IListDataSource, enumerate the contents of the IListDataSource object's data, and optionally register for change notifications.
         * @param notificationHandler Enables the IListBinding to register for change notifications for individual items obtained from the IListDataSource. If you omit this parameter, change notifications won't be available.
         * @returns The new IListBinding.
         **/
        createListBinding(notificationHandler?: IListNotificationHandler<T>): IListBinding<T>;

        /**
         * Notifies the IListDataSource that the batch of edits that began with the last beginEdits call has completed. The IListDataSource will submit notifications for any changes that occurred between the beginEdits and endEdits calls as a batch and resume normal change notifications.
         **/
        endEdits(): void;

        /**
         * Retrieves the number of items in the data source.
         * @returns A Promise that provides a Number that is the number of items in the data source.
         **/
        getCount(): Promise<number>;

        /**
         * Inserts a new item after another item.
         * @param key The key that can be used to retrieve the new item, if known.
         * @param data The data for the item to add.
         * @param previousKey The key for an item in the data source. The new item will be added after this item.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        insertAfter(key: string, data: T, previousKey: string): Promise<IItem<T>>;

        /**
         * Adds an item to the end of the data source.
         * @param key The key that can be used to retrieve the new item, if known.
         * @param data The data for the item to add.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        insertAtEnd(key: string, data: T): Promise<IItem<T>>;

        /**
         * Adds an item to the beginning of the data source.
         * @param key The key that can be used to retrieve the new item, if known.
         * @param data The data for the item to add.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        insertAtStart(key: string, data: T): Promise<IItem<T>>;

        /**
         * Inserts an item before another item.
         * @param key The key that can be used to retrieve the new item, if known.
         * @param data The data for the item to add.
         * @param nextKey The key of an item in the data source. The new item will be inserted before this item.
         * @returns A Promise that contains the IItem that was added or an EditError if an error was encountered.
         **/
        insertBefore(key: string, data: T, nextKey: string): Promise<IItem<T>>;

        /**
         * Indicates that all previous data obtained from the IListDataAdapter is invalid and should be refreshed.
         * @returns A Promise that completes when the data has been completely refreshed and all notifications have been sent.
         **/
        invalidateAll(): Promise<any>;

        /**
         * Retrieves the item that has the specified description.
         * @param description Domain-specific information, to be interpreted by the IListDataAdapter, that describes the item to retrieve.
         * @returns A Promise that provides an IItem that contains the requested item or a FetchError if an error was encountered. If the item wasn't found, the promise completes with a value of null.
         **/
        itemFromDescription(description: any): Promise<IItem<T>>;

        /**
         * Retrieves the item at the specified index.
         * @param index A value that is greater than or equal to zero that is the index of the item to retrieve.
         * @returns A Promise that provides an IItem that contains the requested item or a FetchError if an error was encountered. If the item wasn't found, the promise completes with a value of null.
         **/
        itemFromIndex(index: number): Promise<IItem<T>>;

        /**
         * Retrieves the item with the specified key.
         * @param key The key of the item to retrieve. It must be a non-empty string.
         * @param description Domain-specific information that IListDataAdapter can use to improve the retrieval time.
         * @returns A Promise that provides an IItem that contains the requested item or a FetchError if an error was encountered. If the item was not found, the promise completes with a null value.
         **/
        itemFromKey(key: string, description?: any): Promise<IItem<T>>;

        /**
         * Moves an item to just after another item.
         * @param key The key that identifies the item to move.
         * @param previousKey The key of another item in the data source. The item specified by the key parameter will be moved after this item.
         * @returns A Promise that contains the IItem that was moved or an EditError if an error was encountered.
         **/
        moveAfter(key: string, previousKey: string): Promise<IItem<T>>;

        /**
         * Moves an item before another item.
         * @param key The key that identifies the item to move.
         * @param nextKey The key of another item in the data source. The item specified by the key parameter will be moved before this item.
         * @returns A Promise that contains the IItem that was moved or an EditError if an error was encountered.
         **/
        moveBefore(key: string, nextKey: string): Promise<IItem<T>>;

        /**
         * Moves an item to the end of the data source.
         * @param key The key that identifies the item to move.
         * @returns A Promise that contains the IItem that was moved or an EditError if an error was encountered.
         **/
        moveToEnd(key: string): Promise<IItem<T>>;

        /**
         * Moves the specified item to the beginning of the data source.
         * @param key The key that identifies the item to move.
         * @returns A Promise that contains the IItem that was moved or an EditError if an error was encountered.
         **/
        moveToStart(key: string): Promise<IItem<T>>;

        /**
         * Removes the specified item from the data source.
         * @param key The key that identifies the item to remove.
         * @returns A Promise that contains nothing if the operation was successful or an EditError if an error was encountered.
         **/
        remove(key: string): Promise<IItem<T>>;

        //#endregion Methods
    }

    /**
     * Used by an IListBinding to provide change notifications when items in a IListDataSource change.
     **/
    interface IListNotificationHandler<T> {
        //#region Methods

        /**
         * Indicates the start of a notification batch. Objects that are listening for notifications should defer making updates until endNotifications is called.
         **/
        beginNotifications(): void;

        /**
         * Indicates that an item changed.
         * @param newItem The updated item.
         * @param oldItem The original item.
         **/
        changed(newItem: IItem<T>, oldItem: IItem<T>): void;

        /**
         * Indicates that the number of items in the IListDataSource has changed.
         * @param newCount The updated count.
         * @param oldCount The original count.
         **/
        countChanged(newCount: number, oldCount: number): void;

        /**
         * Indicates the end of a notification batch. When the beginNotifications method is called, objects listening for notifications should defer making updates until endNotifications is called.
         **/
        endNotifications(): void;

        /**
         * Indicates that the index of an item changed.
         * @param handle The temporary ID of the item.
         * @param newIndex The new index.
         * @param oldIndex The original index.
         **/
        indexChanged(handle: string, newIndex: number, oldIndex: number): void;

        /**
         * Indicates that an item was added to the IListDataSource.
         * @param itemPromise A promise for the new IItem.
         * @param previousHandle The temporary ID of the item that precedes the new item.
         * @param nextHandle The temporary ID of the item that follows the new item.
         **/
        inserted(itemPromise: IItemPromise<T>, previousHandle: string, nextHandle: string): void;

        /**
         * Indicates that an IItemPromise was fulfilled and that the item is now available.
         * @param item The fulfilled item.
         **/
        itemAvailable(item: IItem<T>): void;

        /**
         * Indicates that an item was moved.
         * @param item A promise for the IItem that was moved.
         * @param previousHandle The temporary ID of the item that now precedes the moved item.
         * @param nextHandle The temporary ID of the item that now follows the moved item.
         **/
        moved(item: IItemPromise<T>, previousHandle: string, nextHandle: string): void;

        /**
         * Indicates that an item was removed.
         * @param handle The temporary ID of the item that was removed.
         * @param mirage true if the item never actually existed; false if the item was actually present in the IListDataSource.
         **/
        removed(handle: string, mirage: boolean): void;

        //#endregion Methods
    }

    /**
     * Used by ListView's currentItem API
     **/
    interface IListViewItem {
        /**
         * Gets or sets index of the ListView item.
         **/
        index?: number;

        /**
         * Gets or sets key of the ListView item.
         **/
        key?: string;

        /**
         * Gets or sets whether the ListView item is focused.
         **/
        hasFocus?: boolean;

        /**
         * Gets or sets whether the ListView item is focused and is showing its focus visual.
         **/
        showFocus?: boolean;
    }

    /**
     * Represents a selection of ListView items.
     **/
    interface ISelection<T> {
        //#region Methods

        /**
         * Adds one or more items to the selection.
         * @param items The indexes or keys of the items to add. You can provide different types of objects for the items parameter: you can specify an index, a key, or a range of indexes. It can also be an array that contains one or more of these objects. For more info, see the Remarks section.
         * @returns A Promise that is fulfilled when the operation completes.
         **/
        add(items: any): Promise<any>;

        /**
         * Clears the selection.
         * @returns A Promise that is fulfilled when the clear operation completes.
         **/
        clear(): Promise<any>;

        /**
         * Returns the number of items in the selection.
         * @returns The number of items in the selection.
         **/
        count(): number;

        /**
         * Returns a list of the indexes for the items in the selection.
         * @returns The list of indexes for the items in the selection as an array of Number objects.
         **/
        getIndices(): number[];

        /**
         * Returns an array that contains the items in the selection.
         * @returns A Promise that contains an array of the requested IItem objects.
         **/
        getItems(): Promise<IItem<T>[]>;

        /**
         * Gets an array of the index ranges for the selected items.
         * @returns An array that contains an ISelectionRange object for each index range in the selection.
         **/
        getRanges(): ISelectionRange[];

        /**
         * Returns a value that indicates whether the selection contains every item in the data source.
         * @returns true if the selection contains every item in the data source; otherwise, false.
         **/
        isEverything(): boolean;

        /**
         * Removes the specified items from the selection.
         * @param items The indexes or keys of the items to remove. You can provide different types of objects for the items parameter: you can specify an index, a key, or a range of indexes. It can also be an array that contains one or more of these objects. For more info, see the Remarks section.
         * @returns A Promise that is fulfilled when the operation completes.
         **/
        remove(items: any): Promise<any>;

        /**
         * Adds all the items in the ListView to the selection.
         **/
        selectAll(): void;

        /**
         * Clears the current selection and replaces it with the specified items.
         * @param items The indexes or keys of the items that make up the selection. You can provide different types of objects for the items parameter: you can specify an index, a key, or a range of indexes. It can also be an array that contains one or more of these objects. For more info, see the Remarks section.
         * @returns A Promise that is fulfilled when the operation completes.
         **/
        set(items: any): Promise<any>;

        //#endregion Methods
    }

    /**
     * Represents a range of indexes or keys in an ISelection.
     **/
    interface ISelectionRange {
        //#region Properties

        /**
         * Gets or sets the index of the first item in the range.
         **/
        firstIndex: number;

        /**
         * Gets or sets the key of the first item in the range.
         **/
        firstKey: any;

        /**
         * Gets or sets the index of the last item in the range.
         **/
        lastIndex: number;

        /**
         * Gets or sets of the key of the last item in the range.
         **/
        lastKey: any;

        //#endregion Properties
    }

    /**
     * Supports semantic zoom functionality by exposing a control as either the zoomed in or the zoomed out view of the SemanticZoom control.
     **/
    interface IZoomableView<T> {
        //#region Methods

        /**
         * Initiates semantic zoom on the custom control.
         **/
        beginZoom(): void;

        /**
         * Initializes the semantic zoom state for the custom control.
         * @param isZoomedOut True if this is the zoomed out view; otherwise false.
         * @param isCurrentView True if this is the current view; otherwise false.
         * @param triggerZoom The function that manages semantic zoom behavior. Triggers a zoom in or zoom out if the control is the visible control.
         * @param prefetchedPages The number of pages of content to pre-fetch for zooming. This value is dependent on the size of the semantic zoom container. More content can be displayed based on the zoom factor and the size of the container.
         **/
        configureForZoom(isZoomedOut: boolean, isCurrentView: boolean, triggerZoom: Function, prefetchedPages: number): void;

        /**
         * Terminates semantic zoom on the zoomed in or zoomed out child of the custom control.
         * @param isCurrentView True if the control is the visible control; otherwise false.
         **/
        endZoom(isCurrentView: boolean): void;

        /**
         * Retrieves the current item of the zoomed in or zoomed out child of the custom control.
         * @returns An object that represents the selected item. This return value must be a Promise for the following: item, position.
         **/
        getCurrentItem(): Promise<{ item: T; position: Utilities.IPosition }>;

        /**
         * Retrieves the panning axis of the zoomed-in or zoomed-out child of the custom control.
         * @returns Identifies the panning axis of the child control. Implementation specific.
         **/
        getPanAxis(): string;

        /**
         * Manages pointer input for the custom control.
         * @param pointerId The ID of the pointer.
         **/
        handlePointer(pointerId: string): void;

        /**
         * Positions the specified item within the viewport of the child control when panning or zooming begins.
         * @param item The object to position within the viewport of the child control. item can be a number, a string, or an object with any number of properties.
         * @param position An object that contains the position data of the item relative to the child control. position must be an object with four number properties: left, top, width, and height. These values specify a rectangle that is typically the bounding box of the current item, though the details are up to the control. The units of the position must be in pixels. And the coordinates must be relative to the top-left of the control viewport (which should occupy the same area as the semantic zoom viewport), except when in RTL mode. In RTL mode, return coordinates relative to the top-right off the control viewport. The rectangle is transformed from the coordinate system of one control to that of the other.
         **/
        positionItem(item: T, position: Utilities.IPosition): void;

        /**
         * Selects the item closest to the specified screen coordinates.
         * @param x The x-coordinate in DIPs relative to the upper-left corner of the SemanticZoom viewport.
         * @param y The y-coordinate in DIPs relative to the upper-left corner of the SemanticZoom viewport..
         **/
        setCurrentItem(x: number, y: number): void;

        //#endregion Methods
    }

    //#endregion Interfaces

    //#region Objects

    /**
     * Represents a command to be displayed in an app bar.
     **/
    class AppBarCommand {
        //#region Constructors

        /**
         * Creates a new AppBarCommand object.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AppBarCommand.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param type The event type to register.
         * @param listener The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
         **/
        addEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Releases resources held by this AppBarCommand. Call this method when the AppBarCommand is no longer needed. After calling this method, the AppBarCommand becomes unusable.
         **/
        dispose(): void;

        /**
         * Removes an event handler that the addEventListener method registered.
         * @param type The event type to unregister. It must be beforeshow, beforehide, aftershow, or afterhide.
         * @param listener The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
         **/
        removeEventListener(type: string, listener: Function, useCapture?: boolean): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets a value that indicates whether the AppBarCommand is disabled.
         **/
        disabled: boolean;

        /**
         * Gets the DOM element that hosts the AppBarCommand.
         **/
        element: HTMLElement;

        /**
         * Adds an extra CSS class during construction.
         **/
        extraClass: string;

        /**
         * Gets or sets the HTMLElement with a 'content' type AppBarCommand that should receive focus whenever focus moves by the user pressing HOME or the arrow keys, from the previous AppBarCommand to this AppBarCommand.
         **/
        firstElementFocus: HTMLElement;

        /**
         * Gets or sets the Flyout object displayed by this command. The specified flyout is shown when the AppBarCommand's button is invoked.
         **/
        flyout: Flyout;

        /**
         * Gets or sets a value that indicates whether the AppBarCommand is hiding or in the process of becoming hidden.
         **/
        hidden: boolean;

        /**
         * Gets or sets the icon of the AppBarCommand.
         **/
        icon: string;

        /**
         * Gets the element identifier (ID) of the command.
         **/
        id: string;

        /**
         * Gets or sets the label of the command.
         **/
        label: string;

        /**
         * Gets or sets the HTMLElement with a 'content' type AppBarCommand that should receive focus whenever focus moves by the user pressing END or the arrow keys, from the previous AppBarCommand to this AppBarCommand.
         **/
        lastElementFocus: HTMLElement;

        /**
         * Gets or sets the function to be invoked when the command is clicked.
         **/
        onclick: Function;

        /**
         * Gets the section of the app bar that the command is in.
         **/
        section: string;

        /**
         * Gets or sets the selected state of a toggle button.
         **/
        selected: boolean;

        /**
         * Gets or sets the tooltip of the command.
         **/
        tooltip: string;

        /**
         * Gets the type of the command.
         **/
        type: string;

        //#endregion Properties
    }

    /**
     * Represents a layout for the ListView in which items are arranged in a grid and items can span multiple grid cells.
     **/
    class CellSpanningLayout {
        //#region Constructors

        /**
         * Creates a new CellSpanningLayout.
         * @constructor
         * @param options An object that contains one or more property/value pairs to apply to the new CellSpanningLayout. Each property of the options object corresponds to one of the object's properties or events. Event names must begin with "on".
         **/
        constructor(options?: any);

        //#endregion Constructors

        //#region Methods

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        dragLeave(): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        dragOver(): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        executeAnimations(): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param currentItem An object that describes the current item. It has these properties: index, type.
         * @param pressedKey The key that was pressed.
         * @returns An object that describes the next item that should receive focus. It has these properties: index, type.
         **/
        getAdjacent(currentItem: any, pressedKey: WinJS.Utilities.Key): any;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param x The x-coordinate, or the horizontal position on the screen.
         * @param y The y-coordinate, or the vertical position on the screen.
         **/
        hitTest(x: number, y: number): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param site The rendering site for the layout.
         * @param groupsEnabled Set to true if this layout supports groups; set to false if it does not.
         **/
        initialize(site: ILayoutSite2, groupsEnabled: boolean): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param firstPixel The first pixel the range of items falls between.
         * @param lastPixel The last pixel the range of items falls between.
         **/
        itemsFromRange(firstPixel: number, lastPixel: number): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param tree
         * @param changedRange
         * @param modifiedItems
         * @param modifiedGroups
         **/
        layout(tree: ILayoutSite2, changedRange: any, modifiedItems: any, modifiedGroups: any): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        setupAnimations(): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        uninitialize(): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets the position of group headers relative to their items.
         **/
        groupHeaderPosition: WinJS.UI.HeaderPosition;

        /**
         * Gets or sets a function that enables cell-spanning and establishes base cell dimensions.
         **/
        groupInfo: Function;

        /**
         * Gets or sets a function that returns the width and height of an item, as well as whether it should appear in a new column. Setting this function improves performance because the ListView can allocate space for an item without having to measure it first.
         **/
        itemInfo: Function;

        /**
         * Gets or set the maximum number of rows or columns, depending on the orientation, to display before content begins to wrap.
         **/
        maximumRowsOrColumns: number;

        /**
         * This API supports the Windows Library for JavaScript infrastructure and is not intended to be used directly from your code.
         **/
        numberOfItemsPerItemsBlock: any;

        /**
         * Gets the orientation of the CellSpanningLayout. For a CellSpanningLayout, this property always returns Orientation.horizontal.
         **/
        orientation: WinJS.UI.Orientation;

        //#endregion Properties
    }

    /**
     * Adds event-related methods to the control.
     **/
    class DOMEventMixin {
        //#region Methods

        /**
         * Adds an event listener to the control.
         * @param type The type (name) of the event.
         * @param listener The listener to invoke when the event gets raised.
         * @param useCapture true to initiate capture; otherwise, false.
         **/
        addEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Raises an event of the specified type, adding the specified additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event, otherwise false.
         **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Removes an event listener from the control.
         * @param type The type (name) of the event.
         * @param listener The listener to remove.
         * @param useCapture true to initiate capture; otherwise, false.
         **/
        removeEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Adds the set of declaratively specified options (properties and events) to the specified control. If the name of the options property begins with "on", the property value is a function and the control supports addEventListener. This method calls the addEventListener method on the control.
         * @param control The control on which the properties and events are to be applied.
         * @param options The set of options that are specified declaratively.
         **/
        setOptions(control: any, options: any): void;

        //#endregion Methods
    }

    /**
     * Displays lightweight UI that is either information, or requires user interaction. Unlike a dialog, a Flyout can be light dismissed by clicking or tapping off of it.
     **/
    class Flyout {
        //#region Constructors

        /**
         * Creates a new Flyout object.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Flyout.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Events

        /**
         * Raised immediately after a flyout is fully hidden.
         * @param eventInfo An object that contains information about the event.
         **/
        onafterhide(eventInfo: Event): void;

        /**
         * Raised immediately after a flyout is fully shown.
         * @param eventInfo An object that contains information about the event.
         **/
        onaftershow(eventInfo: Event): void;

        /**
         * Raised just before hiding a flyout.
         * @param eventInfo An object that contains information about the event.
         **/
        onbeforehide(eventInfo: Event): void;

        /**
         * Raised just before showing a flyout.
         * @param eventInfo An object that contains information about the event.
         **/
        onbeforeshow(eventInfo: Event): void;

        //#endregion Events

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param type The event type to register. It must be beforeshow, beforehide, aftershow, or afterhide.
         * @param listener The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
         **/
        addEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Releases resources held by this object. Call this method when the object is no longer needed. After calling this method, the object becomes unusable.
         **/
        dispose(): void;

        /**
         * Hides the Flyout, if visible, regardless of other states.
         **/
        hide(): void;

        /**
         * Removes an event handler that the addEventListener method registered.
         * @param type The event type to unregister. It must be beforeshow, beforehide, aftershow, or afterhide.
         * @param listener The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
         **/
        removeEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Shows the Flyout, if hidden, regardless of other states.
         * @param anchor Required. The DOM element to anchor the Flyout.
         * @param placement The placement of the Flyout to the anchor: the string literal "top", "bottom", "left", or "right".
         * @param alignment For "top" or "bottom" placement, the alignment of the Flyout to the anchor's edge: the string literal "center", "left", or "right".
         **/
        show(anchor: HTMLElement, placement: string, alignment: string): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets the default alignment to be used for this Flyout.
         **/
        alignment: string;

        /**
         * Gets or sets the default anchor to be used for this Flyout.
         **/
        anchor: HTMLElement;

        /**
         * Gets the DOM element that hosts the Flyout.
         **/
        element: HTMLElement;

        /**
         * Gets a value that indicates whether the Flyout is hidden or in the process of becoming hidden.
         **/
        hidden: boolean;

        /**
         * Gets or sets the default placement to be used for this Flyout.
         **/
        placement: string;

        //#endregion Properties
    }

    /**
     * Represents a grid layout for the ListView in which items are arranged in a horizontal grid.
     **/
    class GridLayout {
        //#region Constructors

        /**
         * Creates a new GridLayout object.
         * @constructor
         * @param options The set of properties and values to apply to the new GridLayout.
         **/
        constructor(options?: any);

        //#endregion Constructors

        //#region Methods

        /**
         * This method is no longer supported.
         * @param beginScrollPosition
         * @param wholeItem
         **/
        calculateFirstVisible(beginScrollPosition: number, wholeItem: boolean): void;

        /**
         * This method is no longer supported.
         * @param endScrollPosition
         * @param wholeItem
         **/
        calculateLastVisible(endScrollPosition: number, wholeItem: boolean): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        dragLeave(): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        dragOver(): void;

        /**
         * This method is no longer supported.
         **/
        endLayout(): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        executeAnimations(): void;

        /**
         * This method is no longer supported.
         * @param itemIndex
         **/
        getItemPosition(itemIndex: number): void;

        /**
         * This method is no longer supported.
         * @param itemIndex
         * @param element
         * @param keyPressed
         **/
        getKeyboardNavigatedItem(itemIndex: number, element: any, keyPressed: any): void;

        /**
         * This method is no longer supported.
         * @param beginScrollPosition
         * @param endScrollPosition
         **/
        getScrollbarRange(beginScrollPosition: number, endScrollPosition: number): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param x The x-coordinate, or the horizontal position on the screen.
         * @param y The y-coordinate, or the vertical position on the screen.
         **/
        hitTest(x: number, y: number): void;

        /**
         * This method is no longer supported.
         **/
        init(): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param site The rendering site for the layout.
         * @param groupsEnabled Set to true if this layout supports groups; set to false if it does not.
         **/
        initialize(site: ILayoutSite2, groupsEnabled: boolean): void;

        /**
         * This method is no longer supported.
         * @param elements
         **/
        itemsAdded(elements: any): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param firstPixel The first pixel the range of items falls between.
         * @param lastPixel The last pixel the range of items falls between.
         **/
        itemsFromRange(firstPixel: number, lastPixel: number): void;

        /**
         * This method is no longer supported.
         **/
        itemsMoved(): void;

        /**
         * This method is no longer supported.
         * @param elements
         **/
        itemsRemoved(elements: any): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param tree
         * @param changedRange
         * @param modifiedItems
         * @param modifiedGroups
         **/
        layout(tree: any, changedRange: any, modifiedItems: any, modifiedGroups: any): void;

        /**
         * This method is no longer supported.
         * @param groupIndex
         * @param element A DOM element.
         **/
        layoutHeader(groupIndex: number, element: any): void;

        /**
         * This method is no longer supported.
         * @param itemIndex
         * @param element A DOM element.
         **/
        layoutItem(itemIndex: number, element: any): void;

        /**
         * This method is no longer supported.
         * @param element
         **/
        prepareHeader(element: HTMLElement): void;

        /**
         * This method is no longer supported.
         * @param itemIndex
         * @param element A DOM element.
         **/
        prepareItem(itemIndex: number, element: any): void;

        /**
         * This method is no longer supported.
         * @param item
         * @param newItem
         **/
        releaseItem(item: any, newItem: any): void;

        /**
         * This method is no longer supported.
         **/
        reset(): void;

        /**
         * This method is no longer supported.
         * @param layoutSite
         **/
        setSite(layoutSite: any): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        setupAnimations(): void;

        /**
         * This method is no longer supported.
         * @param beginScrollPosition
         * @param endScrollPositionScrollPosition
         **/
        startLayout(beginScrollPosition: number, endScrollPositionScrollPosition: number): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        uninitialize(): void;

        /**
         * This method is no longer supported.
         * @param count
         **/
        updateBackdrop(count: number): void;

        //#endregion Methods

        //#region Properties

        /**
         * This property is no longer supported. Starting with Windows Library for JavaScript 2.0, use the .win-listview.win-container.win-backdrop CSS selector.
         **/
        backdropColor: string;

        /**
         * This property is no longer supported. Starting with Windows Library for JavaScript 2.0, use the .win-listview.win-container.win-backdrop CSS selector.
         **/
        disableBackdrop: boolean;

        /**
         * Gets or sets the position of group headers.
         **/
        groupHeaderPosition: WinJS.UI.HeaderPosition;

        /**
         * This property is no longer supported. Starting with the Windows Library for JavaScript 2.0, use a CellSpanningLayout.
         **/
        groupInfo: Function;

        /**
         * This property is no longer supported. Starting with the Windows Library for JavaScript 2.0, use the orientation property instead.
         **/
        horizontal: boolean;

        /**
         * This property is no longer supported. Starting with the Windows Library for JavaScript 2.0, use a CellSpanningLayout.
         **/
        itemInfo: Function;

        /**
         * Gets or set the maximum number of rows or columns, depending on the orientation, to display before content begins to wrap.
         **/
        maximumRowsOrColumns: number;

        /**
         * This property is no longer supported. Starting with Windows Library for JavaScript 2.0, use the maximumRowsOrColumns property.
         **/
        maxRows: number;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        numberOfItemsPerItemsBlock: any;

        /**
         * Gets or sets the orientation of the GridLayout.
         **/
        orientation: WinJS.UI.Orientation;

        //#endregion Properties
    }

    /**
     * Defines a section of a Hub.
     **/
    class HubSection {
        //#region Constructors

        /**
         * Creates a new HubSection.
         * @constructor
         * @param element The DOM element hosts the new HubSection.
         * @param options An object that contains one or more property/value pairs to apply to the new control. Each property of the options object corresponds to one of the control's properties or events.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Methods

        /**
         * Releases resources held by this HubSection. Call this method when the HubSection is no longer needed. After calling this method, the HubSection becomes unusable.
         **/
        dispose(): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets the DOM element that hosts the HubSection control's content.
         **/
        contentElement: HTMLElement;

        /**
         * Gets the DOM element that hosts this HubSection.
         **/
        element: HTMLElement;

        /**
         * Gets or sets the header for this HubSection.
         **/
        header: string;

        /**
         * Gets a value that specifies whether the header is static.
         **/
        isHeaderStatic: boolean;

        //#endregion Properties
    }

    /**
     * Enables you to include an HTML page dynamically. As part of the constructor, you must include an option indicating the URI of the page.
     **/
    class HtmlControl {
        //#region Constructors

        /**
         * Initializes a new instance of HtmlControl to define a new page control.
         * @constructor
         * @param element The element that hosts the HtmlControl.
         * @param options The options for configuring the page. The uri option is required in order to specify the source document for the content of the page. Other options are the ones used by the WinJS.Pages.render method.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors
    }

    /**
     * Defines an item that can be pressed, swiped, and dragged.
     **/
    class ItemContainer {
        //#region Constructors

        /**
         * Creates a new ItemContainer.
         * @constructor
         * @param element The DOM element hosts the new ItemContainer. For the ItemContainer to be accessible, this element must have its role attribute set to "list" or "listbox". If tapBehavior is set to none and selectionDisabled is true, then use the "list" role; otherwise, use the "listbox" role.
         * @param options An object that contains one or more property/value pairs to apply to the new control. Each property of the options object corresponds to one of the control's properties or events.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Events

        /**
         * Raised when the item is invoked. (You can use the tapBehavior property to specify whether taps and clicks invoke the item.)
         * @param eventInfo An object that contains information about the event.
         **/
        oninvoked(eventInfo: CustomEvent): void;

        /**
         * Raised after the item is selected or deselected.
         * @param eventInfo An object that contains information about the event.
         **/
        onselectionchanged(eventInfo: CustomEvent): void;

        /**
         * Raised just before the current selection changes.
         * @param eventInfo An object that contains information about the event.
         **/
        onselectionchanging(eventInfo: CustomEvent): void;

        //#endregion Events

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param eventName The name of the event to handle. Note that you drop the "on" when specifying the event name. For example, instead of specifying "onclick", you specify "click".
         * @param eventHandler The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
         **/
        addEventListener(eventName: string, eventHandler: Function, useCapture?: boolean): void;

        /**
         * Raises an event of the specified type and with additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event, otherwise false.
         **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Releases resources held by this ItemContainer. Call this method when the ItemContainer is no longer needed. After calling this method, the ItemContainer becomes unusable.
         **/
        dispose(): void;

        /**
         * Forces the ItemContainer to update its layout. Call this function when the reading direction of the app changes after the control has been initialized.
         **/
        forceLayout(): void;

        /**
         * Removes an event handler that the addEventListener method registered.
         * @param eventName The name of the event that the event handler is registered for.
         * @param eventCallback The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
         **/
        removeEventListener(eventName: string, eventCallback: Function, useCapture?: boolean): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets a value that specifies whether the item can be dragged.
         **/
        draggable: boolean;

        /**
         * Gets the element that hosts this ItemContainer.
         **/
        element: HTMLElement;

        /**
         * Gets or sets a value that specifies whether the item is selected.
         **/
        selected: boolean;

        /**
         * Gets or sets a value that specifies whether selection of this item is disabled.
         **/
        selectionDisabled: boolean;

        /**
         * Gets or sets how the ItemContainer reacts to the swipe gesture. The swipe gesture can select the swiped items or can have no effect on the current selection.
         **/
        swipeBehavior: WinJS.UI.SwipeBehavior;

        /**
         * Gets or sets the orientation of swipe gestures.
         **/
        swipeOrientation: Orientation;

        /**
         * Gets or sets how the ItemContainer reacts when the user taps or clicks an item.
         **/
        tapBehavior: TapBehavior;

        //#endregion Properties
    }

    /**
     * This object supports the WinJS infrastructure and is not intended to be used directly from your code.
     **/
    class Layout { }

    /**
     * Represents a layout for the ListView in which items are arranged in a vertical list.
     **/
    class ListLayout {
        //#region Constructors

        /**
         * Creates a new ListLayout.
         * @constructor
         * @param options An object that contains one or more property/value pairs to apply to the new ListLayout. Each property of the options object corresponds to one of the object's properties or events. Event names must begin with "on".
         **/
        constructor(options?: any);

        //#endregion Constructors

        //#region Methods

        /**
         * This method is no longer supported.
         * @param beginScrollPosition
         * @param wholeItem
         **/
        calculateFirstVisible(beginScrollPosition: number, wholeItem: boolean): void;

        /**
         * This method is no longer supported.
         * @param endScrollPosition
         * @param wholeItem
         **/
        calculateLastVisible(endScrollPosition: number, wholeItem: boolean): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        dragLeave(): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        dragOver(): void;

        /**
         * This method is no longer supported.
         **/
        endLayout(): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        executeAnimations(): void;

        /**
         * This method is no longer supported.
         * @param itemIndex
         **/
        getItemPosition(itemIndex: number): void;

        /**
         * This method is no longer supported.
         * @param itemIndex
         * @param element
         * @param keyPressed
         **/
        getKeyboardNavigatedItem(itemIndex: number, element: HTMLElement, keyPressed: any): void;

        /**
         * This method is no longer supported.
         * @param beginScrollPosition
         * @param endScrollPosition
         **/
        getScrollbarRange(beginScrollPosition: number, endScrollPosition: number): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param x The x-coordinate, or the horizontal position on the screen.
         * @param y The y-coordinate, or the vertical position on the screen.
         **/
        hitTest(x: number, y: number): void;

        /**
         * This method is no longer supported.
         **/
        init(): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        initialize(): void;

        /**
         * This method is no longer supported.
         * @param elements
         **/
        itemsAdded(elements: any): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param firstPixel
         * @param lastPixel
         **/
        itemsFromRange(firstPixel: number, lastPixel: number): void;

        /**
         * This method is no longer supported.
         **/
        itemsMoved(): void;

        /**
         * This method is no longer supported.
         * @param elements
         **/
        itemsRemoved(elements: any): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         * @param tree
         * @param changedRange
         * @param modifiedItems
         * @param modifiedGroups
         **/
        layout(tree: any, changedRange: any, modifiedItems: any, modifiedGroups: any): void;

        /**
         * This method is no longer supported.
         * @param groupIndex
         * @param element A DOM element.
         **/
        layoutHeader(groupIndex: number, element: any): void;

        /**
         * This method is no longer supported.
         * @param itemIndex
         * @param element A DOM element.
         **/
        layoutItem(itemIndex: number, element: any): void;

        /**
         * This method is no longer supported.
         * @param element
         **/
        prepareHeader(element: HTMLElement): void;

        /**
         * This method is no longer supported.
         * @param itemIndex
         * @param element A DOM element.
         **/
        prepareItem(itemIndex: number, element: any): void;

        /**
         * This method is no longer supported.
         * @param item
         * @param newItem
         **/
        releaseItem(item: any, newItem: any): void;

        /**
         * This method is no longer supported.
         **/
        reset(): void;

        /**
         * This method is no longer supported.
         * @param layoutSite
         **/
        setSite(layoutSite: any): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        setupAnimations(): void;

        /**
         * This method is no longer supported.
         * @param beginScrollPosition
         * @param endScrollPositionScrollPosition
         **/
        startLayout(beginScrollPosition: number, endScrollPositionScrollPosition: number): void;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        uninitialize(): void;

        /**
         * This method is no longer supported.
         * @param count
         **/
        updateBackdrop(count: number): void;

        //#endregion Methods

        //#region Properties

        /**
         * This property is no longer supported. Starting with Windows Library for JavaScript 2.0, use the .win-listview.win-container.win-backdrop CSS selector.
         **/
        backdropColor: string;

        /**
         * This property is no longer supported. Starting with Windows Library for JavaScript 2.0, use the .win-listview.win-container.win-backdrop CSS selector.
         **/
        disableBackdrop: boolean;

        /**
         * Gets or sets the position of group headers.
         **/
        groupHeaderPosition: WinJS.UI.HeaderPosition;

        /**
         * This property is no longer supported. Starting with the Windows Library for JavaScript 2.0, use a CellSpanningLayout.
         **/
        groupInfo: Function;

        /**
         * This property is no longer supported. Starting with the Windows Library for JavaScript 2.0, use the orientation property instead.
         **/
        horizontal: boolean;

        /**
         * This property is no longer supported. Starting with the Windows Library for JavaScript 2.0, use a CellSpanningLayout.
         **/
        itemInfo: Function;

        /**
         * This API supports the WinJS infrastructure and is not intended to be used directly from your code.
         **/
        numberOfItemsPerItemsBlock: any;

        /**
         * Gets or sets the orientation of the GridLayout.
         **/
        orientation: WinJS.UI.Orientation;

        //#endregion Properties
    }

    /**
     * Displays data items in a customizable list or grid.
     **/
    class ListView<T> {
        //#region Constructors

        /**
         * Creates a new ListView.
         * @constructor
         * @param element The DOM element that hosts the ListView control.
         * @param options An object that contains one or more property/value pairs to apply to the new control. Each property of the options object corresponds to one of the control's properties or events. Event names must begin with "on". For example, to provide a handler for the selectionchanged event, add a property named "onselectionchanged" to the options object and set its value to the event handler.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Events

        /**
         * Occurs when the ListView is about to play an entrance or contentTransition animation.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.type, detail.setPromise.
         **/
        oncontentanimating(eventInfo: CustomEvent): void;

        /**
         * Raised when the user taps or clicks a group header.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.groupHeaderIndex, detail.groupHeaderPromise.
         **/
        ongroupheaderinvoked(eventInfo: CustomEvent): void;

        /**
         * Raised when the ListView is a drop target and the onitemdragenter has been disabled. This is raised every time the cursor is moved between a new pair of items. If you call preventDefault on this event, then the ListView does not move the items slightly above/below the cursor to provide visual feedback for a drop.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains additional information about the event.
         **/
        onitemdragbetween(eventInfo: CustomEvent): void;

        /**
         * Raised when the user is dragging an item from the ListView and the datasource changes while the user is dragging.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains additional information about the event.
         **/
        onitemdragchanged(eventInfo: CustomEvent): void;

        /**
         * Raised when an item is dropped onto the ListView as the result of a drag operation.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.dataTransfer, detail.index, detail.insertAfterIndex.
         **/
        onitemdragdrop(eventInfo: CustomEvent): void;

        /**
         * Raised when the user drops an item dragged from a ListView.
         * @param eventInfo An object that contains information about the event.
         **/
        onitemdragend(eventInfo: CustomEvent): void;

        /**
         * Raised when an dragged item enters the bounds of the ListView control.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.dataTransfer.
         **/
        onitemdragenter(eventInfo: CustomEvent): void;

        /**
         * Raised when a draggable item leaves the bounds of a ListView control.
         * @param eventInfo An object that contains information about the event.
         **/
        onitemdragleave(eventInfo: CustomEvent): void;

        /**
         * Raised when the user begins to drag an item from a ListView control.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.dataTransfer, detail.dragInfo.
         **/
        onitemdragstart(eventInfo: CustomEvent): void;

        /**
         * Occurs when the user taps or clicks an item.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.itemIndex.
         **/
        oniteminvoked(eventInfo: CustomEvent): void;

        /**
         * Raised when the focused item changes.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.oldFocus, detail.oldNewFocus.
         **/
        onkeyboardnavigating(eventInfo: CustomEvent): void;

        /**
         * Occurs when the ListView control's loadingState changes.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.scrolling.
         **/
        onloadingstatechanged(eventInfo: CustomEvent): void;

        /**
         * Occurs after the current selection changes.
         * @param eventInfo An object that contains information about the event. The detail property of this object is null. To obtain the selected items, use the ListView.selection property.
         **/
        onselectionchanged(eventInfo: CustomEvent): void;

        /**
         * Occurs just before the current selection changes.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.newSelection, detail.preventTapBehavior.
         **/
        onselectionchanging(eventInfo: CustomEvent): void;

        //#endregion Events

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param eventName The name of the event to handle. See the ListView object page for a list of events. Note that you drop the "on" when specifying the event name for the addEventListener method. For example, instead of specifying "onselectionchange", you specify "selectionchange".
         * @param eventHandler The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
         **/
        addEventListener(eventName: string, eventHandler: Function, useCapture?: boolean): void;

        /**
         * Raises an event of the specified type and with additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event, otherwise false.
         **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Releases resources held by this object. Call this method when the object is no longer needed. After calling this method, the object becomes unusable.
         **/
        dispose(): void;

        /**
         * Returns the DOM element that represents the item at the specified index.
         * @param itemIndex The index of the item.
         * @returns The DOM element that represents the item at the specified index.
         **/
        elementFromIndex(itemIndex: number): HTMLElement;

        /**
         * Makes the item at the specified index visible. If necessary, the ListView will scroll to the item.
         * @param itemIndex The index of the item to scroll into view.
         **/
        ensureVisible(itemIndex: number): void;

        /**
         * Forces the ListView to update its layout. Use this function when making the ListView visible again after its style.display property had been set to "none".
         **/
        forceLayout(): void;

        /**
         * Returns the index of the item that the specified DOM element displays.
         * @param element The DOM element that displays the item.
         * @returns The index of the item displayed by element.
         **/
        indexOfElement(element: HTMLElement): number;

        /**
         * Loads the next set of pages if the ListView control's loadingBehavior is set to "incremental" (otherwise, it does nothing). The number of pages to be loaded is determined by the pagesToLoad property.
         **/
        loadMorePages(): void;

        /**
         * Repositions all the visible items in the ListView to adjust for items whose sizes have changed. Most apps won’t ever need to call this method. For more info, see the Remarks section.
         **/
        recalculateItemPosition(): void;

        /**
         * Removes an event handler that the addEventListener method registered.
         * @param eventName The name of the event that the event handler is registered for.
         * @param eventCallback The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
         **/
        removeEventListener(eventName: string, eventCallback: Function, useCapture?: boolean): void;

        /**
         * Triggers the ListView disposal service manually.
         **/
        static triggerDispose(): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets a value that indicates whether the next set of pages is automatically loaded when the user scrolls beyond the number of pages specified by the pagesToLoadThreshold property.
         **/
        automaticallyLoadPages: boolean;

        /**
         * Gets or sets an IListViewItem that indicates which item should have keyboard focus and the focus state of that item.
         **/
        currentItem: IListViewItem;

        /**
         * Gets the HTML element that hosts this ListView.
         **/
        element: HTMLElement;

        /**
         * Gets or sets the data source that contains the groups for the items in the itemDataSource.
         **/
        groupDataSource: IListDataSource<T>;

        /**
         * Gets or sets how the ListView reacts when the user taps or clicks a group header.
         **/
        groupHeaderTapBehavior: GroupHeaderTapBehavior;

        /**
         * Gets or sets the Template or function that creates the DOM elements for each group header in the groupDataSource. Each group header can contain multiple elements, but it must have a single root element.
         **/
        groupHeaderTemplate: any;

        /**
         * Gets or sets the first visible item.
         **/
        indexOfFirstVisible: number;

        /**
         * Gets the index of the last visible item in the ListView.
         **/
        indexOfLastVisible: number;

        /**
         * Gets or sets the data source that provides the ListView with items.
         **/
        itemDataSource: IListDataSource<T>;

        /**
         * Go Gets or sets a value that specifies whether items can be dragged. When this is set to true the ListView provides built in behaviors related to item dragging.
         **/
        itemsDraggable: boolean;

        /**
         * Gets or sets whether the ListView control's items can be reordered within itself by dragging and dropping.
         **/
        itemsReorderable: boolean;

        /**
         * Gets or sets the WinJS.Binding.Template or templating function that creates the DOM elements for each item in the itemDataSource. Each item can contain multiple elements, but it must have a single root element.
         **/
        itemTemplate: any;

        /**
         * Gets or sets an object that controls the layout of the ListView.
         **/
        layout: ILayout2;

        /**
         * Gets or sets a value that specifies how the ListView fetches items and adds and removes them to the DOM. Don't change the value of this property after the ListView has begun loading data.
         **/
        loadingBehavior: string;

        /**
         * Gets a value that indicates whether the ListView is still loading or whether loading is complete.
         **/
        loadingState: string;

        /**
         * Gets or sets the maximum number of realized items.
         **/
        maxDeferredItemCleanup: number;

        /**
         * Gets or sets the number of pages to load when the loadingBehavior property is set to "incremental" and the user scrolls beyond the threshold specified by the pagesToLoadThreshold property.
         **/
        pagesToLoad: number;

        /**
         * Gets or sets the threshold (in pages) for initiating an incremental load. When the last visible item is within the specified number of pages from the end of the loaded portion of the list, and if automaticallyLoadPages is true and loadingBehavior is set to "incremental", the ListView initiates an incremental load.
         **/
        pagesToLoadThreshold: number;

        /**
         * Gets or sets the function that is called when the ListView discards or recycles the element representation of a group header.
         **/
        resetGroupHeader: (header: any, element: HTMLElement) => void;

        /**
         * Gets or sets the function that is called when an item is removed, an item is changed, or an item falls outside of the realized range of the ListView.
         **/
        resetItem: (item: T, element: HTMLElement) => void;

        /**
         * Gets or sets the distance, in pixels, of the start of the viewable area within the viewport.
         **/
        scrollPosition: number;

        /**
         * Gets an ISelection that contains the range of currently selected items.
         **/
        selection: ISelection<T>;

        /**
         * Gets or sets the selection mode of the ListView.
         **/
        selectionMode: SelectionMode;

        /**
         * Gets or sets how the ListView reacts to the swipe gesture. The swipe gesture can select the swiped items or can have no effect on the current selection.
         **/
        swipeBehavior: WinJS.UI.SwipeBehavior;

        /**
         * Gets or sets how the ListView reacts when the user taps or clicks an item.
         **/
        tapBehavior: TapBehavior;

        /**
         * Gets a ZoomableView that supports semantic zoom functionality. This API supports the SemanticZoom infrastructure and is not intended to be used directly from your code.
         **/
        zoomableView: IZoomableView<ListView<T>>;

        //#endregion Properties
    }

    /**
     * Represents a command to be displayed in a Menu object.
     **/
    class MenuCommand {
        //#region Constructors

        /**
         * Creates a new MenuCommand object.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new MenuCommand.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param type The event type to register. It must be beforeshow, beforehide, aftershow, or afterhide.
         * @param listener The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
         **/
        addEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Disposes this control.
         **/
        dispose(): void;

        /**
         * Removes an event handler that the addEventListener method registered.
         * @param type The event type to unregister. It must be beforeshow, beforehide, aftershow, or afterhide.
         * @param listener The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
         **/
        removeEventListener(type: string, listener: Function, useCapture?: boolean): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets a value that indicates whether the MenuCommand is disabled.
         **/
        disabled: boolean;

        /**
         * Gets the DOM element that hosts the MenuCommand.
         **/
        element: HTMLElement;

        /**
         * Adds an extra CSS class during construction.
         **/
        extraClass: string;

        /**
         * Gets or sets the Flyout object displayed by this command. The specified flyout is shown when the MenuCommand's button is invoked.
         **/
        flyout: Flyout;

        /**
         * Gets a value that indicates whether the MenuCommand is hidden or in the process of becoming hidden.
         **/
        hidden: boolean;

        /**
         * Gets the element identifier (ID) of the command.
         **/
        id: string;

        /**
         * Gets or sets the label of the command.
         **/
        label: string;

        /**
         * Gets or sets the function to be invoked when the command is clicked.
         **/
        onclick: Function;

        /**
         * Gets or sets the selected state of a toggle button.
         **/
        selected: boolean;

        /**
         * Gets the type of the command.
         **/
        type: string;

        //#endregion Properties
    }

    /**
     * Represents a navigation command in a NavBarContainer.
     **/
    class NavBarCommand {
        //#region Constructors

        /**
         * Creates a new NavBarCommand.
         * @constructor
         * @param element The DOM element hosts the new NavBarCommand.
         * @param options An object that contains one or more property/value pairs to apply to the new control. Each property of the options object corresponds to one of the control's properties or events.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param eventName The name of the event to handle. Note that you drop the "on" when specifying the event name. For example, instead of specifying "onclick", you specify "click".
         * @param eventHandler The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
         **/
        addEventListener(eventName: string, eventHandler: Function, useCapture?: boolean): void;

        /**
         * Raises an event of the specified type and with additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event, otherwise false.
         **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Releases resources held by this NavBarCommand. Call this method when the NavBarCommand is no longer needed. After calling this method, the NavBarCommand becomes unusable.
         **/
        dispose(): void;

        /**
         * Removes an event handler that the addEventListener method registered.
         * @param eventName The name of the event that the event handler is registered for.
         * @param eventCallback The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
         **/
        removeEventListener(eventName: string, eventCallback: Function, useCapture?: boolean): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets the HTML element that hosts this NavBarCommand.
         **/
        element: HTMLElement;

        /**
         * Gets or sets the command's icon.
         **/
        icon: string;

        /**
         * Gets or sets the label of the command.
         **/
        label: string;

        /**
         * Get or sets the location to navigate to when this command is invoked.
         **/
        location: any;

        /**
         * Gets or sets a value that specifies whether to show the split tab stop.
         **/
        splitButton: boolean;

        /**
         * Gets a value that indicates whether the splitButton is open.
         **/
        splitOpened: boolean;

        /**
         * Gets or sets a user-defined object that represents the state associated with the command's location.
         **/
        state: any;

        /**
         * Gets or sets the tooltip of the command.
         **/
        tooltip: any;

        //#endregion Properties
    }

    /**
     * Contains a group of NavBarCommand objects in a NavBar.
     **/
    class NavBarContainer {
        //#region Constructors

        /**
         * Creates a new NavBarContainer.
         * @constructor
         * @param element The DOM element hosts the new NavBarContainer.
         * @param options An object that contains one or more property/value pairs to apply to the new control. Each property of the options object corresponds to one of the control's properties or events.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Events

        /**
         * Occurs when a child NavBarCommand object's click event fires.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.index, detail.navbarcommand, detail.data.
         **/
        oninvoked(eventInfo: CustomEvent): void;

        /**
         * Occurs when the split button of a child NavBarCommand is opened or closed. A split button is toggled when the user navigates to another page or opens another split button.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.opened, detail.index, detail.navbarcommand, detail.data.
         **/
        onsplittoggle(eventInfo: CustomEvent): void;

        //#endregion Events

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param eventName The name of the event to handle. Note that you drop the "on" when specifying the event name. For example, instead of specifying "onclick", you specify "click".
         * @param eventHandler The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
         **/
        addEventListener(eventName: string, eventHandler: Function, useCapture?: boolean): void;

        /**
         * Raises an event of the specified type and with additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event, otherwise false.
         **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Releases resources held by this NavBarCommand. Call this method when the NavBarCommand is no longer needed. After calling this method, the NavBarCommand becomes unusable.
         **/
        dispose(): void;

        /**
         * Forces the NavBarContainer to update its layout. Use this function when making the NavBarContainer visible again after you set its style.display property to "none".
         **/
        forceLayout(): void;

        /**
         * Removes an event handler that the addEventListener method registered.
         * @param eventName The name of the event that the event handler is registered for.
         * @param eventCallback The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
         **/
        removeEventListener(eventName: string, eventCallback: Function, useCapture?: boolean): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets the index of the current item.
         **/
        currentIndex: number;

        /**
         * Gets or sets a WinJS.Binding.List that generates NavBarCommand objects.
         **/
        data: WinJS.Binding.List<NavBarCommand>;

        /**
         * Gets the HTML element that hosts this NavBarContainer.
         **/
        element: HTMLElement;

        /**
         * Gets or sets a value that specifies whether NavBarCommand objects in this container use a fixed or dynamic width.
         **/
        fixedSize: boolean;

        /**
         * Gets or sets a value that specifies whether the NavBarContainer has a horizontal or vertical layout.
         **/
        layout: Orientation;

        /**
         * Gets or sets a value that specifies how many rows of navigation commands to display on a page.
         **/
        maxRows: number;

        /**
         * Gets or sets the WinJS.Binding.Template or templating function that creates the DOM elements for each item in the data source. Each item can contain multiple elements, but it must have a single root element.
         **/
        template: WinJS.Binding.Template;

        //#endregion Properties
    }

    /**
     * Enables the user to zoom between two different views supplied by two child controls. One child control supplies the zoomed-out view and the other provides the zoomed-in view.
     **/
    class SemanticZoom {
        //#region Constructors

        /**
         * Creates a new SemanticZoom.
         * @constructor
         * @param element The DOM element that hosts the SemanticZoom.
         * @param options An object that contains one or more property/value pairs to apply to the new control. This object can contain these properties: initiallyZoomedOut Boolean, zoomFactor 0.2–0.85.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Events

        /**
         * Occurs when the control zooms in or out.
         * @param eventInfo An object that contains information about the event. The detail property of this object is true when the control is zoomed out. Otherwise, it's false.
         **/
        onzoomchanged(eventInfo: CustomEvent): void;

        //#endregion Events

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param eventName The name of the event to handle.
         * @param eventHandler The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
         **/
        addEventListener(eventName: string, eventHandler: Function, useCapture?: boolean): void;

        /**
         * Raises an event of the specified type and with additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event, otherwise false.
         **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Releases resources held by this SemanticZoom. Call this method when the SemanticZoom is no longer needed. After calling this method, the SemanticZoom becomes unusable.
         **/
        dispose(): void;

        /**
         * Forces the SemanticZoom to update its layout. Use this function when making the SemanticZoom visible again after its style.display property had been set to "none".
         **/
        forceLayout(): void;

        /**
         * Unregisters an event handler for the specified event.
         * @param eventName The name of the event that the event handler is registered for.
         * @param eventCallback The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
         **/
        removeEventListener(eventName: string, eventCallback: Function, useCapture?: boolean): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets the DOM element that hosts the SemanticZoom control.
         **/
        element: HTMLElement;

        /**
         * Gets or a sets a value that specifies whether to display the SemanticZoom zoom out button.
         **/
        enableButton: boolean;

        /**
         * Determines whether any controls contained in a SemanticZoom should be processed separately. This property is always true, meaning that the SemanticZoom takes care of processing its own controls.
         **/
        isDeclarativeControlContainer: boolean;

        /**
         * Gets or sets a value that indicates whether SemanticZoom is locked and zooming between views is disabled.
         **/
        locked: boolean;

        /**
         * Gets or sets a value that indicates whether the control is zoomed out.
         **/
        zoomedOut: boolean;

        /**
         * Gets or sets a value that specifies how much the scaling the cross-fade animation performs when the SemanticZoom transitions between views.
         **/
        zoomFactor: number;

        //#endregion Properties
    }

    /**
     * Provides users with fast, in-context access to settings that affect the current Windows Store app.
     **/
    class SettingsFlyout {
        //#region Constructors

        /**
         * Creates a new SettingsFlyout object.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new SettingsFlyout.
         **/
        constructor(element?: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Events

        /**
         * Raised immediately after the SettingsFlyout is completely hidden.
         * @param eventInfo An object that contains information about the event.
         **/
        onafterhide(eventInfo: Event): void;

        /**
         * Raised immediately after a SettingsFlyout is fully shown.
         * @param eventInfo An object that contains information about the event.
         **/
        onaftershow(eventInfo: Event): void;

        /**
         * Raised just before hiding a SettingsFlyout.
         * @param eventInfo An object that contains information about the event.
         **/
        onbeforehide(eventInfo: Event): void;

        /**
         * Raised just before showing a SettingsFlyout.
         * @param eventInfo An object that contains information about the event.
         **/
        onbeforeshow(eventInfo: Event): void;

        //#endregion Events

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param type The event type to register. It must be beforeshow, beforehide, aftershow, or afterhide.
         * @param listener The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
         **/
        addEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Raises an event of the specified type and with additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event, otherwise false.
         **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Releases resources held by this SettingsFlyout. Call this method when the SettingsFlyout is no longer needed. After calling this method, the SettingsFlyout becomes unusable.
         **/
        dispose(): void;

        /**
         * Hides the SettingsFlyout, if visible, regardless of other states.
         **/
        hide(): void;

        /**
         * Loads a fragment of the SettingsFlyout. Your app calls this when the user invokes a settings command and the WinJS.Application.onsettings event occurs.
         * @param e An object that contains information about the event, received from the WinJS.Application.onsettings event. The detail property of this object contains the applicationcommands sub-property that you set to an array of settings commands. You then populate the SettingsFlyout with these commands by a call to populateSettings.
         **/
        static populateSettings(e: CustomEvent): void;

        /**
         * Removes an event handler that the addEventListener method registered.
         * @param type The event type to unregister. It must be beforeshow, beforehide, aftershow, or afterhide.
         * @param listener The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
         **/
        removeEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Shows the SettingsPane UI, if hidden.
         **/
        show(): void;

        /**
         * Shows the SettingsPane UI, if hidden, regardless of other state.
         **/
        static show(): void;

        /**
         * Show the Settings flyout using the Settings element identifier (ID) and the path of the page that contains the Settings element.
         * @param id The ID of the Settings element.
         * @param path The path of the page that contains the Settings element.
         **/
        static showSettings(id: string, path: any): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets the DOM element the SettingsFlyout is attached to.
         **/
        element: HTMLElement;

        /**
         * Gets whether the SettingsFlyout is hidden.
         **/
        hidden: boolean;

        /**
         * Gets or sets the settings command Id for the SettingsFlyout control.
         **/
        settingsCommandId: string;

        /**
         * This property may be unavailable or altered in future versions. Use the CSS width property of the element that has the win-settingsflyout class instead.
         **/
        width: string;

        //#endregion Properties
    }

    /**
     * A type of IListDataSource that provides read-access to an object that implements the IStorageQueryResultBase interface. A StorageDataSource enables you to query and bind to items in the data source.
     **/
    class StorageDataSource<T> {
        //#region Constructors

        /**
         * Creates a new StorageDataSource object.
         * @constructor
         * @param query The IStorageQueryResultBase that the StorageDataSource obtains its items from. Instead of IStorageQueryResultBase, you can also pass one of these string values: Music, Pictures, Videos, Documents.
         * @param options The set of properties and values to apply to the new StorageDataSource. Properties on this object may include: mode , requestedThumbnailSize , thumbnailOptions , synchronous .
         **/
        constructor(query: any, options?: any);

        //#endregion Constructors

        //#region Methods

        /**
         * Draws the thumbnail for the specified item to the specified img element.
         * @param item The item to retrieve the thumbnail for.
         * @param image The img element that will display the thumbnail.
         * @returns A Promise that completes when the full-quality thumbnail is visible.
         **/
        loadThumbnail(item: IItem<T>, image: HTMLImageElement): Promise<void>;

        //#endregion Methods
    }

    /**
     * Prevents a DOM sub-tree from receiving tab navigations and focus.
     **/
    class TabContainer {
        //#region Constructors

        /**
         * Creates a new TabContainer.
         * @constructor
         * @param element The DOM element that hosts the TabContainer control.
         * @param options An object that contains one or more property/value pairs to apply to the new control. Each property of the options object corresponds to one of the control's properties.
         **/
        constructor(element: HTMLElement, options?: any);

        //#endregion Constructors

        //#region Methods

        /**
         * Releases resources held by this TabContainer. Call this method when the TabContainer is no longer needed. After calling this method, the TabContainer becomes unusable.
         **/
        dispose(): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets the child DOM element that receives tab focus.
         **/
        childFocus: HTMLElement;

        /**
         * Gets or sets the tab index of this container.
         **/
        tabIndex: number;

        //#endregion Properties
    }

    /**
     * Serves as the base class for a custom IListDataSource.
     **/
    class VirtualizedDataSource<T> {
        //#region Constructors

        /**
         * Initializes the VirtualizedDataSource base class of a custom data source.
         * @constructor
         * @param listDataAdapter The object that supplies data to the VirtualizedDataSource.
         * @param options An object that can contain properties that specify additional options for the VirtualizedDataSource. It supports these properties: cacheSize.
         **/
        constructor(listDataAdapter: IListDataAdapter<T>, options?: any);

        //#endregion Constructors

        //#region Events

        /**
         * Occurs when the status of the VirtualizedDataSource changes.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: status.
         **/
        statuschanged(eventInfo: CustomEvent): void;

        //#endregion Events

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param eventName The name of the event to handle. See the VirtualizedDataSource object page for a list of events. Note that you drop the "on" when specifying the event name for the addEventListener method. For example, instead of specifying "onstatuschanged", you specify "statuschanged".
         * @param eventHandler The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
         **/
        addEventListener(eventName: string, eventHandler: Function, useCapture?: boolean): void;

        /**
         * Raises an event of the specified type and with additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event, otherwise false.
         **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Removes an event handler that the addEventListener method registered.
         * @param eventName The name of the event that the event handler is registered for. See the VirtualizedDataSource object page for a list of events.
         * @param eventCallback The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
         **/
        removeEventListener(eventName: string, eventCallback: Function, useCapture?: boolean): void;

        //#endregion Methods
    }

    //#endregion Objects

    //#region Functions

    /**
     * Returns a new IListDataSource that adds group information to the items of another IListDataSource.
     * @param listDataSource The data source for the individual items to group.
     * @param groupKey A callback function that accepts a single argument: an item in the IListDataSource. The function is called for each item in the list and must return the group key for that item as a string.
     * @param groupData A callback function that accepts a single argument: an item in the IListDataSource. The function is called on one IListDataSource item for each group and must return an object that represents the header of that group.
     * @param options An object that can contain properties that specify additional options: groupCountEstimate, batchSize.
     * @returns An IListDataSource that contains the items in the original data source and provides additional group information in the form of a "groups" property. The "groups" property returns another IListDataSource that enumerates the different groups in the list.
     **/
    function computeDataSourceGroups<T>(listDataSource: IListDataSource<T>, groupKey: Function, groupData: Function, options?: any): IListDataSource<T>;

    /**
     * Used to disables all Animations Library and ListView animations. Calling this function does not guarantee that the animations will be disabled, as the determination is made based on several factors.
     **/
    function disableAnimations(): void;

    /**
     * Used to enable all Animations Library and ListView animations. Calling this function does not guarantee that the animations will be enabled, as the determination is made based on several factors.
     **/
    function enableAnimations(): void;

    /**
     * Marks a event handler function as being compatible with declarative processing.
     * @param handler The handler to be marked as compatible with declarative processing.
     * @returns The handler, marked as compatible with declarative processing.
     **/
    function eventHandler(handler: any): any;

    /**
     * Asynchronously executes a collection of CSS animations on a collection of elements. This is the underlying animation mechanism used by the Animations Library. Apps are encouraged to use the Animations Library to conform with the standard look and feel of the rest of the system, rather than calling this function directly.
     * @param element Element or elements to be animated. This parameter can be expressed in several ways: As the special value "undefined", which means that the animation has no target, As a single object, As a JavaScript array (possibly empty), in which each element of the array can be a single element or a JavaScript array of elements., As a NodeList (for example, the result of querySelectorAll), As an HTMLCollection.
     * @param animation The animation description or an array of animation descriptions to apply to element. An animation description is a JavaScript object with specific properties, listed below. There are two types of animation descriptions: one for keyframe-based animations and one for explicit animations. These types are distinguished by whether the keyframe property has a defined value. The following properties are required for both types of animation descriptions: property (string), delay (number), duration (number), timing (string). If an animation has a keyframe property with a defined, non-null value, then the animation is a keyframe-based animation. A keyframe-based animation description requires the following property in addition to those mentioned above: keyframe (string). If an animation does not have a keyframe property, or if the value of the property is null or undefined, then the animation is an explicit animation. An explicit animation description requires the following properties in addition to the common properties mentioned above: from, to. The values given in the from and to properties must be valid for the CSS property specified by the property property. For example, if the CSS property is "opacity", then the from and to properties must be numbers between 0 and 1 (inclusive).
     * @returns Returns a Promise object that completes when the CSS animation is complete.
     **/
    function executeAnimation(element: HTMLElement, animation: any): Promise<any>;

    /**
     * Asynchronously executes a collection of CSS transitions on a collection of elements. This is the underlying animation mechanism used by the Animations Library. Apps are encouraged to use the Animations Library to conform with the standard look and feel of the rest of the system, rather than calling this function directly.
     * @param element Element or elements on which to perform the transition. This parameter can be expressed in several ways: As the special value "undefined", which means that the transition has no target, As a single object, As a JavaScript array (possibly empty), in which each element of the array can be a single element or a JavaScript array of elements., As a NodeList (for example, the result of querySelectorAll), As an HTMLCollection.
     * @param transition The transition description or an array of transition descriptions to apply to element. A transition description is a JavaScript object with these properties: property (string), delay (number), duration (number), timing (string), from (optional), to. The values given in the from and to properties must be valid for the CSS property specified by the property property. For example, if the CSS property is "opacity", then the from and to properties must be numbers between 0 and 1 (inclusive).
     * @returns Returns a Promise that completes when the transition is finished.
     **/
    function executeTransition(element: HTMLElement, transition: any): Promise<any>;

    /**
     * Retrieves the items in the specified index range.
     * @param dataSource The data source that contains the items to retrieve.
     * @param ranges An array of ISelectionRange objects that have firstIndex and lastIndex values.
     * @returns A Promise that contains an array of the requested IItem objects.
     **/
    function getItemsFromRanges<U>(dataSource: IListDataSource<U>, ranges: ISelectionRange[]): Promise<IItem<U>>;

    /**
     * Determines whether the Animations Library and ListView animations will be performed if called.
     * @returns Returns true if animations will be performed; otherwise false.
     **/
    function isAnimationEnabled(): boolean;

    /**
     * Applies declarative control binding to all elements, starting at the specified root element.
     * @param rootElement The element at which to start applying the binding. If this parameter is not specified, the binding is applied to the entire document.
     * @param skipRoot If true, the elements to be bound skip the specified root element and include only the children.
     * @returns A promise that is fulfilled when binding has been applied to all the controls.
     **/
    function processAll(rootElement?: Element, skipRoot?: boolean): Promise<any>;

    /**
     * Applies declarative control binding to the specified element.
     * @param element The element to bind.
     * @returns A promise that is fulfilled after the control is activated. The value of the promise is the control that is attached to element.
     **/
    function process(element: Element): Promise<any>;

    /**
     * Walks the DOM tree from the given element to the root of the document. Whenever a selector scope is encountered, this method performs a lookup within that scope for the specified selector string. The first matching element is returned.
     * @param selector The selector string.
     * @param element The element to begin walking to the root of the document from.
     * @returns The target element, if found.
     **/
    function scopedSelect(selector: string, element: HTMLElement): HTMLElement;

    /**
     * Given a DOM element and a control, attaches the control to the element.
     * @param element Element to associate with the control.
     * @param control The control to attach to the element.
     **/
    function setControl(element: HTMLElement, control: any): void;

    /**
     * Adds the set of declaratively specified options (properties and events) to the specified control. If name of the options property begins with "on", the property value is a function and the control supports addEventListener. setControl calls addEventListener on the control.
     * @param control The control on which the properties and events are to be applied.
     * @param options The set of options that are specified declaratively.
     **/
    function setOptions(control: any, options?: any): void;

    //#endregion Functions
}
/**
 * Provides functions to load HTML content programmatically.
 **/
declare module WinJS.UI.Fragments {
    //#region Functions

    /**
     * Starts loading the fragment at the specified location. The returned promise completes when the fragment is ready to be copied.
     * @param href The URI that contains the fragment to be copied.
     * @returns A promise that is fulfilled when the fragment has been prepared for copying.
     **/
    function cache(href: string): Promise<any>;

    /**
     * Removes any cached information about the specified fragment. This method does not unload any scripts or styles that are referenced by the fragment.
     * @param href The URI that contains the fragment to be cleared. If no URI is provided, the entire contents of the cache are cleared.
     **/
    function clearCache(href: string): void;

    /**
     * Loads the contents of the specified URI into the specified element without copying it.
     * @param href The URI that contains the fragment to copy.
     * @param element Optional. The element to which the fragment is appended.
     * @returns A promise that is fulfilled when the fragment has been loaded. If a target element is not specified, the copied fragment is the completed value. The element is not added to the cache. See also rendercopy, where the element is added to the cache.
     **/
    function render(href: string, element?: HTMLElement): Promise<HTMLElement>;

    /**
     * Loads and copies the contents of the specified URI into the specified element.
     * @param href The URI that contains the fragment to copy.
     * @param target The element to which the fragment is appended.
     * @returns A promise that is fulfilled when the fragment has been loaded. If a target element is not specified, the copied fragment is the completed value. The fragment is added to the cache. See also render, where the element is not added to the cache.
     **/
    function renderCopy(href: string, target?: HTMLElement): Promise<HTMLElement>;

    //#endregion Functions
}
/**
 * Provides methods for defining and displaying PageControl objects.
 **/
declare module WinJS.UI.Pages {
    //#region Interfaces

    /**
     * Provides members for a PageControl. You implement this interface when defining a new PageControl.
     **/
    interface IPageControlMembers {
        //#region Methods

        /**
         * Called if any error occurs during the processing of the page.
         * @param err The error that occurred.
         * @returns Nothing if the error was handled, or an error promise if the error was not handled.
         **/
        error?(err: any): Promise<any>;

        /**
         * Initializes the control before the content of the control is set. Use the processed method for any initialization that should be done after the content of the control has been set.
         * @param element The DOM element that will contain all the content for the page.
         * @param options The options passed to the constructor of the page.
         * @returns A promise that is fulfilled when initialization is complete, if asynchronous processing is necessary. If not, returns nothing.
         **/
        init?(element: HTMLElement, options: any): Promise<any>;

        /**
         * Creates DOM objects from the content in the specified URI. This method is called after the PageControl is defined and before the init method is called.
         * @param uri The URI from which to create DOM objects.
         * @returns A promise whose fulfilled value is the set of unparented DOM objects.
         **/
        load?(uri: string): Promise<any>;

        /**
         * Initializes the control after the content of the control is set.
         * @param element The DOM element that will contain all the content for the page.
         * @param options The options that are to be passed to the constructor of the page.
         * @returns A promise that is fulfilled when initialization is complete, if asynchronous processing is necessary. If not, returns nothing.
         **/
        processed?(element: HTMLElement, options: any): Promise<any>;

        /**
         * Called after all initialization and rendering is complete. At this time, the element is ready for use.
         * @param element The DOM element that contains all the content for the page.
         * @param options An object that contains one or more property/value pairs to apply to the PageControl. How these property/value pairs are used (or not used) depends on the implementation of that particular PageControl.
         * @returns A promise that is fulfilled when the element is ready for use, if asynchronous processing is necessary. If not, returns nothing.
         **/
        ready?(element: HTMLElement, options: any): Promise<any>;

        attache?(element: HTMLElement, options: any): Promise<any>;

        detache?(element: HTMLElement, options: any): Promise<any>;

        /**
         * Takes the elements returned by the load method and attaches them to the specified element.
         * @param element The DOM element to which the loadResult elements are appended.
         * @param options An object that contains one or more property/value pairs to apply to the PageControl. How these property/value pairs are used (or not used) depends on the implementation of that particular PageControl.
         * @param loadResult A Promise that contains the elements returned from the load method.
         **/
        render?(element: HTMLElement, options: any, loadResult: Promise<any>): void;

        //#endregion Methods
    }

    //#endregion Interfaces

    //#region Objects

    /**
     * A modular unit of HTML, CSS, and JavaScript that can be navigated to or used as a custom WinJS control.
     **/
    class PageControl { }

    //#endregion Objects

    //#region Functions

    /**
     * Creates a new PageControl from the specified URI that contains the specified members. Multiple calls to this method for the same URI are allowed, and all members will be merged.
     * @param uri The URI for the content that defines the page.
     * @param members An object that defines the members that the control will have.
     * @returns A constructor function that creates the PageControl.
     **/
    function define(uri: string, members: IPageControlMembers): PageControl;

    /**
     * Gets an already-defined page control for the specified URI, or creates a new one.
     * @param uri The URI for the content that defines the page.
     * @returns A constructor function that creates the page.
     **/
    function get(uri: string): Function;

    /**
     * Creates a PageControl from the specified URI and inserts it inside the specified element.
     * @param uri The URI for the content that defines the page.
     * @param element The DOM element to which the PageControl is appended.
     * @param options An object that contains one or more property/value pairs to apply to the new PageControl. How these property/value pairs are used (or not used) depends on the implementation of that particular PageControl.
     * @param parentedPromise A Promise that is fulfilled when the new PageControl is done rendering and its contents becomes the child of element.
     * @returns A promise that is fulfilled when rendering is complete, if asynchronous processing is necessary. If not, returns nothing.
     **/
    function render(uri: string, element: HTMLElement, options?: any, parentedPromise?: Promise<any>): Promise<void>;

    //#endregion Functions
}
/**
 * Provides methods for detecting when the user tabs to or from DOM elements.
 **/
declare module WinJS.UI.TrackTabBehavior {
    //#region Functions

    /**
     * Sets the tab order for the specified element within its container.
     * @param element The element to update.
     * @param tabIndex The index value of the element within its container.
     **/
    function attach(element: HTMLElement, tabIndex: number): void;

    /**
     * Removes the tab order information from the specified element.
     * @param element The element to remove tab information from.
     **/
    function detatch(element: HTMLElement): void;

    //#endregion Functions
}
/**
 * Provides helper functions, for example, functions to add and remove CSS classes.
 **/
declare module WinJS.Utilities {
    //#region Enumerations

    /**
     * Defines a set of keyboard values.
     **/
    enum Key {
        /**
         * The BACKSPACE key.
         **/
        backspace,
        /**
         * The TAB key.
         **/
        tab,
        /**
         * The ENTER key.
         **/
        enter,
        /**
         * The SHIFT key.
         **/
        shift,
        /**
         * The CTRL key.
         **/
        ctrl,
        /**
         * The ALT key.
         **/
        alt,
        /**
         * The PAUSE key.
         **/
        pause,
        /**
         * The CAPS LOCK key.
         **/
        capsLock,
        /**
         * The ESCAPE key.
         **/
        escape,
        /**
         * The SPACE key.
         **/
        space,
        /**
         * The PAGE UP key.
         **/
        pageUp,
        /**
         * The PAGE DOWN key.
         **/
        pageDown,
        /**
         * The END key.
         **/
        end,
        /**
         * The HOME key.
         **/
        home,
        /**
         * The LEFT ARROW key.
         **/
        leftArrow,
        /**
         * The UP ARROW key.
         **/
        upArrow,
        /**
         * The RIGHT ARROW key.
         **/
        rightArrow,
        /**
         * The DOWN ARROW key.
         **/
        downArrow,
        /**
         * The INSERT key.
         **/
        insert,
        /**
         * The DELETE key.
         **/
        deleteKey,
        /**
         * The 0 key.
         **/
        num0,
        /**
         * The 1 key.
         **/
        num1,
        /**
         * The 2 key.
         **/
        num2,
        /**
         * The 3 key.
         **/
        num3,
        /**
         * The 4 key.
         **/
        num4,
        /**
         * The 5 key.
         **/
        num5,
        /**
         * The 6 key.
         **/
        num6,
        /**
         * The 7 key.
         **/
        num7,
        /**
         * The 8 key.
         **/
        num8,
        /**
         * The 9 key.
         **/
        num9,
        /**
         * The a key.
         **/
        a,
        /**
         * The b key.
         **/
        b,
        /**
         * The c key.
         **/
        c,
        /**
         * The d key.
         **/
        d,
        /**
         * The e key.
         **/
        e,
        /**
         * The f key.
         **/
        f,
        /**
         * The g key.
         **/
        g,
        /**
         * The h key.
         **/
        h,
        /**
         * The i key.
         **/
        i,
        /**
         * The j key.
         **/
        j,
        /**
         * The k key.
         **/
        k,
        /**
         * The l key.
         **/
        l,
        /**
         * The m key.
         **/
        m,
        /**
         * The n key.
         **/
        n,
        /**
         * The o key.
         **/
        o,
        /**
         * The p key.
         **/
        p,
        /**
         * The q key.
         **/
        q,
        /**
         * The r key.
         **/
        r,
        /**
         * The s key.
         **/
        s,
        /**
         * The t key.
         **/
        t,
        /**
         * The u key.
         **/
        u,
        /**
         * The v key.
         **/
        v,
        /**
         * The w key.
         **/
        w,
        /**
         * The x key.
         **/
        x,
        /**
         * The y key.
         **/
        y,
        /**
         * The z key.
         **/
        z,
        /**
         * The left Windows key.
         **/
        leftWindows,
        /**
         * The right Windows key.
         **/
        rightWindows,
        /**
         * The menu key.
         **/
        menu,
        /**
         * The 0 key on the numerical keypad.
         **/
        numPad0,
        /**
         * The 1 key on the numerical keypad.
         **/
        numPad1,
        /**
         * The 2 key on the numerical keypad.
         **/
        numPad2,
        /**
         * The 3 key on the numerical keypad.
         **/
        numPad3,
        /**
         * The 4 key on the numerical keypad.
         **/
        numPad4,
        /**
         * The 5 key on the numerical keypad.
         **/
        numPad5,
        /**
         * The 6 key on the numerical keypad.
         **/
        numPad6,
        /**
         * The 7 key on the numerical keypad.
         **/
        numPad7,
        /**
         * The 8 key on the numerical keypad.
         **/
        numPad8,
        /**
         * The 9 key on the numerical keypad.
         **/
        numPad9,
        /**
         * The multiplication key (*).
         **/
        multiply,
        /**
         * The addition key (+).
         **/
        add,
        /**
         * The subtraction key (-).
         **/
        subtract,
        /**
         * The decimal point key (.)
         **/
        decimalPoint,
        /**
         * The division key (/).
         **/
        divide,
        /**
         * The F1 key.
         **/
        F1,
        /**
         * The F2 key.
         **/
        F2,
        /**
         * The F3 key.
         **/
        F3,
        /**
         * The F4 key.
         **/
        F4,
        /**
         * The F5 key.
         **/
        F5,
        /**
         * The F6 key.
         **/
        F6,
        /**
         * The F7 key.
         **/
        F7,
        /**
         * The F8 key.
         **/
        F8,
        /**
         * The F9 key.
         **/
        F9,
        /**
         * The F10 key.
         **/
        F10,
        /**
         * The F11 key.
         **/
        F11,
        /**
         * The F12 key.
         **/
        F12,
        /**
         * The NUMBER LOCK key.
         **/
        numLock,
        /**
         * The SCROLL LOCK key.
         **/
        scrollLock,
        /**
         * The browser BACK key.
         **/
        browserBack,
        /**
         * The browser FORWARD key.
         **/
        browserForward,
        /**
         * The semicolon key (;).
         **/
        semicolon,
        /**
         * The equals key (=).
         **/
        equal,
        /**
         * The comma key (,).
         **/
        comma,
        /**
         * The dash key (-).
         **/
        dash,
        /**
         * The period key (.).
         **/
        period,
        /**
         * The forward slash key (/).
         **/
        forwardSlash,
        /**
         * The grave accent key (`).
         **/
        graveAccent,
        /**
         * The open bracket key ([).
         **/
        openBracket,
        /**
         * The backslash key (\).
         **/
        backSlash,
        /**
         * The close bracket key (]).
         **/
        closeBracket,
        /**
         * The single quote key (').
         **/
        singleQuote,
    }

    //#endregion Enumerations

    //#region Objects
    /**
    * Generates HTML from a set of data. Use this control to generate lists of items.
   **/
    class Repeater {
        //#region Constructors

        /**
         * Creates a new Repeater control.
         * @constructor 
         * @param options An object that contains one or more property/value pairs to apply to the new Repeater. Each property of the options object corresponds to one of the object's properties or events. Event names must begin with "on".
        **/
        constructor(options?: any);

        //#endregion Constructors

        //#region Events

        /**
         * Raised after an item in the Repeater control's data source changes and after the corresponding DOM element has been updated.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.index, detail.key, detail.newElement, detail.newItem, detail.newValue, detail.oldElement, detail.oldItem, detail.oldValue, detail.setPromise.
        **/
        onitemchanged(eventInfo: CustomEvent): void;

        /**
         * Raised after an item in the Repeater control's data source changes but before the corresponding DOM element has been updated.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.index, detail.key, detail.newElement, detail.newItem, detail.newValue, detail.oldElement, detail.oldItem, detail.oldValue, detail.setPromise.
        **/
        onitemchanging(eventInfo: CustomEvent): void;

        /**
         * Raised after an item has been added to the Repeater control's data source and after the corresponding DOM element has been added.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.affectedElement, detail.index, detail.key, detail.value.
        **/
        oniteminserted(eventInfo: CustomEvent): void;

        /**
         * Raised after an item has been added to the Repeater control's data source but before the corresponding DOM element has been added.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.affectedElement, detail.index, detail.key, detail.value.
        **/
        oniteminserting(eventInfo: CustomEvent): void;

        /**
         * Raised after an item has been moved from one index to another in the Repeater control's data source and after the corresponding DOM element has been moved.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.affectedElement, detail.index, detail.key, detail.oldIndex, detail.newIndex.
        **/
        onitemmoved(eventInfo: CustomEvent): void;

        /**
         * Raised after an item has been moved from one index to another in the Repeater control's data source but before the corresponding DOM element has been moved.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.affectedElement, detail.index, detail.key, detail.oldIndex, detail.newIndex.
        **/
        onitemmoving(eventInfo: CustomEvent): void;

        /**
         * Raised after an item has been moved from one index to another in the Repeater control's data source and after the corresponding DOM element has been moved.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.affectedElement, detail.index, detail.item, detail.setPromise.
        **/
        onitemremoved(eventInfo: CustomEvent): void;

        /**
         * Raised after an item has been removed from the Repeater control's data source but before the corresponding DOM element has been removed.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.affectedElement, detail.index, detail.item, detail.setPromise.
        **/
        onitemremoving(eventInfo: CustomEvent): void;

        /**
         * Raised when the Repeater has finished loading a new set of data. This event is only fired on construction. This event is only raised when the Repeater is constructed or its data source or template changes.
         * @param eventInfo An object that contains information about the event.
        **/
        onitemsloaded(eventInfo: CustomEvent): void;

        /**
         * Raised after the Repeater control's underlying data has been updated and after the updated HTML has been reloaded.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.affectedElements.
        **/
        onitemsreloaded(eventInfo: CustomEvent): void;

        /**
         * Raised after the Repeater control's underlying data has been updated but before the updated HTML has been reloaded.
         * @param eventInfo An object that contains information about the event. The detail property of this object contains the following sub-properties: detail.affectedElements, detail.setPromise.
        **/
        onitemsreloading(eventInfo: CustomEvent): void;

        //#endregion Events

        //#region Methods

        /**
         * Registers an event handler for the specified event.
         * @param eventName The name of the event to handle.
         * @param eventHandler The event handler function to associate with the event.
         * @param useCapture Set to true to register the event handler for the capturing phase; otherwise, set to false to register the event handler for the bubbling phase.
        **/
        addEventListener(eventName: string, eventHandler: Function, useCapture?: boolean): void;

        /**
         * Raises an event of the specified type and with additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event, otherwise false.
        **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Releases resources held by this Repeater. Call this method when the Repeater is no longer needed. After calling this method, the Repeater becomes unusable.
        **/
        dispose(): void;

        /**
         * Returns the HTML element for the item at the specified index.
         * @param index The index of the item.
         * @returns The DOM element for the specified item.
        **/
        elementFromIndex(index: number): HTMLElement;

        /**
         * Removes an event handler that the addEventListener method registered.
         * @param eventName The name of the event that the event handler is registered for.
         * @param eventCallback The event handler function to remove.
         * @param useCapture Set to true to remove the capturing phase event handler; set to false to remove the bubbling phase event handler.
        **/
        removeEventListener(eventName: string, eventCallback: Function, useCapture?: boolean): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets or sets the List that provides the Repeater with items to display.
        **/
        data: WinJS.Binding.List<any>;

        /**
         * Gets the DOM element that hosts the Repeater.
        **/
        element: HTMLElement;

        /**
         * Gets the number of items in the Repeater control.
        **/
        length: number;

        /**
         * Gets or sets a WinJS.Binding.Template or custom rendering function that defines the HTML of each item within the Repeater.
        **/
        template: WinJS.Binding.Template;

        //#endregion Properties

    }

    /**
     * A mixin that contains event-related functions.
     **/
    var eventMixin: {
        //#region Methods

        /**
         * Adds an event listener to the control.
         * @param type The type (name) of the event.
         * @param listener The listener to invoke when the event gets raised.
         * @param useCapture If true, initiates capture, otherwise false.
         **/
        addEventListener(type: string, listener: Function, useCapture?: boolean): void;

        /**
         * Raises an event of the specified type and with the specified additional properties.
         * @param type The type (name) of the event.
         * @param eventProperties The set of additional properties to be attached to the event object when the event is raised.
         * @returns true if preventDefault was called on the event.
         **/
        dispatchEvent(type: string, eventProperties: any): boolean;

        /**
         * Removes an event listener from the control.
         * @param type The type (name) of the event.
         * @param listener The listener to remove.
         * @param useCapture true if capture is to be initiated, otherwise false.
         **/
        removeEventListener(type: string, listener: Function, useCapture?: boolean): void;

        //#endregion Methods
    };

    /**
     * Represents the result of a query selector, and provides various operations that perform actions over the elements of the collection.
     **/
    interface QueryCollection<T> extends Array<T> {
        //#region Methods

        /**
         * Adds the specified class to all the elements in the collection.
         * @param name The name of the class to add.
         * @returns This QueryCollection object.
         **/
        addClass(name: string): QueryCollection<T>;

        /**
         * Creates a QueryCollection that contains the children of the specified parent element.
         * @param element The parent element.
         * @returns The QueryCollection that contains the children of the element.
         **/
        children(element: HTMLElement): QueryCollection<T>;

        /**
         * Clears the specified style property for all the elements in the collection.
         * @param name The name of the style property to be cleared.
         * @returns This QueryCollection object.
         **/
        clearStyle(name: string): QueryCollection<T>;

        /**
         * Creates controls that are attached to the elements in this QueryCollection, if the ctor parameter is a function, or configures the controls that are attached to the elements in this QueryCollection, if the ctor parameter is an object.
         * @param ctor If this parameter is a function, it is a constructor function that is used to create controls to attach to the elements. If it is an object, it is the set of options passed to the controls.
         * @param options The options passed to the newly-created controls.
         * @returns This QueryCollection object.
         **/
        control(ctor: any, options?: any): QueryCollection<T>;

        /**
         * Performs an action on each item in the QueryCollection.
         * @param callbackFn The action to perform on each item.
         * @param thisArg The argument to bind to callbackFn.
         * @returns The QueryCollection.
         **/
        forEach(callbackFn: (value: T, index: number, array: T[]) => void, thisArg?: any): QueryCollection<T>;

        /**
         * Gets an item from the QueryCollection.
         * @param index The index of the item to return.
         * @returns A single item from the collection.
         **/
        get(index: number): T;

        /**
         * Gets an attribute value from the first element in the collection.
         * @param name The name of the attribute.
         * @returns The value of the attribute.
         **/
        getAttribute(name: string): any;

        /**
         * Determines whether the specified class exists on the first element of the collection.
         * @param name The name of the class.
         * @returns true if the element has the specified class; otherwise, false.
         **/
        hasClass(name: string): boolean;

        /**
         * Looks up an element by ID and wraps the result in a QueryCollection.
         * @param id The ID of the element.
         * @returns A QueryCollection that contains the element, if it is found.
         **/
        id(id: string): QueryCollection<T>;

        /**
         * Adds a set of items to this QueryCollection.
         * @param items The items to add to the QueryCollection. This may be an array-like object, a document fragment, or a single item.
         **/
        include(items: T): void;

        /**
         * Adds a set of items to this QueryCollection.
         * @param items The items to add to the QueryCollection. This may be an array-like object, a document fragment, or a single item.
         **/
        include(items: T[]): void;

        /**
         * Registers the listener for the specified event on all the elements in the collection.
         * @param eventType The name of the event.
         * @param listener The event handler function to be called when the event occurs.
         * @param capture true if capture == true is to be passed to addEventListener; otherwise, false.
         **/
        listen(eventType: string, listener: Function, capture?: boolean): void;

        /**
         * Executes a query selector on all the elements in the collection and aggregates the result into a QueryCollection.
         * @param query The query selector string.
         * @returns A QueryCollection object containing the aggregate results of executing the query on all the elements in the collection.
         **/
        query(query: any): QueryCollection<T>;

        /**
         * Removes the specified class from all the elements in the collection.
         * @param name The name of the class to be removed.
         * @returns his QueryCollection object.
         **/
        removeClass(name: string): QueryCollection<T>;

        /**
         * Unregisters the listener for the specified event on all the elements in the collection.
         * @param eventType The name of the event.
         * @param listener The event handler function.
         * @param capture true if capture == true; otherwise, false.
         * @returns This QueryCollection object.
         **/
        removeEventListener(eventType: string, listener: Function, capture?: boolean): QueryCollection<T>;

        /**
         * Sets an attribute value on all the items in the collection.
         * @param name The name of the attribute to be set.
         * @param value The value of the attribute to be set.
         * @returns This QueryCollection object.
         **/
        setAttribute(name: string, value: any): QueryCollection<T>;

        /**
         * Sets the specified style property for all the elements in the collection.
         * @param name The name of the style property.
         * @param value The value for the property.
         * @returns This QueryCollection object.
         **/
        setStyle(name: string, value: any): QueryCollection<T>;

        /**
         * Renders a template that is bound to the given data and parented to the elements included in the QueryCollection. If the QueryCollection contains multiple elements, the template is rendered multiple times, once at each element in the QueryCollection per item of data passed.
         * @param templateElement The DOM element to which the template control is attached.
         * @param data The data to render. If the data is an array (or any other object that has a forEach method) then the template is rendered multiple times, once for each item in the collection.
         * @param renderDonePromiseCallback If supplied, this function is called each time the template gets rendered, and is passed a promise that is fulfilled when the template rendering is complete.
         * @returns The QueryCollection.
         **/
        template(templateElement: HTMLElement, data: any, renderDonePromiseCallback: Function): QueryCollection<T>;

        /**
         * Toggles (adds or removes) the specified class on all the elements in the collection. If the class is present, it is removed; if it is absent, it is added.
         * @param name The name of the class to be toggled.
         * @returns This QueryCollection object.
         **/
        toggleClass(name: string): QueryCollection<T>;

        //#endregion Methods
    }

    /**
     * Constructor support for QueryCollection interface
     **/
    export var QueryCollection: {
        new <T>(items: T[]): QueryCollection<T>;
        prototype: QueryCollection<any>;
    };

    //#endregion Objects

    //#region Functions

    /**
     * Adds the specified class to the specified element.
     * @param e The element to which to add the class.
     * @param name The name of the class to add.
     * @returns The element.
     **/
    function addClass<T extends HTMLElement>(e: T, name: string): T;

    /**
     * Gets a collection of elements that are the direct children of the specified element.
     * @param element The parent element.
     * @returns The collection of children of the element.
     **/
    function children(element: HTMLElement): QueryCollection<HTMLElement>;

    /**
     * Converts a CSS positioning string for the specified element to pixels.
     * @param element The element.
     * @param value The CSS positioning string.
     * @returns The number of pixels.
     **/
    function convertToPixels(element: HTMLElement, value: string): number;

    /**
     * Creates an object that has one event for each name passed to the function.
     * @param events A variable list of property names.
     * @returns The object with the specified properties. The names of the properties are prefixed with 'on'.
     **/
    function createEventProperties(...events: string[]): any;

    /**
     * Gets the data value associated with the specified element.
     * @param element The element.
     * @returns The value associated with the element.
     **/
    function data(element: HTMLElement): any;

    /**
     * Disposes all first-generation disposable elements that are descendents of the specified element. The specified element itself is not disposed.
     * @param element The root element whose sub-tree is to be disposed.
     **/
    function disposeSubTree(element: HTMLElement): void;

    /**
     * Removes all the child nodes from the specified element.
     * @param element The element.
     * @returns The element.
     **/
    function empty<T extends HTMLElement>(element: T): T;

    /**
     * Determines whether the specified event occurred within the specified element.
     * @param element The element.
     * @param event The event.
     * @returns true if the event occurred within the element; otherwise, false.
     **/
    function eventWithinElement(element: HTMLElement, event: Event): boolean;

    /**
     * Adds tags and type to a logging message.
     * @param message The message to be formatted.
     * @param tag The tag(s) to be applied to the message. Multiple tags should be separated by spaces.
     * @param type The type of the message.
     * @returns The formatted message.
     **/
    function formatLog(message: string, tag: string, type: string): string;

    /**
     * Gets the height of the content of the specified element. The content height does not include borders or padding.
     * @param element The element.
     * @returns The content height of the element.
     **/
    function getContentHeight(element: HTMLElement): number;

    /**
     * Gets the width of the content of the specified element. The content width does not include borders or padding.
     * @param element The element.
     * @returns The content width of the element.
     **/
    function getContentWidth(element: HTMLElement): number;

    /**
     * Gets the leaf-level type or namespace specified by the name parameter.
     * @param name The name of the member.
     * @param root The root to start in. Defaults to the global object.
     * @returns The leaf-level type or namespace in the specified parent namespace.
     **/
    function getMember(name: string, root?: any): any;

    /**
     * Gets the position of the specified element.
     * @param element The element.
     * @returns An object that contains the left, top, width and height properties of the element.
     **/
    function getPosition(element: HTMLElement): IPosition;

    /**
     * Gets the left coordinate of the specified element relative to the specified parent.
     * @param element The element.
     * @param parent The parent element.
     * @returns The relative left coordinate.
     **/
    function getRelativeLeft(element: HTMLElement, parent: HTMLElement): number;

    /**
     * Gets the top coordinate of the element relative to the specified parent.
     * @param element The element.
     * @param parent The parent element.
     * @returns The relative top coordinate.
     **/
    function getRelativeTop(element: HTMLElement, parent: HTMLElement): number;

    /**
     * Gets the height of the element, including its margins.
     * @param element The element.
     * @returns The height of the element including margins.
     **/
    function getTotalHeight(element: HTMLElement): number;

    /**
     * Gets the width of the element, including margins.
     * @param element The element.
     * @returns The width of the element including margins.
     **/
    function getTotalWidth(element: HTMLElement): number;

    /**
     * Determines whether the specified element has the specified class.
     * @param e The element.
     * @param name The name of the class.
     * @returns true if the element has the class, otherwise false.
     **/
    function hasClass(e: HTMLElement, name: string): boolean;

    /**
     * Returns a collection with zero or one elements matching the specified id.
     * @param id The ID of the element (or elements).
     * @returns A collection of elements whose id matches the id parameter.
     **/
    function id(id: string): QueryCollection<HTMLElement>;

    /**
     * Calls insertAdjacentHTML on the specified element.
     * @param element The element on which insertAdjacentHTML is to be called.
     * @param position The position relative to the element at which to insert the HTML. Possible values are: beforebegin, afterbegin, beforeend, afterend.
     * @param text The text to insert.
     **/
    function insertAdjacentHTML(element: HTMLElement, position: string, text: string): void;

    /**
     * Calls insertAdjacentHTML on the specified element in the context of MSApp.execUnsafeLocalFunction.
     * @param element The element on which insertAdjacentHTML is to be called.
     * @param position The position relative to the element at which to insert the HTML. Possible values are: beforebegin, afterbegin, beforeend, afterend.
     * @param text Value to be provided to insertAdjacentHTML.
     **/
    function insertAdjacentHTMLUnsafe(element: HTMLElement, position: string, text: string): void;

    /**
     * Attaches the default dispose API wrapping the dispose implementation to the specified element.
     * @param element The element to mark as disposable.
     * @param disposeImpl The function containing the element-specific dispose logic, called by the dispose function that markDisposable attaches.
     **/
    function markDisposable(element: HTMLElement, disposeImpl: Function): void;

    /**
     * Marks a function as being compatible with declarative processing. Declarative processing is performed by WinJS.UI.processAll or WinJS.Binding.processAll.
     * @param func The function to be marked as compatible with declarative processing.
     * @returns The input function, marked as compatible with declarative processing.
     **/
    function markSupportedForProcessing<U extends Function>(func: U): U;

    /**
     * Returns a QueryCollection with zero or one elements matching the specified selector query.
     * @param query The CSS selector to use. See Selectors for more information.
     * @param element Optional. The root element at which to start the query. If this parameter is omitted, the scope of the query is the entire document.
     * @returns A QueryCollection with zero or one elements matching the specified selector query.
     **/
    function query(query: any, element?: HTMLElement): QueryCollection<HTMLElement>;

    /**
     * Ensures that the specified function executes only after the DOMContentLoaded event has fired for the current page. The DOMContentLoaded event occurs after the page has been parsed but before all the resources are loaded.
     * @param callback A function that executes after the DOMContentLoaded event has occurred.
     * @param async If true, the callback should be executed asynchronously.
     * @returns A promise that completes after the DOMContentLoaded event has occurred.
     **/
    function ready(callback?: Function, async?: boolean): Promise<any>;

    /**
     * Removes the specified class from the specified element.
     * @param e The element from which to remove the class.
     * @param name The name of the class to remove.
     * @returns The element.
     **/
    function removeClass<T extends HTMLElement>(e: T, name: string): T;

    /**
     * Asserts that the value is compatible with declarative processing. Declarative processing is performed by WinJS.UI.processAll or WinJS.Binding.processAll. If the value is not compatible, and strictProcessing is on, an exception is thrown. All functions that have been declared using WinJS.Class.define, WinJS.Class.derive, WinJS.UI.Pages.define, or WinJS.Binding.converter are automatically marked as supported for declarative processing. Any other function that you use from a declarative context (that is, a context in which an HTML element has a data-win-control or data-win-options attribute) must be marked manually by calling this function. When you mark a function as supported for declarative processing, you are guaranteeing that the code in the function is secure from injection of third-party content.
     * @param value The value to be tested for compatibility with declarative processing. If the value is a function it must be marked with a property supportedForProcessing with a value of true when strictProcessing is on. For more information, see WinJS.Utilities.markSupportedForProcessing.
     * @returns The input value.
     **/
    function requireSupportedForProcessing<T>(value: T): T;

    /**
     * Sets the innerHTML property of the specified element to the specified text.
     * @param element The element on which the innerHTML property is to be set.
     * @param text The value to be set to the innerHTML property.
     **/
    function setInnerHTML(element: HTMLElement, text: string): void;

    /**
     * Sets the innerHTML property of the specified element to the specified text.
     * @param element The element on which the innerHTML property is to be set.
     * @param text The value to be set to the innerHTML property.
     **/
    function setInnerHTMLUnsafe(element: HTMLElement, text: string): void;

    /**
     * Sets the outerHTML property of the specified element to the specified text.
     * @param element The element on which the outerHTML property is to be set.
     * @param text The value to be set to the outerHTML property.
     **/
    function setOuterHTML(element: HTMLElement, text: string): void;

    /**
     * Sets the outerHTML property of the specified element to the specified text in the context of MSApp.execUnsafeLocalFunction.
     * @param element The element on which the outerHTML property is to be set.
     * @param text The value to be set to the outerHTML property.
     **/
    function setOuterHTMLUnsafe(element: HTMLElement, text: string): void;

    /**
     * Configures a logger that writes messages containing the specified tags to the JavaScript console.
     * @param options The tags for messages to log. Multiple tags should be separated by spaces. May contain type, tags, excludeTags and action properties.
     **/
    function startLog(options?: ILogOptions): void;

    /**
     * Removes the WinJS logger that had previously been set up.
     **/
    function stopLog(): void;

    /**
     * Toggles (adds or removes) the specified class on the specified element. If the class is present, it is removed; if it is absent, it is added.
     * @param e The element on which to toggle the class.
     * @param name The name of the class to toggle.
     * @returns The element.
     **/
    function toggleClass<T extends HTMLElement>(e: T, name: string): T;

    //#endregion Functions

    //#region Properties

    /**
     * Gets whether the current script context has access to WinRT APIs.
     **/
    var hasWinRT: boolean;

    /**
     * Indicates whether the app is running on Windows Phone.
     **/
    var isPhone: boolean;

    //#endregion Properties

    //#region Interfaces

    interface ILogOptions {
        type: string;
        action?: (message: string, tags: string, type: string) => void;
        excludeTags: string;
        tags: string;
    }

    interface IPosition {
        left: number;
        top: number;
        width: number;
        height: number;
    }

    //#endregion Interfaces
}
/**
 * Provides functions and objects for scheduling and managing asynchronous tasks.
 **/
declare module WinJS.Utilities.Scheduler {
    //#region Enumerations

    /**
     * Represents a priority for a job managed by the Scheduler.
     **/
    enum Priority {
        /**
         * A priority higher than the normal priority level.
         **/
        aboveNormal,
        /**
         * A priority less than the normal priority level.
         **/
        belowNormal,
        /**
         * A high priority.
         **/
        high,
        /**
         * The idle priority for work items.
         **/
        idle,
        /**
         * The highest priority.
         **/
        max,
        /**
         * The lowest priority.
         **/
        min,
        /**
         * The normal priority for work items.
         **/
        normal,
    }

    //#endregion Enumerations

    //#region Interfaces

    /**
     * Represents a work item that's executed by the Scheduler.
     **/
    interface IJob {
        //#region Methods

        /**
         * Cancels the job.
         **/
        cancel(): void;

        /**
         * Pauses the job.
         **/
        pause(): void;

        /**
         * Resumes the job.
         **/
        resume(): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets a value that indicates whether the job has successfully completed.
         **/
        completed: boolean;

        /**
         * Gets the unique numeric identifier assigned to the job.
         **/
        id: number;

        /**
         * Gets or sets the name of the job.
         **/
        name: string;

        /**
         * Gets or sets the owner of the job.
         **/
        owner: IOwnerToken;

        /**
         * Gets or sets the priority of the job.
         **/
        priority: Priority;

        //#endregion Properties
    }

    /**
     * Provides a control mechanism that allows a job to cooperatively yield. This object is passed to your work function when you schedule it.
     **/
    interface IJobInfo {
        //#region Methods

        /**
         * Uses a Promise to determine how long the scheduler should wait before rescheduling the job after it yields.
         * @param promise Once the work item yields, the scheduler will wait for this Promise to complete before rescheduling the job.
         **/
        setPromise(promise: Promise<any>): void;

        /**
         * Specifies the next unit of work to run once this job yields.
         * @param work The next unit of work to run once this job yields.
         **/
        setWork(work: Function): void;

        //#endregion Methods

        //#region Properties

        /**
         * Gets the work item associated with this IJobInfo.
         **/
        job: IJob;

        /**
         * Gets a value that specifies whether the job should yield.
         **/
        shouldYield: boolean;

        //#endregion Properties
    }

    /**
     * Represents an object that owns jobs. You can use this object to cancel a set of jobs.
     **/
    interface IOwnerToken {
        //#region Methods

        /**
         * Synchronously cancels the job that this token owns, including paused and blocked jobs.
         **/
        cancelAll(): void;

        //#endregion Methods
    }

    //#endregion Interfaces

    //#region Functions

    /**
     * Creates and returns a new IOwnerToken which can be set to the owner property of one or more jobs.
     * @returns A new IOwnerToken which can be set to the owner property of one or more jobs.
     **/
    function createOwnerToken(): IOwnerToken;

    /**
     * Runs the specified callback in a high priority context.
     * @param callback The callback to run in a high priority callback.
     * @returns The return value of the callback.
     **/
    function execHigh<U>(callback: () => U): U;

    /**
     * Returns a string representation of the scheduler's state for diagnostic purposes. The jobs and drain requests are displayed in the order in which they are currently expected to be processed. The current job and drain request are marked by an asterisk.
     * @returns A string representation of the scheduler's state for diagnostic purposes. The jobs and drain requests are displayed in the order in which they are currently expected to be processed. The current job and drain request are marked by an asterisk.
     **/
    function retrieveState(): string;

    /**
     * Runs jobs in the scheduler without timeslicing until all jobs at the specified priority and higher have executed.
     * @param priority The priority to which the scheduler should drain. The default is -15.
     * @param name An optional description of the drain request for diagnostics.
     * @returns A Promise which completes when the drain has finished. Canceling this Promise cancels the drain request. This Promise will never enter an error state.
     **/
    function requestDrain(priority?: Priority, name?: string): Promise<any>;

    /**
     * Schedules the specified function to execute asynchronously.
     * @param work A function that represents the work item to be scheduled. When called the work item will receive as its first argument an object which allows the work item to ask the scheduler if it should yield cooperatively and if so allows the work item to either provide a function to be run as a continuation or a WinJS.Promise which will when complete provide a function to run as a continuation. Provide these fields for the object: shouldYield, setWork(work), setPromise(promise), job.
     * @param priority The priority of the work item. If you don't specify a priority, it defaults to WinJS.Utilities.Scheduler.Priority.normal.
     * @param thisArg A "this" instance to be bound to the work item. The default value is null.
     * @param name A description of the work item for diagnostics. The default value is an empty string.
     * @returns The job instance that represents this work item.
     **/
    function schedule(work: (jobInfo: IJobInfo) => any, priority?: Priority, thisArg?: any, name?: string): IJob;

    /**
     * Schedules a job to complete the returned Promise at WinJS.Utilities.Scheduler.Priority.aboveNormal priority.
     * @param promiseValue The value returned by the completed Promise.
     * @param jobName A string that describes the job for diagnostic purposes.
     * @returns A Promise that completes within a job of aboveNormal priority.
     **/
    function schedulePromiseAboveNormal<U>(promiseValue?: U, jobName?: string): Promise<U>;

    /**
     * Schedules a job to complete the returned Promise at WinJS.Utilities.Scheduler.Priority.belowNormal priority.
     * @param promiseValue The value returned by the completed Promise.
     * @param jobName A string that describes the job for diagnostic purposes.
     * @returns A Promise that completes within a job of belowNormal priority.
     **/
    function schedulePromiseBelowNormal<U>(promiseValue?: U, jobName?: string): Promise<U>;

    /**
     * Schedules a job to complete the returned Promise at WinJS.Utilities.Scheduler.Priority.high priority.
     * @param promiseValue The value returned by the completed Promise.
     * @param jobName A string that describes the job for diagnostic purposes.
     * @returns A Promise that completes within a job of high priority.
     **/
    function schedulePromiseHigh<U>(promiseValue?: U, jobName?: string): Promise<U>;

    /**
     * Schedules a job to complete the returned Promise at WinJS.Utilities.Scheduler.Priority.Idle priority.
     * @param promiseValue The value returned by the completed Promise.
     * @param jobName A string that describes the job for diagnostic purposes.
     * @returns A Promise that completes within a job of idle priority.
     **/
    function schedulePromiseIdle<U>(promiseValue?: U, jobName?: string): Promise<U>;

    /**
     * Schedules a job to complete the returned Promise at WinJS.Utilities.Scheduler.Priority.normal priority.
     * @param promiseValue The value returned by the completed Promise.
     * @param jobName A string that describes the job for diagnostic purposes.
     * @returns A Promise that completes within a job of normal priority.
     **/
    function schedulePromiseNormal<U>(promiseValue?: U, jobName?: string): Promise<U>;

    //#endregion Functions
}

/// <reference path="../defs/winjs/winjs.d.ts" />
/// <reference path="../defs/simplekeyboard/simplekeyboard.d.ts" />
declare namespace VisiWin.System.JSObjects {
    /**
    * JavaScript Date objects represent a single moment in time in a platform-independent format.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date|Date(MDN)}.
    **/
    type Date = any;
    /**
    * The JavaScript Array class is a global object that is used in the construction of arrays; which are high-level, list-like objects.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array|Array(MDN)}.
    **/
    type Array = any;
    /**
    * The Intl object is the namespace for the ECMAScript Internationalization API,
    * which provides language sensitive string comparison, number formatting, and date and time formatting. .
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl|Intl(MDN)}.
    **/
    type Intl = any;
}
declare namespace VisiWin.System.JSPrimitives {
    /**
    * The String object is used to represent and manipulate a sequence of characters.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#string_type|String(MDN)}.
    **/
    type String = string;
    /**
    * Boolean represents a logical entity and can have two values: true and false.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#boolean_type|Boolean(MDN)}.
    **/
    type Boolean = boolean;
    /**
    * The Number type is the reference type for numeric values.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#number_type|Number(MDN)}.
    **/
    type Number = number;
    /**
    * The Null type has exactly one value: null.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#null_type|Null(MDN)}.
    **/
    type Null = null;
    /**
    * A variable that has not been assigned a value has the value undefined.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#undefined_type|Undefined(MDN)}.
    **/
    type Undefined = undefined;
    /**
    * In JavaScript, objects can be seen as a collection of properties(key-value pairs).<br>
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#objects|Objects(MDN)}.
    **/
    type Object = any;
}
declare namespace VisiWin.System.DataAccess {
    type VariantType = string | number | boolean | Array<any> | object | null | undefined | any;
}
/**
* Namespace VisiWin
* @namespace VisiWin
*/
declare namespace VisiWin {
    type IGuid = string;
    /**
    * Checks if the given argument is undefined.
    * @function
    */
    function isUndefined(obj: unknown): boolean;
    /**
     * Checks if the given argument is an object.
     * @function
     */
    function isObject(obj: unknown): boolean;
    /**
     * Checks if the given argument is a function.
     * @function
     */
    function isFunction(func: unknown): boolean;
    /**
     * Checks if the given argument is a string.
     * @function
     */
    function isString(str: unknown): boolean;
    /**
    * Checks if the given argument is a number.
    * @function
    */
    function isNumber(nr: unknown): boolean;
    /**
    * Checks if the given argument is a boolean.
    * @function
    */
    function isBoolean(bool: unknown): boolean;
    /**
    * Checks if the given argument is a array.
    * @function
    */
    function isArray(ar: unknown[]): boolean;
    /**
    * Checks if the given argument is a Date.
    * @function
    */
    function isDate(date: unknown): boolean;
    /**
    * Checks if the given argument is null or Undefined.
    * @function
    */
    function isNullOrUndefined(obj: unknown): boolean;
    /**
    * Checks if the given string is null or empty.
    * @function
    */
    function isNullOrEmpty(s: unknown): boolean;
    function Guid(): VisiWin.IGuid;
    function stringStartsWith(strg: string, searchString: string, position?: number): boolean;
    function stringEndsWith(strg: string, searchString: string, position?: number): boolean;
    /**
     * Sleep Promise
     * Example
     * async function something() {
     *		console.log("this might take some time....");
     *		await VisiWin.sleep(5000);
     *		console.log("5 sec later, we are done")
     * }
     */
    const sleep: (ms: number) => Promise<unknown>;
}
/**
* Namespace VisiWin
* @namespace VisiWin
*/
declare namespace VisiWin.Internal {
    /**
    * Converts a given value to boolean
    * @function
    * @param {string | number | boolean} value The value to be converted.
    */
    function valueToBoolean(value: string | number | boolean): boolean;
    /**
    * Converts a given string to boolean
    * @function
    */
    function stringToBoolean(str: string): boolean;
    function stringContains(str: string, subString: string): boolean;
    /**
    * Joins all the properies of the object using the provided join string
    */
    function makeString<T>(item: T, join?: string): string;
    function SimpleObjectJSONClone(obj: object): any;
    class EnumHelper {
        static getNamesAndValues(e: any): any;
        static getNames(e: any): string[];
        static getValues(e: any): number[];
        static convertToString(enumType: any, key: number): string;
        static convertToNumber(enumType: any, key: string): number;
        private static getObjValues;
        static isEnum(instance: any): boolean;
    }
    function getQueryVariable(variable: string): string | boolean;
    function ArrayContains(theArray: any[], searchObject: any, memberName?: string): boolean;
    function isFloatingType(typeCode: VisiWin.System.DataAccess.TypeCode): boolean;
    function isIntergerType(typeCode: VisiWin.System.DataAccess.TypeCode): boolean;
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System
*/
declare namespace VisiWin.Internal.System {
    interface IBaseType {
        TypeName: string;
        Namespace: string;
        FullName(): string;
    }
    class BaseType implements IBaseType {
        constructor();
        TypeName: string;
        Namespace: string;
        FullName(): string;
        toString(): string;
    }
    interface IBaseClass {
        Type: VisiWin.Internal.System.IBaseType;
        Tag: object;
        toString(): string;
        toJSONString(): string;
        isDisposable: boolean;
        Dispose(): void;
    }
    class BaseClass implements VisiWin.Internal.System.IBaseClass {
        Type: VisiWin.Internal.System.IBaseType;
        isDisposable: boolean;
        constructor();
        private _getClassName;
        toString(): string;
        toJSONString(): string;
        Tag: object;
        Dispose(): void;
    }
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Events
*/
declare namespace VisiWin.Internal.System.Events {
    interface IEvent {
        add(listener: () => void, sourceContext?: any): void;
        remove(listener?: () => void): void;
        remove(listener: () => void, sourceContext?: any): void;
        trigger(...a: any[]): void;
    }
    interface IMessageEvent extends IEvent {
        add(listener: (message: any) => void, sourceContext?: any): void;
        remove(listener?: (message: any) => void): void;
        remove(listener?: (message: any) => void, sourceContext?: any): void;
        trigger(...a: any[]): void;
    }
    interface IEventArgs<T> extends IMessageEvent {
        add(listener: (message: T) => void, sourceContext?: any): void;
        remove(listener?: (message: T) => any): void;
        remove(listener?: (message: T) => void, sourceContext?: any): void;
        trigger(message: T): void;
    }
    interface IEventArgsParams<T, U> extends IEventArgs<T> {
        add(listener: (message1: T, params?: U) => any): void;
        remove(listener?: (message: T, params?: U) => any): void;
        trigger(message: T, params?: U): void;
    }
    class TypedEvent<T, U> implements IEventArgsParams<T, U> {
        private _listeners;
        private _context;
        add(listener: (message: any) => void, sourceContext?: any): void;
        remove(listener?: (message: any) => void): void;
        trigger(...a: any[]): void;
    }
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Exception
*/
declare namespace VisiWin.Internal.System.Exception {
    class Error {
        name: string;
        message: string;
        constructor(message?: string);
    }
    class ExceptionBase implements VisiWin.Internal.System.Exception.Error {
        name: string;
        message: string;
        constructor(name: string, message: string);
    }
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Exception
*/
declare namespace VisiWin.Internal.System.Exception {
    interface IAuthorizedExceptionEventArgs {
        name: string;
        message: string;
        authorized: boolean | null;
        requestID: string;
        result: string;
        text: string;
        param: unknown;
    }
    const onAuthorizedException: VisiWin.Internal.System.Events.IEventArgs<VisiWin.Internal.System.Exception.IAuthorizedExceptionEventArgs>;
    class AuthorizedException extends VisiWin.Internal.System.Exception.ExceptionBase {
        name: string;
        message: string;
        authorized: boolean | null;
        requestID: string;
        result: string;
        text: string;
        param: unknown;
        constructor(name: string, message: string, param?: unknown, authorized?: boolean, requestID?: string, result?: string, text?: string);
    }
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Exception
*/
declare namespace VisiWin.Internal.System.Exception {
    class WindowException extends VisiWin.Internal.System.Exception.ExceptionBase {
        message: string;
        error: any;
        constructor(message: any, fileName: string, lineNumber: number, columnNumber: number, error?: any);
    }
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Exception
*/
declare namespace VisiWin.Internal.System.Exception {
    class ParameterException extends VisiWin.Internal.System.Exception.ExceptionBase {
        name: string;
        message: string;
        authorized: boolean;
        requestID: string;
        result: string;
        text: string;
        param: any;
        constructor(name: string, message: string, param?: any);
        handleError(): void;
        logError(): void;
    }
    function isValidStringParam(str: string, fnName: string, paramName: string): boolean;
    function isValidNumberParam(numb: number, fnName: string, paramName: string): boolean;
    function isValidAnyParam(variant: any, fnName: string, paramName: string): boolean;
    function isValidStringArrayParam(str: string[], fnName: string, paramName: string): boolean;
    function isValidNumberArrayParam(numb: number[], fnName: string, paramName: string): boolean;
    function isValidAnyArrayParam(variant: any[], fnName: string, paramName: string): boolean;
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Exception
*/
declare namespace VisiWin.Internal.System.Exception {
    class NotSupportedException extends VisiWin.Internal.System.Exception.ExceptionBase {
        name: string;
        message: string;
        param: unknown;
        constructor(name?: string, message?: string, param?: string);
    }
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Exception
*/
declare namespace VisiWin.Internal.System.Exception {
    class DeprecatedWarning extends VisiWin.Internal.System.Exception.ExceptionBase {
        name: string;
        message: string;
        authorized: boolean;
        requestID: string;
        result: string;
        text: string;
        param: unknown;
        constructor(nameToWarnFor: string, warnMessage: string, param?: unknown);
        logWarning(): void;
    }
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Diagnostics.Logging
*/
declare namespace VisiWin.Internal.System.Diagnostics.Logging {
    enum LoggerOutPutType {
        Console = 1,
        Alert = 2,
        Server = 3,
        IndexDB = 4
    }
    enum LogLevel {
        Off = 0,
        Verbose = 1,
        Info = 2,
        Warn = 3,
        Error = 4
    }
    enum AppDomainEventSource {
        Alarm = 0,
        DataAccess = 1,
        Language = 3,
        Project = 4,
        Recipe = 5,
        Trend = 6,
        UserManagement = 7,
        Logging = 8,
        ServerObjects = 9,
        System = 10,
        Undefined = 11,
        Socket = 12
    }
    enum AppDomainCategorySource {
        CommandHandler = 1,
        Store = 2,
        Constructor = 3,
        Undefined = 4
    }
    interface ILogger {
        log: (msg: string, objToLog?: any, systemToLog?: AppDomainEventSource, eventToLog?: AppDomainCategorySource, callback?: any) => void;
        addObserver(callback: (msg: string, objToLog?: any) => void): void;
        removeObserver(callback: () => void): void;
        GetLogStack(): IClientLogEntry[];
    }
    interface IClientLogEntry {
        Source: AppDomainEventSource;
        Category: AppDomainCategorySource;
        SourceCategoryText: string;
        LogText: string;
        Parameter: any;
        DateTime: Date;
        CallbackFn: any;
    }
    class Logger implements ILogger {
        constructor(loggerOutPutType: LoggerOutPutType, logLevel: LogLevel, domainLog?: boolean);
        log(msg: string): void;
        log(msg: string, objToLog?: any): void;
        log(msg: string, objToLog?: any, callback?: any): void;
        addObserver(observer: any): void;
        removeObserver(observer: any): void;
        GetLogStack(): IClientLogEntry[];
        private addLogToLogStack;
        private _loggerOutPutType;
        private _logLevel;
        private _write;
        private _outType;
        private _observers;
        private _domainLog;
        private _LogStack;
        private _settings;
        private _consoleLogger;
        private _AppDomainLog;
        private splitSubstring;
        private _alertLog;
        private _serverLog;
        private _shouldLog;
        private _toLog;
        private _stringify;
        private _notifyObservers;
    }
    function ClientLogEntry(msg: string, objToLog?: any, systemToLog?: AppDomainEventSource, eventToLog?: AppDomainCategorySource, callback?: any): IClientLogEntry;
}
/**
* Namespace VisiWin system diagnostics
* @namespace VisiWin.System.Diagnostics.Logger
*/
declare namespace VisiWin.System.Diagnostics.Logger {
    const WebSocketLog: VisiWin.Internal.System.Diagnostics.Logging.ILogger;
    const InfoLog: VisiWin.Internal.System.Diagnostics.Logging.ILogger;
    const WarnLog: VisiWin.Internal.System.Diagnostics.Logging.ILogger;
    const ErrorLog: VisiWin.Internal.System.Diagnostics.Logging.ILogger;
    const ServerLog: VisiWin.Internal.System.Diagnostics.Logging.ILogger;
    const AppDomainLog: VisiWin.Internal.System.Diagnostics.Logging.ILogger;
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Diagnostics
*/
declare namespace VisiWin.Internal.System.Diagnostics {
    interface IPerformanceHelper {
        endMark(): void;
        measure(): void;
        duration(): PerformanceEntry[];
        log(): void;
        reset(): void;
    }
    function performanceMark(markName: string, measureOnEndMark?: boolean): IPerformanceHelper;
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Diagnostics
*/
declare namespace VisiWin.Internal.System.Diagnostics {
    class StopWatch {
        constructor();
        startTime: number;
        stopTime: number;
        running: boolean;
        start(): void;
        stop(): void;
        duration(): number;
        isRunning(): boolean;
        getTime(): number;
    }
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Collections
*/
declare namespace VisiWin.Internal.System.Collections {
    interface IDictionary {
        add(key: string, value: unknown): void;
        remove(key: string): void;
        containsKey(key: string): boolean;
        keys(): string[];
        values(): unknown[];
        getByKey(key: string): unknown;
    }
    class GenericDictionary<T> implements IDictionary {
        [idx: string]: unknown;
        _keys: string[];
        _values: T[];
        constructor(init?: Array<{
            key?: string;
            value?: T;
        }>);
        add(key: string, value: T): void;
        remove(key: string): void;
        keys(): string[];
        values(): T[];
        getByKey(key: string): T;
        containsKey(key: string): boolean;
        toLookup(): IDictionary;
    }
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Net.Websocket
*/
declare namespace VisiWin.Internal.System.Net.Websocket {
    enum SocketState {
        CONNECTING = 0,
        OPEN = 1,
        CLOSING = 2,
        CLOSED = 3,
        ERROR = 4
    }
    enum CloseStatus {
        SUCCESS_CLOSE_STATUS = 1000,
        ENDPOINT_TERMINATED_CLOSE_STATUS = 1001,
        PROTOCOL_ERROR_CLOSE_STATUS = 1002,
        INVALID_DATA_TYPE_CLOSE_STATUS = 1003,
        EMPTY_CLOSE_STATUS = 1005,
        ABORTED_CLOSE_STATUS = 1006,
        INVALID_UTF8_CLOSE_STATUS = 1007,
        POLICY_VIOLATION_CLOSE_STATUS = 1008,
        MESSAGE_TOO_BIG_CLOSE_STATUS = 1009,
        UNSUPPORTED_EXTENSIONS_CLOSE_STATUS = 1010,
        SERVER_ERROR_CLOSE_STATUS = 1011,
        SECURE_HANDSHAKE_ERROR_CLOSE_STATUS = 1015
    }
}
/**
*  *for internal use
* @namespace VisiWin.Internal.System.Net.Websocket
*/
declare namespace VisiWin.Internal.System.Net.Websocket {
    class VWSocket {
        _wasConnected: boolean;
        readyState: number;
        State: number;
        IsOnline: boolean;
        CloseCode: number;
        CloseReason: string;
        private ws;
        private serviceUrl;
        get Url(): string;
        set Url(value: string);
        onWebSocketOpen: VisiWin.Internal.System.Events.IEventArgs<Event>;
        onWebSocketClose: VisiWin.Internal.System.Events.IEventArgs<CloseEvent>;
        onWebSocketError: VisiWin.Internal.System.Events.IEventArgs<Event>;
        onWebSocketMessage: VisiWin.Internal.System.Events.IEventArgs<MessageEvent>;
        onWebSocketSend: VisiWin.Internal.System.Events.IEventArgs<string>;
        private OnOpenHandler;
        private OnMessageHandler;
        private OnCloseHandler;
        private OnErrorHandler;
        constructor(url: string);
        Start(): void;
        /**
        * Send string to websocket server
        * @param evtdata a String value Sends to the server
        */
        Send(evtdata: string): void;
        /**
         * Returns boolean, whether websocket was FORCEFULLY closed.
         */
        Close(code: string): boolean;
        Close(code: string, reason: string): boolean;
        Close(code: number): boolean;
        Close(code: number, reason: string): boolean;
    }
}
declare namespace VisiWin.Internal.System {
    const CONST_VW_NS: any;
}
/**
*
<section class="tsd-panel-group tsd-index-group">
    <h4>Additional Information</h4>
    <section class="tsd-panel tsd-index-panel">
        <div class="tsd-index-content">
            <section class="tsd-index-section ">
             <h4>Examples</h4>
                <ul class="tsd-index-list">
                    <li><a href="../tutorials/Alarm/IAlarmService.html" class="tsd-kind-icon">IAlarmService</a></span></li>
                </ul>
                <ul class="tsd-index-list">
                    <li><a href="../tutorials/Alarm/CurrentAlarms.html" class="tsd-kind-icon">CurrentAlarms</a></span></li>
                    <li><a href="../tutorials/Alarm/CreateAlarmFilter.html" class="tsd-kind-icon">CreateAlarmFilter</a></span></li>
                    <li><a href="../tutorials/Alarm/AcknowledgeAlarm.html" class="tsd-kind-icon">AcknowledgeAlarm</a></span></li>
                </ul>
            </section>
        </div>
    </section>
</section>

*/
declare namespace VisiWin.System.Alarm { }
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.AlarmService
    * @description Class for monitoring alarm class information of an alarm.
    * @memberof VisiWin.System.Alarm
    */
    interface IAlarmService extends VisiWin.Internal.System.IBaseClass {
        /**
        * Returns the names of all alarm groups.
        * @member { string[] }
        */
        GroupNames: string[];
        /**
        * Returns the names of all alarm classes.
        * @member { string[] }
        */
        ClassNames: string[];
        /**
        * Collects and monitors all currently active alarms.
        * @member { VisiWin.System.Alarm.ICurrentAlarms }
        */
        CurrentAlarms: VisiWin.System.Alarm.ICurrentAlarms;
        /**@function
        * Acknowledges an alarm. The system time is used as acknowlegdement time stamp.
        */
        AcknowledgeAlarm(strGroupAndName: string | number): void;
        /**@function
        * Returns the specified alarm class object
        * @param name of the alarm class
        */
        GetAlarmClass(className: string): VisiWin.System.Alarm.IAlarmClass;
        /**@function
        * Returns the alarm group object specified by the alarm group identifier.
        * @param The groupTree parameter indicates the alarm group identifier. The identifier must indicate all superordinate alarm groups according to their hierarchy and the name of the alarm group itself, separated by dots.
        */
        GetAlarmGroup(groupTree: string): VisiWin.System.Alarm.IAlarmGroup;
        /**@function
        * Returns a CurrentAlarms object that contains all pending alarms.
        */
        GetCurrentAlarms(filter: VisiWin.System.Alarm.IAlarmFilter): VisiWin.System.Alarm.ICurrentAlarms;
        /**@function
        * Object for filtering alarms.
        */
        CreateAlarmFilter(): VisiWin.System.Alarm.IAlarmFilter;
        /**@function
        * Object for filtering historical alarms.
        */
        CreateHistoricalAlarmFilter(): VisiWin.System.Alarm.IHistoricalAlarmFilter;
        /**@function
        * Creates an object to query historical alarm data.
        * @param VisiWin.System.Alarm.IHistoricalAlarmFilter
        */
        CreateHistoricalAlarmRequest(filter: VisiWin.System.Alarm.IHistoricalAlarmFilter): VisiWin.System.Alarm.IHistoricalAlarms;
        /**@function
        * Acknowledges all pending alarms from an alarm class.
        * @param name of the alarm class
        */
        AcknowledgeAlarmClass(className: string): void;
        /**@function
        * Acknowledges all pending alarms of an alarm group.
        * @param name of the alarm group
        */
        AcknowledgeAlarmGroup(groupName: string): void;
        /**@function
        * Acknowledges all alarms currently pending in the system.
        */
        AcknowledgeAllAlarms(): void;
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
* @class
* @name VisiWin.System.Alarm.HistoricalAlarm.
* @description Collection of recorded alarm information
* @memberof VisiWin.System.Alarm
*/
    interface IHistoricalAlarms extends VisiWin.Internal.System.IBaseClass {
        /**
        * Returns all historical alarms.
        * @member { VisiWin.System.Alarm.IHistoricalAlarmItem[] } HistoricalAlarms
        */
        HistoricalAlarms: VisiWin.System.Alarm.IHistoricalAlarmItem[];
        /**
        * Determines the filter to be used for the alarms request.
        * @member {  VisiWin.System.Alarm.IHistoricalAlarmFilter } Filter
        */
        Filter: VisiWin.System.Alarm.IHistoricalAlarmFilter;
        /**
        * @function
        * Retrieves historical alarms.
        * @returns { Promise<VisiWin.System.Alarm.IGetHistoricalDataAsyncEventArgs> }
        */
        GetHistoricalDataAsync(): Promise<VisiWin.System.Alarm.IGetHistoricalDataAsyncEventArgs>;
        /**
        * Is triggered when an asynchronous query for alarm information is completed.
        * @event {  VisiWin.System.Alarm.IGetHistoricalDataCompletedEventArgs } GetHistoricalDataCompleted
        */
        GetHistoricalDataCompleted: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IGetHistoricalAlarmsCompletedEventArgs>;
        /**
        * Returns the unique ID of a historical alarms request.
        * @member { VisiWin.IGuid } RequestID
        */
        RequestID: VisiWin.IGuid;
        /**
        * Returns the current position of a historical alarm in the data stream.
        * @member { number } Position
        */
        Position: number;
        /**
        * Returns the lenght of the data stream.
        * @member { number } Length
        */
        Length: number;
        /**
        * Returns the number of alarms returned by the alarms request.
        * @member { number } Count
        */
        Count: number;
        /**
        * Provides additional information on the result.
        * @member { string } Result
        */
        Result: string;
        /**
        * @function
        * GetHistoricalAlarmsStream
        * @description Initializes the historical data stream.
        * @returns {   Promise<VisiWin.System.Alarm.IHistoricalAlarms> }
        */
        GetHistoricalAlarmsStream(): Promise<VisiWin.System.Alarm.IHistoricalAlarms>;
        /**
        * @function
        * ReadHistoricalAlarmsStream
        * @description Starts reading a historical alarms data steam.
        * @param { number }  position The current position inside the data stream.
        * @param { number }  count The number of objects to retrieve.
        * @returns {  Promise<VisiWin.System.Alarm.IHistoricalAlarms> }
        */
        ReadHistoricalAlarmsStream(position: number, count: number): Promise<VisiWin.System.Alarm.IHistoricalAlarms>;
        /**
        * @function
        * CloseHistoricalAlarmsStream
        * @descriptionThe method call is required at the end of each streaming session. Otherwise the memory consumption may increase over time.
        */
        CloseHistoricalAlarmsStream(): void;
    }
    /**
    *  GetHistoricalDataCompleted Event Arguments
    */
    interface IGetHistoricalAlarmsCompletedEventArgs {
        /**
        *  Array of HistoricalAlarmItems
        */
        HistoricalAlarms: VisiWin.System.Alarm.IHistoricalAlarmItem[];
        /**
        *  Request processed successfully
        */
        Success: boolean;
    }
    /**
    *  GetHistoricalDataAsync Event Arguments
    */
    interface IGetHistoricalDataAsyncEventArgs {
        ResultString: string;
        Result: string;
        Authorized: boolean;
    }
}
declare namespace VisiWin.System.Alarm {
    /**
    * Returns information referring to an alarm.
    */
    interface IAlarmItem extends VisiWin.System.Alarm.IAlarmItemBase {
        /**
        * Shows the unique identification of the alarm.
        */
        ID: number;
        /**
        * @description Is triggered when an alarm from the 'Alarms' property collection changes state.
        * AlarmStateChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
        * @member { Event } AlarmStateChanged
        */
        AlarmStateChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
    }
    /**
    * Base class for currently active or server-recorded alarms
    */
    interface IAlarmItemBase extends VisiWin.Internal.System.IBaseClass {
        /**
        * Returns the time when the alarm was acknowledged.
        * @member { Date } AcknowledgeTime
        */
        AcknowledgeTime: Date;
        /**
        * Returns how often an alarm has assumed the reactivated status since it was triggered.
        * @member { number } ActivationCounter
        */
        ActivationCounter: number;
        /**
        * Returns the time when the alarm was activated.
        * @member { Date } ActivationTime
        */
        ActivationTime: Date;
        /**
        * Returns the alarm state.
        * @member { VisiWin.System.Alarm.AlarmState } AlarmState
        */
        AlarmState: VisiWin.System.Alarm.AlarmState;
        /**
        * Returns the alarm class to which the alarm belongs.
        * @member { VisiWin.System.Alarm.IAlarmClass } Class
        */
        Class: VisiWin.System.Alarm.IAlarmClass;
        /**
        * Returns the time when the alarm was deactivated.
        * @member { Date } DeactivationTime
        */
        DeactivationTime: Date;
        /**
        * Returns the alarm group to which the alarm belongs.
        * @member { VisiWin.System.Alarm.IAlarmGroup } Group
        */
        Group: VisiWin.System.Alarm.IAlarmGroup;
        /**
        * Returns the value of the alphanumeric Parameter1 parameter.
        * @member { string } LocalizableParam1
        */
        LocalizableParam1: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Returns the machine name.
        * @member { string } Machine
        */
        Machine: string;
        /**
        * Returns the alarm name.
        * @member { string } Name
        */
        Name: string;
        /**
        * Returns the value of the alphanumeric Parameter1 parameter.
        * @member { string } Param1
        */
        Param1: string;
        /**
        * Returns the value of the numeric Parameter2 parameter.
        * @member { number } Param2
        */
        Param2: number;
        /**
        * Returns the alarm priority.
        * @member { number } Priority
        */
        Priority: number;
        /**
        * Returns information about the display parameters of the alarm class for the current alarm state.
        * @member { VisiWin.System.Alarm.IAlarmStateInfo } StateInfo
        */
        StateInfo: VisiWin.System.Alarm.IAlarmStateInfo;
        /**
        * Tag
        */
        Tag: object;
        /**
        * Returns the alarm text in the currently set language.
        * @member { string } Text
        */
        Text: string;
        /**
        * Returns the user name with which the alarm was acknowledged.
        */
        User: string;
    }
    /**
    *  Returns information referring to an historical alarm.
    */
    interface IHistoricalAlarmItem extends VisiWin.System.Alarm.IAlarmItemBase {
        /**
        * Shows the unequivocal identification of the alarm from the file.
        */
        HistoricalID: string;
        /**
        * Returns the name of the file in which the note is recorded.
        */
        FileName: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.AlarmFilter
    * @description Object for filtering alarms.
    * @memberof VisiWin.System.Alarm
    */
    interface IAlarmFilter extends VisiWin.Internal.System.IBaseClass {
        /**
        * Returns a collection of alarm classes to be displayed.
        * @member { string[] } DesiredClasses
        */
        DesiredClasses: string[];
        /**
        * Returns a collection of alarm groups to be displayed.
        * @member { string[] } DesiredGroups
        */
        DesiredGroups: string[];
        /**
        * Returns a collection of alarm states to be displayed.
        * @member { string[] } DesiredStates
        */
        DesiredStates: VisiWin.System.Alarm.AlarmState[];
        /**
        * Returns the maximum priority for the alarms to be displayed.
        * @member { number } MaxPriority
        */
        MaxPriority: number;
        /**
        * Returns the minimum priority for the alarms to be displayed.
        * @member { number } MinPriority
        */
        MinPriority: number;
    }
    /**
    * Object for filtering historical alarms.
    */
    interface IHistoricalAlarmFilter extends VisiWin.System.Alarm.IAlarmFilter {
        /**
        *Determines a user name.
        */
        User: string;
        /**
        * Sets the final point of the time filter.
        */
        MaxTime: Date;
        /**
        * Sets the starting point of the time filter.
        */
        MinTime: Date;
        UtcOffset: number;
    }
}
declare namespace VisiWin.System.Alarm {
    /**
    *   Class for querying alarm group information.
    */
    interface IAlarmGroup extends VisiWin.Internal.System.IBaseClass {
        /**
        *  Returns the complete identifier of the alarm group.
        */
        GroupTree: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        *  Returns the alarm group name.
        */
        Name: string;
        /**
        * Returns an array of subordinate alarm groups.
        */
        SubGroupNames: string[];
        /**
        * Returns the localizable alarm group name.
        */
        Text: string;
    }
}
declare namespace VisiWin.System.Alarm {
    /**
    * Class for monitoring alarm class information of an alarm.
    */
    interface IAlarmClass extends VisiWin.Internal.System.IBaseClass {
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        *  Returns the alarm class name.
        */
        Name: string;
        /**
        * Returns the localizable text for the alarm class in the active project language.
        */
        Text: string;
    }
}
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.CurrentAlarms
    * @description Class for monitoring alarm class information of an alarm.
    * @memberof VisiWin.System.Alarm
    */
    interface ICurrentAlarms extends VisiWin.Internal.System.IBaseClass {
        /**
        * Returns  all present alarms.
        * @member { VisiWin.System.Alarm.IAlarmItem[] } Alarms
        */
        Alarms: VisiWin.System.Alarm.IAlarmItem[];
        /**
        * Filters the alarm information by alarm classes, groups, status and priority.
        * @member { VisiWin.System.Alarm.IAlarmFilter } Filter
        */
        Filter: VisiWin.System.Alarm.IAlarmFilter;
        /**
        * Determines how alarms are sorted within the alarms collection.
        * @member { VisiWin.System.Alarm.AlarmSortMode } SortMode
        */
        SortMode: VisiWin.System.Alarm.AlarmSortMode;
        /**
        * Is triggered when an alarm from the Alarms property collection changes its state.
        * @event  VisiWin.System.Alarm.CurrentAlarms.ChangeAlarm
        * @param { VisiWin.System.Alarm.IAlarmItem } Object Information referring to an alarm.
        */
        ChangeAlarm: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
        /**
        * Is triggered when an alarm from the Alarms property collection is deleted.
        * @event  VisiWin.System.Alarm.CurrentAlarms.ClearAlarm
        * @param { VisiWin.System.Alarm.IAlarmItem } Object Information referring to an alarm.
        */
        ClearAlarm: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
        /**
        * Is triggered after the object has connected with the alarm server
        */
        InitAlarm: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
        /**
        * Is triggered when a new alarm is added to the Alarms property collection.
        * @event  VisiWin.System.Alarm.CurrentAlarms.NewAlarm
        *@param { VisiWin.System.Alarm.IAlarmItem } Object Information referring to an alarm.
        */
        NewAlarm: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
    }
}
declare namespace VisiWin.System.Alarm {
    /**
    *  Display information regarding the current alarm status
    */
    interface IAlarmStateInfo extends VisiWin.Internal.System.IBaseClass {
        /**
        *  Background colour for the alarm status
        */
        BackColor: string;
        /**
        *  Font colour for the alarm status
        */
        ForeColor: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Status text for the alarm status.
        */
        Text: string;
        Tag: object;
    }
}
declare namespace VisiWin.System.Alarm {
    /**
    * Returns an alarm deinition.
    */
    interface IAlarmDefinition {
        AcknowledgeMode: number;
        ClassDefinition: VisiWin.System.Alarm.IAlarmClassDefinition;
        ClassID: number;
        GroupDefinition: VisiWin.System.Alarm.IAlarmGroupDefinition;
        ID: number;
        /**
        * Returns the projected value of the alphanumeric "Parameter1" parameter.
        */
        LocalizableParam1: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        LowActive: boolean;
        /**
        * Returns the name of the alarm.
        */
        Name: string;
        /**
        * Returns the value of the alphanumeric 'Parameter1' parameter.
        */
        Parameter1: string;
        /**
        * Value of the numeric 'Parameter2' parameter.
        */
        Parameter2: number;
        Parameters: any;
        /**
        * Priority of the alarm.
        */
        Priority: number;
        Tag: object;
    }
}
declare namespace VisiWin.System.Alarm {
    /**
    * alarm class definition of an alarm.
    */
    interface IAlarmClassDefinition {
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        *  Returns the alarm class name.
        */
        Name: string;
    }
}
declare namespace VisiWin.System.Alarm {
    /**
    *   Class for querying alarm group definition.
    */
    interface IAlarmGroupDefinition {
        /**
        *  Returns the complete identifier of the alarm group.
        */
        GroupTree: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Returns the alarm group name.
        */
        Name: string;
        /**
        * Returns an array of subordinate alarm groups.
        */
        SubGroupNames: string[];
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * Contains the available alarm states.
    * @readonly
    * @enum {number} AlarmState
    */
    enum AlarmState {
        /**
        * Only allowed as a filter setting. When this value is set as a filter, all alarm states are returned in the query.
        */
        None = 0,
        /**
        * The alarm is in the Active state. The event bit is active. No acknowledgement was made.
        */
        Active = 1,
        /**
        * The alarm is in the Inactive state. The event bit is inactive. No acknowledgement was made when the alarm was active. A second acknowledgement is still expected.
        */
        Inactive = 2,
        /**
        * The alarm is in the Active Acklowledged state. The alarm was acknowledged by a client but the event bit is still active.
        */
        ActiveAck = 4,
        /**
        * The alarm is in the Inactive Acknowledged state. The event bit is inactive. An acknowledgement was made when the alarm was active. A second acknowledgement is still required.
        */
        InactiveAck = 8,
        /**
        * The alarm was finally cleared. The event bit is inactive. All necessary acknowledgements  were made.
        */
        Cleared = 16,
        /**
        * The alarm was reactivated.
        * If the event bit was set back by the PLC but the implemented acknowledge mode requires an acknowledgement by the user,
        * the Reactivated state will not disappear unless the alarm is acknowledged and the event bit reset.
        */
        Reactivated = 32
    }
    /**
    * Contains the available data types for the free parameters.
    * @readonly
    * @enum {number} ExtAlarmParamType
    */
    enum ExtAlarmParamType {
        /**
        * The free parameter has not been not found
        */
        None = 0,
        /**
        * The free parameter is returned as integer.
        */
        Long = 1,
        /**
        * The free parameter is returned as floating-point number.
        */
        Double = 2,
        /**
        * The free parameter is returned as string.
        */
        Text = 3,
        /**
        * The free parameter is returned as a field of bytes.
        */
        File = 4,
        /**
        * The free parameter is returned as an image object.
        */
        Image = 5
    }
    /**
    * Contains whether the alarm definition is expanded via an alarm type.
    * @readonly
    * @enum {number} AlarmType
    */
    enum AlarmType {
        /**
        * The alarm is activated by a process variable bit that is specified by the Bit Number parameter.
        */
        Bit = 0,
        /**
        * The alarm is activated by an error code(numerical value).
        */
        Numerical = 1,
        /**
        * The alarm is activated by a bit of the event variable.
        */
        BitBlock = 2
    }
    /**
    * Includes reset mode settings for the numerical alarm type.
    * @readonly
    * @enum {number} ResetMode
    */
    enum ResetMode {
        /**
        * By changing the event variable of possibly resulting alarm is reset.
        * It can be active only an alarm from the alarm type.
        */
        NewValueResetsOld = 0,
        /**
        * The value of the result variable must be negative in order to reset the alarm.
        */
        NegativeValueResets = 1,
        /**
        * If the event variable value is "0", all pending alarms of the alarm type are reset.
        */
        ZeroResetsAll = 2
    }
    /**
    * Includes settings that affect the combination of numerical information (priority, parameter2) in numerical alarms and bit block alarms.
    * @readonly
    * @enum {number} ParamMode
    */
    enum ParamMode {
        /**
        * The alarm definition parameter is returned.
        */
        AlarmOnly = 0,
        /**
        * The type definition parameter is returned.
        */
        TypeOnly = 1,
        /**
        * The parameter values of alarm and type definition are added.
        */
        AddAlarmAndType = 2
    }
    /**
    * Includes settings that affect the output of different textual information (alarm text, parameter1) in numerical alarm and bit block alarm.
    * @readonly
    * @enum {number} TextMode
    */
    enum TextMode {
        /**
        * The given alarm definition parameter is returned
        */
        Alarm = 0,
        /**
        * The given type definition parameter is returned
        */
        Type = 1
    }
    /**
    * Contains the available sorting sequences for current alarms.
    * @readonly
    * @enum {number} AlarmSortMode
    */
    enum AlarmSortMode {
        /**
        * For multiple alarms (as in an AlarmList): New alarms are added to the end of the list.
        * For the alarm with the highest priority (as in an AlarmLine):
        * Another alarm with the currently highest priority does not overwrite the current return/display value.
        */
        FirstUpFaultOnTop = 0,
        /**
        * For multiple alarms (as in an AlarmList): New alarms are added to the start of the list.
        * For the alarm with the highest priority (as in an AlarmLine):
        * Another alarm with the currently highest priority overwrites the current return/display value.
        */
        NewestFaultOnTop = 1
    }
    enum HistoricalAlarmColumns {
        Type = 0,
        FileName = 1,
        ClassName = 2,
        GroupFullName = 3,
        Name = 4,
        AcknowledgeMode = 5,
        Priority = 6,
        Timestamp = 7,
        User = 8,
        Machine = 9,
        State = 10,
        ActivationCount = 11,
        Text = 12,
        RowNum = 13
    }
    enum HistoricalFileColumns {
        FileName = 0,
        Start = 1,
        End = 2
    }
    enum HistoricalAlarmNotesColumns {
        StateId = 0,
        Timestamp = 1,
        User = 2,
        Machine = 3,
        Text = 4
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.AlarmClass
    * @description Class for monitoring alarm class information of an alarm.
    * @memberof VisiWin.System.Alarm
    */
    abstract class AlarmClass extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Alarm.IAlarmClass {
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Returns the alarm class name.
        * @member { string } Name
        */
        Name: string;
        /**
        * Returns the localizable text for the alarm class in the active project language.
        * @member { string } Text:
        */
        Text: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.AlarmGroup
    * @description Class for querying alarm group information.
    * @memberof VisiWin.System.Alarm
    */
    abstract class AlarmGroup extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Alarm.IAlarmGroup {
        /**
        * Returns the complete identifier of the alarm group.
        * @member { string } GroupTree
        */
        GroupTree: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Returns the localizable alarm group name.
        * @member { string } Name
        */
        Name: string;
        /**
        * Returns an array of subordinate alarm groups.
        * @member { string[] } SubGroupNames
        */
        SubGroupNames: string[];
        /**
        * Localizable name for alarm group.
        * @member { string } Text
        */
        Text: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.AlarmFilter
    * @description Object for filtering alarms.
    * @memberof VisiWin.System.Alarm
    */
    abstract class AlarmFilter extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Alarm.IAlarmFilter {
        /**
        * Returns a collection of alarm classes to be displayed.
        * @member { string[] } DesiredClasses
        */
        DesiredClasses: string[];
        /**
        * Returns a collection of alarm groups to be displayed.
        * @member { string[] } DesiredGroups
        */
        DesiredGroups: string[];
        /**
        * Returns a collection of alarm states to be displayed.
        * @member { string[] } DesiredStates
        */
        DesiredStates: VisiWin.System.Alarm.AlarmState[];
        /**
        * Returns the maximum priority for the alarms to be displayed.
        * @member { number } MaxPriority
        */
        MaxPriority: number;
        /**
        * Returns the minimum priority for the alarms to be displayed.
        * @member { number } MinPriority
        */
        MinPriority: number;
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.AlarmItem
    * @description Returns information referring to an alarm.
    * @memberof VisiWin.System.Alarm
    */
    abstract class AlarmItem extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Alarm.IAlarmItemBase {
        ID: string;
        /**
        * Returns the time when the alarm was acknowledged.
        * @member { Date } AcknowledgeTime
        */
        AcknowledgeTime: Date;
        /**
        * Returns how often an alarm has assumed the reactivated status since it was triggered.
        * @member { number } ActivationCounter
        */
        ActivationCounter: number;
        /**
        * Returns the time when the alarm was activated.
        * @member { Date } ActivationTime
        */
        ActivationTime: Date;
        /**
        * Returns the alarm state.
        * @member { VisiWin.System.Alarm.AlarmState } AlarmState
        */
        AlarmState: VisiWin.System.Alarm.AlarmState;
        /**
        * Returns the alarm class to which the alarm belongs.
        * @member { VisiWin.System.Alarm.IAlarmClass } Class
        */
        Class: VisiWin.System.Alarm.IAlarmClass;
        /**
        * Returns the time when the alarm was deactivated.
        * @member { Date } DeactivationTime
        */
        DeactivationTime: Date;
        /**
        * Returns the alarm group to which the alarm belongs.
        * @member { VisiWin.System.Alarm.IAlarmGroup } Group
        */
        Group: VisiWin.System.Alarm.IAlarmGroup;
        /**
        * Returns the value of the alphanumeric Parameter1 parameter.
        * @member { string } LocalizableParam1
        */
        LocalizableParam1: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Returns the machine name.
        * @member { string } Machine
        */
        Machine: string;
        /**
        * Returns the alarm name.
        * @member { string } Name
        */
        Name: string;
        /**
        * Returns the value of the alphanumeric Parameter1 parameter.
        * @member { string } Param1
        */
        Param1: string;
        /**
        * Returns the value of the numeric Parameter2 parameter.
        * @member { number } Param2
        */
        Param2: number;
        /**
        * Returns the alarm priority.
        * @member { number } Priority
        */
        Priority: number;
        /**
        * Returns information about the display parameters of the alarm class for the current alarm state.
        * @member { VisiWin.System.Alarm.IAlarmStateInfo } StateInfo
        */
        StateInfo: VisiWin.System.Alarm.IAlarmStateInfo;
        /**
        * Tag
        * @member { object } Tag
        */
        Tag: object;
        /**
        * Returns the alarm text in the currently set language.
        * @member { string } Text
        */
        Text: string;
        /**
        * Returns the user name with which the alarm was acknowledged.
        * @member { string } User
        */
        User: string;
        /**
        * @description Is triggered when an alarm from the 'Alarms' property collection changes state.
        * AlarmStateChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
        * @member { Event } AlarmStateChanged
        */
        AlarmStateChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
    }
}
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.CurrentAlarms
    * @description Class for monitoring alarm class information of an alarm.
    * @memberof VisiWin.System.Alarm
    */
    abstract class CurrentAlarms extends VisiWin.Internal.System.BaseClass implements ICurrentAlarms {
        /**
        * Returns  all present alarms.
        * @member { VisiWin.System.Alarm.IAlarmItem[] } Alarms
        */
        Alarms: VisiWin.System.Alarm.IAlarmItem[];
        /**
        * Filters the alarm information by alarm classes, groups, status and priority.
        * @member { VisiWin.System.Alarm.IAlarmFilter } Filter
        */
        Filter: VisiWin.System.Alarm.IAlarmFilter;
        /**
        * Determines how alarms are sorted within the alarms collection.
        * @member { VisiWin.System.Alarm.AlarmSortMode } SortMode
        */
        SortMode: VisiWin.System.Alarm.AlarmSortMode;
        /**
        * Is triggered when an alarm from the Alarms property collection changes its state.
        * @event  VisiWin.System.Alarm.CurrentAlarms.ChangeAlarm
        * @param { VisiWin.System.Alarm.IAlarmItem } Object Information referring to an alarm.
        */
        ChangeAlarm: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
        /**
        * Is triggered when an alarm from the Alarms property collection is deleted.
        * @event  VisiWin.System.Alarm.CurrentAlarms.ClearAlarm
        * @param { VisiWin.System.Alarm.IAlarmItem } Object Information referring to an alarm.
        */
        ClearAlarm: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
        /**
        * Is triggered when the object has connected to the alarm server.
        * @event  VisiWin.System.Alarm.CurrentAlarms.InitAlarm
        * @param { VisiWin.System.Alarm.IAlarmItem } Object Information referring to an alarm.
        */
        InitAlarm: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
        /**
        * Is triggered when a new alarm is added to the Alarms property collection.
        * @event  VisiWin.System.Alarm.CurrentAlarms.NewAlarm
        *@param { VisiWin.System.Alarm.IAlarmItem } Object Information referring to an alarm.
        */
        NewAlarm: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IAlarmItem>;
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.HistoricalAlarm.
    * @description Collection of recorded alarm information
    * @memberof VisiWin.System.Alarm
    */
    abstract class HistoricalAlarm extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Alarm.IHistoricalAlarms {
        /**
        * Returns all historical alarms.
        * @member { VisiWin.System.Alarm.IHistoricalAlarmItem[] } HistoricalAlarms
        */
        HistoricalAlarms: VisiWin.System.Alarm.IHistoricalAlarmItem[];
        /**
        * Determines the filter to be used for the alarms request.
        * @member {  VisiWin.System.Alarm.IHistoricalAlarmFilter } Filter
        */
        Filter: VisiWin.System.Alarm.IHistoricalAlarmFilter;
        /**
        * @function
        * Retrieves historical alarms.
        * @returns { Promise<VisiWin.System.Alarm.IGetHistoricalDataAsyncEventArgs> }
        */
        GetHistoricalDataAsync(): Promise<VisiWin.System.Alarm.IGetHistoricalDataAsyncEventArgs>;
        /**
        * Is triggered when an asynchronous query for alarm information is completed.
        * @event {  VisiWin.System.Alarm.IGetHistoricalDataCompletedEventArgs } GetHistoricalDataCompleted
        */
        GetHistoricalDataCompleted: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Alarm.IGetHistoricalAlarmsCompletedEventArgs>;
        /**
        * Returns the unique ID of a historical alarms request.
        * @member { VisiWin.IGuid } RequestID
        */
        RequestID: VisiWin.IGuid;
        /**
        * Returns the current position of a historical alarm in the data stream.
        * @member { number } Position
        */
        Position: number;
        /**
        * Returns the lenght of the data stream.
        * @member { number } Length
        */
        Length: number;
        /**
        * Returns the number of alarms returned by the alarms request.
        * @member { number } Count
        */
        Count: number;
        /**
        * Provides additional information on the result.
        * @member { string } Result
        */
        Result: string;
        /**
        * @function
        * GetHistoricalAlarmsStream
        * @description Initializes the historical data stream.
        * @returns {   Promise<VisiWin.System.Alarm.IHistoricalAlarms> }
        */
        GetHistoricalAlarmsStream(): Promise<VisiWin.System.Alarm.IHistoricalAlarms>;
        /**
        * @function
        * ReadHistoricalAlarmsStream
        * @description Starts reading a historical alarms data steam.
        * @param { number }  position The current position inside the data stream.
        * @param { number }  count The number of objects to retrieve.
        * @returns {  Promise<VisiWin.System.Alarm.IHistoricalAlarms> }
        */
        ReadHistoricalAlarmsStream(position: number, count: number): Promise<VisiWin.System.Alarm.IHistoricalAlarms>;
        /**
        * @function
        * CloseHistoricalAlarmsStream
        * @descriptionThe method call is required at the end of each streaming session. Otherwise the memory consumption may increase over time.
        */
        CloseHistoricalAlarmsStream(): void;
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.HistoricalAlarmFilter
    * @description Class describing the filter setting for querying recorded alarms.
    * @memberof VisiWin.System.Alarm
    */
    abstract class HistoricalAlarmFilter extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Alarm.IHistoricalAlarmFilter {
        /**
        * Determines a user name.
        * @member { string }
        */
        User: string;
        /**
        * Sets the final point of the time filter.
        * @member { Date } MaxTime
        */
        MaxTime: Date;
        /**
        * Sets the starting point of the time filter.
        * @member { Date } MinTime
        */
        MinTime: Date;
        /**
        * Returns a collection of alarm classes to be displayed.
        * @member { string[] } DesiredClasses
        */
        DesiredClasses: string[];
        /**
        * Returns a collection of alarm groups to be displayed.
        * @member { string[] } DesiredGroups
        */
        DesiredGroups: string[];
        /**
        * Returns a collection of alarm states to be displayed.
        * @member { string[] } DesiredStates
        */
        DesiredStates: VisiWin.System.Alarm.AlarmState[];
        /**
        * Returns the maximum priority for the alarms to be displayed.
        * @member { number } MaxPriority
        */
        MaxPriority: number;
        /**
        * Returns the minimum priority for the alarms to be displayed.
        * @member { number } MinPriority
        */
        MinPriority: number;
        UtcOffset: number;
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.HistoricalAlarmItem
    * @description Returns information relating to a recorded alarm.
    * @memberof VisiWin.System.Alarm
    */
    abstract class HistoricalAlarmItem extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Alarm.IAlarmItemBase {
        /**
        * Shows the unequivocal identification of the alarm from the file.
        * @member { string } HistoricalID
        */
        HistoricalID: string;
        /**
        * Returns the name of the file in which the note is recorded.
        * @member { string } FileName
        */
        FileName: string;
        /**
        * Returns the time when the alarm was acknowledged.
        * @member { Date } AcknowledgeTime
        */
        AcknowledgeTime: Date;
        /**
        * Returns how often an alarm has assumed the reactivated status since it was triggered.
        * @member { number } ActivationCounter
        */
        ActivationCounter: number;
        /**
        * Returns the time when the alarm was activated.
        * @member { Date } ActivationTime
        */
        ActivationTime: Date;
        /**
        * Returns the alarm state.
        * @member { VisiWin.System.Alarm.AlarmState } AlarmState
        */
        AlarmState: VisiWin.System.Alarm.AlarmState;
        /**
        * Information on the linked alarm class
        * @member { VisiWin.System.Alarm.IAlarmClass } Class
        */
        Class: VisiWin.System.Alarm.IAlarmClass;
        /**
        * Returns the time when the alarm was deactivated.
        * @member { Date } DeactivationTime
        */
        DeactivationTime: Date;
        /**
        * Returns the alarm group to which the alarm belongs.
        * @member { VisiWin.System.Alarm.IAlarmGroup } Group
        */
        Group: VisiWin.System.Alarm.IAlarmGroup;
        /**
        * Returns the value of the alphanumeric Parameter1 parameter.
        * @member { string } LocalizableParam1
        */
        LocalizableParam1: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Returns the machine name.
        * @member { string } Machine
        */
        Machine: string;
        /**
        * Returns the alarm name.
        * @member { string } Name
        */
        Name: string;
        /**
        * Returns the value of the alphanumeric Parameter1 parameter.
        * @member { string } Param1
        */
        Param1: string;
        /**
        * Returns the value of the numeric Parameter2 parameter.
        * @member { number } Param2
        */
        Param2: number;
        /**
        * Returns the alarm priority.
        * @member { number } Priority
        */
        Priority: number;
        /**
        * Returns information about the display parameters of the alarm class for the current alarm state.
        * @member { VisiWin.System.Alarm.IAlarmStateInfo } StateInfo
        */
        StateInfo: VisiWin.System.Alarm.IAlarmStateInfo;
        /**
        * Tag
        * @member { object } Tag
        */
        Tag: object;
        /**
        * Returns the alarm text in the currently set language.
        * @member { string } Text
        */
        Text: string;
        /**
        * Returns the user name with which the alarm was acknowledged.
        * @member { string } User
        */
        User: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Alarm
*/
declare namespace VisiWin.System.Alarm {
    /**
    * @class
    * @name VisiWin.System.Alarm.AlarmService
    * @description Class for monitoring alarm class information of an alarm.
    * @memberof VisiWin.System.Alarm
    */
    abstract class AlarmService extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Alarm.IAlarmService {
        static getService(): AlarmService;
        /**
        * Returns the names of all alarm groups.
        * @member { string[] }
        */
        GroupNames: string[];
        /**
        * Returns the names of all alarm classes.
        * @member { string[] }
        */
        ClassNames: string[];
        /**
        * Collects and monitors all currently active alarms.
        * @member { VisiWin.System.Alarm.ICurrentAlarms }
        */
        CurrentAlarms: VisiWin.System.Alarm.ICurrentAlarms;
        /**@function
        * Acknowledges an alarm. The system time is used as acknowlegdement time stamp.
        */
        AcknowledgeAlarm(strGroupAndName: string | number): void;
        /**@function
        * Returns the specified alarm class object
        * @param name of the alarm class
        */
        GetAlarmClass(className: string): VisiWin.System.Alarm.IAlarmClass;
        /**@function
        * Returns the alarm group object specified by the alarm group identifier.
        * @param The groupTree parameter indicates the alarm group identifier. The identifier must indicate all superordinate alarm groups according to their hierarchy and the name of the alarm group itself, separated by dots.
        */
        GetAlarmGroup(groupTree: string): VisiWin.System.Alarm.IAlarmGroup;
        /**@function
        * Returns a CurrentAlarms object that contains all pending alarms.
        */
        GetCurrentAlarms(filter: VisiWin.System.Alarm.IAlarmFilter): VisiWin.System.Alarm.ICurrentAlarms;
        /**@function
        * Object for filtering alarms.
        */
        CreateAlarmFilter(): VisiWin.System.Alarm.IAlarmFilter;
        /**@function
        * Object for filtering historical alarms.
        */
        CreateHistoricalAlarmFilter(): VisiWin.System.Alarm.IHistoricalAlarmFilter;
        /**@function
        * Creates an object to query historical alarm data.
        * @param VisiWin.System.Alarm.IHistoricalAlarmFilter
        */
        CreateHistoricalAlarmRequest(filter: VisiWin.System.Alarm.IHistoricalAlarmFilter): VisiWin.System.Alarm.IHistoricalAlarms;
        /**@function
        * Acknowledges all pending alarms from an alarm class.
        * @param name of the alarm class
        */
        AcknowledgeAlarmClass(className: string): void;
        /**@function
        * Acknowledges all pending alarms of an alarm group.
        * @param name of the alarm group
        */
        AcknowledgeAlarmGroup(groupName: string): void;
        /**@function
        * Acknowledges all alarms currently pending in the system.
        */
        AcknowledgeAllAlarms(): void;
    }
}
/**
*
<section class="tsd-panel-group tsd-index-group">
    <h4>Additional Information</h4>
    <section class="tsd-panel tsd-index-panel">
        <div class="tsd-index-content">
            <section class="tsd-index-section ">
             <h4>Examples</h4>
                <ul class="tsd-index-list">
                    <li><a href="../tutorials/DataAccess/IVariableService.html" class="tsd-kind-icon">IVariableService</a></span></li>
                </ul>
                <ul class="tsd-index-list">
                    <li><a href="../tutorials/DataAccess/IVariable.html" class="tsd-kind-icon">IVariable</a></span></li>
                    <li><a href="../tutorials/DataAccess/GetValueAsync.html" class="tsd-kind-icon">GetValueAsync</a></span></li>
                    <li><a href="../tutorials/DataAccess/GetValueAsyncArray.html" class="tsd-kind-icon">GetValueAsyncArray</a></span></li>
                    <li><a href="../tutorials/DataAccess/GetValueAsyncStruct.html" class="tsd-kind-icon">GetValueAsyncStruct</a></span></li>
                </ul>
                <ul class="tsd-index-list">
                    <li><a href="../tutorials/DataAccess/IQuality.html" class="tsd-kind-icon">IQuality</a></span></li>
                    <li><a href="../tutorials/DataAccess/IUnitClass.html" class="tsd-kind-icon">IUnitClass</a></span></li>
                </ul>
            </section>
        </div>
    </section>
</section>

*/
declare namespace VisiWin.System.DataAccess { }
declare namespace VisiWin.System.DataAccess {
    /**
    * @class
    * @name VisiWin.System.DataAccess.Variable
    * @description Object for accessing a process variable from the process databank.
    * @memberof VisiWin.System.DataAccess
    */
    interface IVariableBase extends VisiWin.Internal.System.IBaseClass {
        /**
        * Is triggered when the variable changes.
        * @event  VisiWin.System.DataAccess.Variable
        * @param { ChangeEventArgs } VisiWin.System.DataAccess.IVariableChangeEventArgs
        */
        Change: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.DataAccess.IVariableChangeEventArgs>;
        /**
        * @ignore
        */
        RecipeItemChange?: VisiWin.Internal.System.Events.IEventArgs<any>;
        /**
        * Returns the point shifting calculated from 'DecPoint' and 'UnitConversion'.
        * @member { number }  CalculatedDecPoint
        */
        CalculatedDecPoint: number;
        /**
        * Determines whether the variable value can be edited using this control in the recipe buffer.
        * @member { boolean }  CanRecipeEdit
        */
        CanRecipeEdit: boolean;
        /**
        * Determines the value for the "Comment" definition parameter.
        * @member { string }  Comment
        */
        Comment: string;
        /**
        * Decimal adjustment with whole-numbered values or specification of decimal places with floating point figures.
        * @member { number }  DecPoint
        */
        DecPoint: number;
        /**
        * Establishes whether the object is currently administering a valid process variable registration.
        * @member { boolean }  IsAttached
        */
        IsAttached: boolean;
        /**
        * Returns whether the specified variable is in the editing mode.
        * @member { string }  IsEditing
        */
        IsEditing: boolean;
        /**
        * Returns whether the variable represents a numeric data type.
        * @member { boolean }  IsNumeric
        */
        IsNumeric: boolean;
        /**
        * Returns whether the quality information to the transmitted value indicates a trouble-free data exchange.
        * @member { boolean }  IsQualityGood
        */
        IsQualityGood: boolean;
        /**
        * Returns whether the value of the variable is currently based on the recipe buffer.
        * @member { boolean }  IsRecipeEditing
        */
        IsRecipeEditing: boolean;
        /**
        * Returns whether the specified variable was found in the variable kernel.
        * @member { boolean }  IsValid
        */
        IsValid: boolean;
        /**
        * Name of the process variable from the project databank
        * @member { string }  Name
        */
        Name: string;
        /**
        * Returns the value of the "maximum value" from the variable definition (without unit conversion).
        * @member { VisiWin.System.DataAccess.VariantType }  RawMaxValue
        */
        RawMaxValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Returns the value of the "minimum value" from the variable definition (without unit conversion).
        * @member { VisiWin.System.DataAccess.VariantType }  RawMinValue
        */
        RawMinValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Specifies the new variable value (without unit conversion).
        * @member { VisiWin.System.DataAccess.VariantType }  RawValue
        */
        RawValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Allows the user caching of any object.
        * @member { object }  Tag
        */
        Tag: object;
        /**
        * Returns the localizable text on the variable.
        * @member { any }  Text
        */
        Text: string;
        /**
        * Returns the value of the "Unit text" parameter.
        * @member { string }  UnitText
        */
        UnitText: string;
        /**
        * Determines whether the properties Value/MinValue/MaxValue associated with a device class (display) to be converted.
        * @member { boolean }  UseUnitConversion
        */
        UseUnitConversion: boolean;
        /**
        * Returns the old value (without unit conversion) before the change of the variable value.
        * @member { VisiWin.System.DataAccess.VariantType }  PreviousRawValue
        */
        PreviousRawValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Returns the old value (with unit conversion) before the change of the variable value.
        * @member { VisiWin.System.DataAccess.VariantType }  PreviousValue
        */
        PreviousValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Returns whether the linked variable is to be obtained through the recipe cache of the variable
        * @member { boolean }  RecipeMode
        */
        RecipeMode: boolean;
        /**
        * Registers the object with the process variable core
        */
        AttachAsync(): Promise<boolean>;
        /**
        * unregisters the object with the process variable core
        */
        Detach(): void;
        /**
        * Value from the variable core.
        * @member { VisiWin.System.DataAccess.VariantType }  Value
        */
        Value: VisiWin.System.DataAccess.VariantType;
        /**
        * Value of the 'Maximum' parameter from the project databank.
        * @member { VisiWin.System.DataAccess.VariantType }  MaxValue
        */
        MaxValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Value of the 'Minimum' parameter from the project databank.
        * @member { VisiWin.System.DataAccess.VariantType }  MinValue
        */
        MinValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Evaluating information from the variable core.
        * @member { VisiWin.System.DataAccess.IQuality }  Quality
        */
        Quality: VisiWin.System.DataAccess.IQuality;
        /**
        * Returns the raw data type of the associated variables.
        * @member { VisiWin.System.DataAccess.TypeCode }  RawTypeCode
        */
        RawTypeCode: VisiWin.System.DataAccess.TypeCode;
        /**
        * Time stamp of the last transmitted value.
        * @member { Date }  TimeStamp
        */
        TimeStamp: Date;
        /**
        * Returns the data type of the sssociated variables.
        * @member { VisiWin.System.DataAccess.TypeCode }  TypeCode
        */
        TypeCode: VisiWin.System.DataAccess.TypeCode;
        /**
        * Returns the unit class specified in the variable definition.
        * @member { VisiWin.System.DataAccess.IUnitClass }  UnitClass
        */
        UnitClass: VisiWin.System.DataAccess.IUnitClass;
        /**
        * Returns a detailed reason for the value change
        * @member { VisiWin.System.DataAccess.ChangeSource }  Source
        */
        Source: VisiWin.System.DataAccess.ChangeSource;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Returns the name of the max value variable, if available.
        * @description This variable name is required for the UI, to implement a limit check, when the limits came from variables.
        * @description MaxValue,MinValue,RawMaxValue,RawMinValue are not available in IVariable, if a variable dependent limit value is set.
        * available with WebGatewayProtocolVersion == 3 (2019.2)
        */
        MaxValueVariableName?: string;
        /**
        * Returns the name of the min value variable, if available.
        * @description This variable name is required for the UI, to implement a limit check, when the limits came from variables.
        * @description MaxValue,MinValue,RawMaxValue,RawMinValue are not available in IVariable, if a variable dependent limit value is set.
        * available with WebGatewayProtocolVersion == 3 (2019.2)
        */
        MinValueVariableName?: string;
        /**
        *@description Contains the settings for the "Access type" parameter from the project database
        * @member { VisiWin.System.DataAccess.AccessRight } AccessRight
        */
        AccessRight?: VisiWin.System.DataAccess.AccessRight;
        /**
        *@description Returns the "field size" of the variable.
        *
        *@version Rumtime version 7.2 only!
        *@deprecated With runtime version 7.3, please use FieldSizes.
        *
        * @member { number[] } FieldSize
        */
        FieldSize?: number[];
        /**
        *@description Returns the "field sizes" of the variable.
        *
        *
        *@version Rumtime version 7.3 only!
        *
        * @member { number[] } FieldSizes
        */
        FieldSizes?: number[];
        /**
        *@description Returns the "field offset" of the variable.
        *
        *@version Rumtime version 7.2 only!
        *@deprecated With runtime version 7.3, please use FieldOffsets.
        *
        * @member {number[]} FieldOffset
        */
        FieldOffset?: number[];
        /**
        *@description Returns the "field offsets" of the variable.
        *
        *@version Rumtime version 7.3 only!
        *
        * @member {number[]} FieldOffsets
        */
        FieldOffsets?: number[];
    }
    interface IVariable extends VisiWin.System.DataAccess.IVariableBase {
        AttachAsync(): Promise<boolean>;
        Detach(): void;
        SetValueMember?(val: VisiWin.System.DataAccess.VariantType): void;
    }
    interface IVariableChangeEventArgs {
        /**
        * Value from the variable core.
        */
        Value: VisiWin.System.DataAccess.VariantType;
        /**
        * Name of the process variable from the project databank.
        */
        Name: string;
        /**
        * Returns the old value (without unit conversion) before the change of the variable value.
        */
        PreviousRawValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Returns the old value (with unit conversion) before the change of the variable value.
        */
        PreviousValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Returns whether the linked variable is to be obtained through the recipe cache of the variable
        */
        RecipeMode: boolean;
        /**
        * Returns a detailed reason for the value change
        */
        Source: VisiWin.System.DataAccess.ChangeSource;
        /**
        * Evaluating information from the variable core.
        */
        Quality: VisiWin.System.DataAccess.IQuality;
        /**
        * Specifies the new variable value (without unit conversion).
        */
        RawValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Time stamp of the last transmitted value.
        */
        TimeStamp: Date;
    }
}
declare namespace VisiWin.System.DataAccess {
    /**
    * @class VisiWin.System.DataAccess.VariableService
    * @description Entry point into the process connection.
    * @memberof VisiWin.System.DataAccess
    */
    interface IVariableService extends VisiWin.Internal.System.IBaseClass {
        /**
        * @function GetValueAsync
        * @description Reads the value of the variable.
        * @param {string} variableName The alias of the variable.
        * @returns {Promise<VisiWin.System.DataAccess.VariantType>} The value of the variable.
        */
        GetValueAsync(variableName: string): Promise<VisiWin.System.DataAccess.VariantType>;
        /**
        * @function GetValueAsync
        * @description Reads the value of the variable.
        * @param {string} variableName The alias of the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.IGetValueResult>} the extended result of the operation
        */
        GetValueAsync(variableName: string, resultDetails: boolean): Promise<VisiWin.System.DataAccess.IGetValueResult>;
        /**@function GetValuesAsync
        * @description Reads the values of variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @returns {Promise<VisiWin.System.DataAccess.VariantType[]>} The values of the variables.
        */
        GetValuesAsync(variableNames: string[]): Promise<VisiWin.System.DataAccess.VariantType[]>;
        /**@function GetValuesAsync
        * @description Reads the values of variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.IGetValueResult[]>} The extended result of the operation.
        */
        GetValuesAsync(variableNames: string[], resultDetails: boolean): Promise<VisiWin.System.DataAccess.IGetValueResult[]>;
        /**@function GetRawValueAsync
        * @description Reads the raw value of the variable.
        * @param {string} variableName The alias of the variable.
        * @returns {Promise<VisiWin.System.DataAccess.VariantType[]>} The value of the variable.
        */
        GetRawValueAsync(variableName: string): Promise<VisiWin.System.DataAccess.VariantType>;
        /**@function GetRawValueAsync
        * @description Reads the values of variables.
        * @param {string} variableName The alias of the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.IGetValueResult>} the extended result of the operation
        */
        GetRawValueAsync(variableName: string, resultDetails: boolean): Promise<VisiWin.System.DataAccess.IGetValueResult>;
        /**@function GetRawValuesAsync
        * @description Reads the raw values of the variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @returns {Promise<VisiWin.System.DataAccess.VariantType[]>} The values of the variables.
        */
        GetRawValuesAsync(variableNames: string[]): Promise<VisiWin.System.DataAccess.VariantType[]>;
        /**@function GetRawValuesAsync
        * @description Reads the values of variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.IGetValueResult[]>} the extended result of the operation
        */
        GetRawValuesAsync(variableNames: string[], resultDetails: boolean): Promise<VisiWin.System.DataAccess.IGetValueResult[]>;
        /**@function SetValueAsync
        * @description Writes the value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {VisiWin.System.DataAccess.VariantType} newValue The value for the variable.
        * @returns {Promise<boolean>} Determines whether the operation was successful.
        */
        SetValueAsync(variableName: string, newValue: VisiWin.System.DataAccess.VariantType): Promise<boolean>;
        /**@function SetValueAsync
        * @description Writes the value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {VisiWin.System.DataAccess.VariantType} newValue The value for the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetValueResult>} The extended result of the operation
        */
        SetValueAsync(variableName: string, newValue: VisiWin.System.DataAccess.VariantType, resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetValueResult>;
        /**@function SetValuesAsync
        * @description Writes the values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {VisiWin.System.DataAccess.VariantType[]} newValues The values for the variables.
        * @returns {Promise<boolean[]>} Determines whether the operation was successful.
        */
        SetValuesAsync(variableNames: string[], newValues: VisiWin.System.DataAccess.VariantType[]): Promise<boolean[]>;
        /**@function SetValuesAsync
        * @description Writes the values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {VisiWin.System.DataAccess.VariantType[]} newValues The values for the variables.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetValueResult[]>} The extended result of the operation
        */
        SetValuesAsync(variableNames: string[], newValues: VisiWin.System.DataAccess.VariantType[], resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetValueResult[]>;
        /**@function SetRawValueAsync
        * @description Writes the raw value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {VisiWin.System.DataAccess.VariantType} newValue The raw value for the variable.
        * @returns {Promise<boolean>} Determines whether the operation was successful.
        */
        SetRawValueAsync(variableName: string, newValue: VisiWin.System.DataAccess.VariantType): Promise<boolean>;
        /**@function SetRawValueAsync
        * @description Writes the valuespassed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {VisiWin.System.DataAccess.VariantType} newValue The raw value for the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetValueResult>} The extended result of the operation
        */
        SetRawValueAsync(variableName: string, newValue: VisiWin.System.DataAccess.VariantType, resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetValueResult>;
        /**@function SetRawValuesAsync
        * @description Writes the raw values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {VisiWin.System.DataAccess.VariantType[]} newValues The raw values for the variables.
        * @returns {Promise<boolean[]>} Determines whether the operation was successful.
        */
        SetRawValuesAsync(variableNames: string[], newValues: VisiWin.System.DataAccess.VariantType[]): Promise<boolean[]>;
        /**@function SetRawValuesAsync
        * @description Writes the values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {VisiWin.System.DataAccess.VariantType[]} newValues The raw values for the variables.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetValueResult[]>} The extended result of the operation
        */
        SetRawValuesAsync(variableNames: string[], newValues: VisiWin.System.DataAccess.VariantType[], resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetValueResult[]>;
        /**@function SetBitAsync
        * @description Writes the value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {number} bitNumber The bit number for the variable.
        * @param {boolean} The bit value for the variable.
        * @returns {Promise<boolean>} Determines whether the operation was successful.
        */
        SetBitAsync(variableName: string, bitNumber: number, newValue: boolean): Promise<boolean>;
        /**@function SetBitAsync
        * @description Writes the value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {number} bitNumber The bit number for the variable.
        * @param {boolean} newValue The bit value for the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetBitResult>} The extended result of the operation
        */
        SetBitAsync(variableName: string, bitNumber: number, newValue: boolean, resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetBitResult>;
        /**@function SetBitsAsync
        * @description Writes the values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {number[]} bitNumbers The bit numbers for the variables.
        * @param {boolean[]} newValues The bit values for the variables.
        * @returns {Promise<boolean[]>} Determines whether the operation was successful.
        */
        SetBitsAsync(variableNames: string[], bitNumbers: number[], newValues: boolean[]): Promise<boolean[]>;
        /**@function SetBitsAsync
        * @description Writes the values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {number[]} bitNumbers The bit numbers for the variables.
        * @param {boolean[]} newValues The bit values for the variables.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetBitResult[]>} The extended result of the operation
        */
        SetBitsAsync(variableNames: string[], bitNumbers: number[], newValues: boolean[], resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetBitResult[]>;
        /**@function GetVariable
        * @description An empty IVariable object by variable name.
        * @param {string} variableName The alias of the variable.
        * @returns {VisiWin.System.DataAccess.IVariable}
        * @remarks Add Change handler before calling Variable.AttachAsync()
        */
        GetVariable(variableName: string): VisiWin.System.DataAccess.IVariable;
        /**@function GetUnitClassAsync
        * @description Returns a unit class object.
        * @param {string} unitClassName The name of the required UnitClass.
        * @returns {Promise<VisiWin.System.DataAccess.IUnitClass>}
        */
        GetUnitClassAsync(unitClassName: string): Promise<VisiWin.System.DataAccess.IUnitClass>;
        /**@function GetCurrentUnitAsync
        * @description  Returns the active unit object of the unit class.
        * @param {string} unitClassNam The name of the required UnitClass.
        * @returns {Promise<VisiWin.System.DataAccess.IUnit>}
        */
        GetCurrentUnitAsync(unitClassName: string): Promise<VisiWin.System.DataAccess.IUnit>;
    }
}
declare namespace VisiWin.System.DataAccess {
    /**
    * @class
    * @name VisiWin.System.DataAccess.UnitClass
    * @description Class for access to the unit conversion in a unit class currently used in the system.
    * @memberof VisiWin.System.DataAccess
    * @summary UnitClass is only available for attached variables.
    */
    interface IUnitClass extends VisiWin.Internal.System.IBaseClass {
        UnitClassType: VisiWin.System.DataAccess.UnitClassType;
        /**
        * A unit class currently used in the system.
        * @member { VisiWin.System.DataAccess.IUnit }  CurrentUnit
        */
        CurrentUnit: VisiWin.System.DataAccess.IUnit;
        /**
        *  Name of the unit class.
        * @member { string } Name
        */
        Name: string;
        /**
        * Is triggered when the information of the unit conversion was changed.
        * @member { Event } Change
        */
        Change: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.DataAccess.IUnit>;
    }
}
declare namespace VisiWin.System.DataAccess {
    /**
    * @class
    * @name VisiWin.System.DataAccess.Unit
    * @description Class for access to the unit conversion in a unit class currently used in the system.
    * @memberof VisiWin.System.DataAccess
    */
    interface IUnit extends VisiWin.Internal.System.IBaseClass {
        /**
        * Decimal adjustment with whole-numbered values or specification of decimal place with floating point figures.
        * @member { number }  DecPoint
        */
        DecPoint: number;
        /**
        * Value addend/offset.
        * @member { number }  Offset
        * Value addend/offset.
        * b= y2 - m * x2
        * m= (y2-y1)/(x2-x1)
        */
        Offset: number;
        /**
        * Value factor.
        * @member { number }  Slope
        */
        Slope: number;
        /**
        * Value of the "Unit text" definition parameter.
        * @member { string }  Text
        */
        Text: string;
        /**
        * Name of the unit.
        * @member { string }  Name
        */
        Name: string;
        /**
        * X coordinate of the first straight line base point.
        * @member { number }  X1
        */
        X1: number;
        /**
        * X coordinate of the second straight line point.
        * @member { number }  X2
        */
        X2: number;
        /**
        * Y coordinate of the first straight line point.
        * @member { number }  Y1
        */
        Y1: number;
        /**
        * Y coordinate of the first straight line point.
        * @member { number }  Y2
        */
        Y2: number;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
    }
}
declare namespace VisiWin.System.DataAccess {
    /**
    * @class
    * @name VisiWin.System.DataAccess.Quality
    * @description Structure for access to the status information of a process value.
    * @memberof VisiWin.System.DataAccess
    */
    interface IQuality extends VisiWin.Internal.System.IBaseClass {
        /**
        * Status information as to the transmitted process value.
        * @member { VisiWin.System.DataAccess.DataQuality }
        */
        Data: VisiWin.System.DataAccess.DataQuality;
        /**
        * Additional information as to the transmitted variable value relating to defined value area limitations.
        * @member { VisiWin.System.DataAccess.LimitQuality }
        */
        Limit: VisiWin.System.DataAccess.LimitQuality;
        /**
        * Returns whether in the transfer of practical value, an error occurred.
        * @member { boolean }  IsBad
        */
        IsBad: boolean;
        /**
        * Returns whether the transfer of the value of the PLC has expired for visualization without clear error.
        * @member { boolean }
        */
        IsGoodOrUncertain: boolean;
        /**
        * The 'Value' property returns a numerical value from which 'Data' and 'Limit' are deduced.
        * @member { number }
        */
        Value: number;
    }
}
declare namespace VisiWin.System.DataAccess {
    /**
    *  Capsules, the result for SetValue.
    */
    interface ISetValueResult {
        /**
        * Determines whether the set value request succeeded.
        */
        Success: boolean;
        /**
        * In case of error.
        * VisiWin.System.DataAccess.ISetVariableErrorCode
        */
        Errors: VisiWin.System.DataAccess.ISetVariableErrorCode;
        Quality: VisiWin.System.DataAccess.IQuality;
    }
    /**
    *  Capsules, the result for SetBit.
    */
    interface ISetBitResult {
        /**
        * Determines whether the set value request succeeded.
        */
        Success: boolean;
        /**
        * In case of error
        * VisiWin.System.DataAccess.ISetBitVariableErrorCode
        */
        Errors: VisiWin.System.DataAccess.ISetBitVariableErrorCode;
        Quality: VisiWin.System.DataAccess.IQuality;
    }
    /**
    *  The result of the variable setter operation.
    */
    interface ISetVariableErrorCode {
        /**
        *  Result: VisiWin.System.DataAccess.VariableValueErrorCode;
        */
        Result: VisiWin.System.DataAccess.VariableValueErrorCode;
        /**
        *  The name of the variable to be set.
        */
        VariableName: string;
        /**
        *  The value of the variable to be set.
        */
        Value: VisiWin.System.DataAccess.VariableValueErrorCode;
    }
    /**
    *  The result of the variable bit setter operation.
    */
    interface ISetBitVariableErrorCode extends ISetVariableErrorCode {
        /**
        *  The bit number of the variable to be set.
        */
        BitNumber: number;
    }
    /**
    *  Capsules, the result for GetValue.
    */
    interface IGetValueResult {
        /**
        * Determines whether the set value request succeeded.
        */
        Success: boolean;
        /**
        * In case of error
        * VisiWin.System.DataAccess.IGetVariableErrorCode
        */
        Errors: VisiWin.System.DataAccess.IGetVariableErrorCode;
        /**
        * Time stamp of the last transmitted value.
        */
        TimeStamp: Date;
        /**
        *  Variable value.
        */
        Value: VisiWin.System.DataAccess.VariantType;
    }
    /**
    *  The result of the variable getter operation.
    */
    interface IGetVariableErrorCode {
        /**
        *  Result: VisiWin.System.DataAccess.VariableValueErrorCode;
        */
        Result: VisiWin.System.DataAccess.VariableValueErrorCode;
        /**
        *  The name of the variable to be set.
        */
        VariableName: string;
        /**
        *  The value of the variable to be set.
        */
        Value: VisiWin.System.DataAccess.VariantType;
        /**
        * Structure for access to the status information of a process value.
        */
        Quality: VisiWin.System.DataAccess.IQuality;
        /**
        * Enumeration for the type code of a process variable.
        */
        TypeCode: VisiWin.System.DataAccess.TypeCode;
    }
}
/**
* @namespace
* @name VisiWin.System.DataAccess
*/
declare namespace VisiWin.System.DataAccess {
    enum UnitClassType {
        Display = 0,
        Process = 1
    }
    /**
    * Enumeration for the type code of a process variable.
    * public enum TypeCode
    * @enum TypeCode
    */
    enum TypeCode {
        /**
         *  A null reference.
         */
        Empty = 0,
        /**
         * A general type representing any reference or value type not explicitly represented by another TypeCode.
         */
        Object = 1,
        /**
         * A database null (column) value.
         */
        DBNull = 2,
        /**
         * A simple type representing Boolean values of true or false.
         */
        Boolean = 3,
        /**
         * An integral type representing unsigned 16-bit integers with values between
         * 0 and 65535. The set of possible values for the System.TypeCode.Char type
         * corresponds to the Unicode character set.
         */
        Char = 4,
        /**
         * An integral type representing signed 8-bit integers with values between -128 and 127.
         */
        SByte = 5,
        /**
         * An integral type representing unsigned 8-bit integers with values between 0 and 255.
         */
        Byte = 6,
        /**
         * An integral type representing signed 16-bit integers with values between -32768 and 32767.
         */
        Int16 = 7,
        /**
         * An integral type representing unsigned 16-bit integers with values between 0 and 65535.
         */
        UInt16 = 8,
        /**
         * An integral type representing signed 32-bit integers with values between -2147483648 and 2147483647.
         */
        Int32 = 9,
        /**
         *  An integral type representing unsigned 32-bit integers with values between  0 and 4294967295.
         */
        UInt32 = 10,
        /**
         *   An integral type representing signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.
         */
        Int64 = 11,
        /**
         *  An integral type representing unsigned 64-bit integers with values between 0 and 18446744073709551615.
         */
        UInt64 = 12,
        /**
         * A floating point type representing values ranging from approximately 1.5 x 10 -45 to 3.4 x 10 38 with a precision of 7 digits.
         */
        Single = 13,
        /**
         * A floating point type representing values ranging from approximately 5.0 x 10 -324 to 1.7 x 10 308 with a precision of 15-16 digits.
         */
        Double = 14,
        /**
         * A simple type representing values ranging from 1.0 x 10 -28 to approximately 7.9 x 10 28 with 28-29 significant digits.
         */
        Decimal = 15,
        /**
         * A type representing a date and time value.
         */
        DateTime = 16,
        /**
         * A sealed class type representing Unicode character strings.
         */
        String = 18
    }
    /**
    * Enumeration for the data type of a process variable.
    * public enum DataType
    * @enum DataType
    */
    enum DataType {
        VT_EMPTY = 0,
        VT_NULL = 1,
        VT_I2 = 2,
        VT_I4 = 3,
        VT_R4 = 4,
        VT_R8 = 5,
        VT_DATE = 7,
        VT_BSTR = 8,
        VT_BOOL = 11,
        VT_I1 = 16,
        VT_UI1 = 17,
        VT_UI2 = 18,
        VT_UI4 = 19,
        VT_INT = 22,
        VT_UINT = 23
    }
    /**
    * public enum LimitQuality
    * List that contains the boundaries assessed values of a process variable status (Quality).
    * @enum LimitQuality
    */
    enum LimitQuality {
        /**
        * The value has no boundaries or is between the specified limits.
        */
        Ok = 0,
        /**
        * The value has exceeded the upper limit.
        */
        Low = 1,
        /**
        * The value has exceeded the upper limit.
        */
        High = 2,
        /**
        * The value is a constant and can not be changed.
        */
        Const = 3
    }
    /**
    * public enum DataQuality
    * Enumeration for the OPC transmit status of a value.
    * @enum DataQuality
    */
    enum DataQuality {
        /**
        * Category "Bad"
        * The process value cannot be used. An unknown error has occurred.
        */
        Bad = 0,
        /**
        * Category "Bad"
        * The process value cannot be used. A problem with the configuration of the OPC server has occurred.
        * It is for example possible that the process variable was deleted from the configuration of the OPC server.
        */
        ConfigError = 4,
        /**
        * Category "Bad"
        * The value could not be read because the control is not supporting it,
        * caused e.g. by accessing an optional entry that is not existent in the current configuration.
        */
        NotConnected = 8,
        /**
        * Category "Bad"
        * The process value cannot be used. A device error has occurred.
        */
        DeviceFailure = 12,
        /**
        * Category "Bad"
        * An error has been diagnosed during the admission process of the value regarded as sensor value by the OPC server.
        * Specified information about the evaluation of a value my means of the defined limits is indicated in the 'Limit' property.
        */
        SensorFailure = 16,
        /**
        * Category "Uncertain"
        * A communication error has occurred. The process value could not be reread. There is, however, a former value that is passed here.
        * The time that value was read can be read in the time stamp.
        */
        LastKnown = 20,
        /**
        * Category "Bad"
        * The process value cannot be used. Communication could not be established. There is no previous value.
        */
        CommFailure = 24,
        /**
        * Category "Bad"
        * Access to the process value or the group was deactivated or barred.
        */
        OutofService = 28,
        /**
        *Category "Uncertain"
        * The value was categorized as "unsafe" without specified information.
        */
        Uncertain = 64,
        /**
        * Category "Bad"
        * The process value is to be regarded as outdated, and no longer acceptable.
        */
        LastUsable = 68,
        /**
        * Category "Uncertain"
        * Either the value regarded as sensor value no longer lies within the region defined (through the limits) as 'normal'
        * or another logic within the OPC server has diagnosed that the value is to be regarded as 'uncalibrated'.
        * Specified information about the evaluation of a value my means of the defined limits is indicated in the 'Limit' property.
        */
        SensorCal = 80,
        /**
        * Category "Uncertain"
        * The process value has left the set limits. Further information can be read in the Limit' property.
        */
        EguExceeded = 84,
        /**
        * Category "Uncertain"
        * The value is reveiced from several sources, an inadequate quantity of which posess the "Good" quality.
        */
        SubNormal = 88,
        /**
        * Category "Good"
        * The process value can be used.
        */
        Good = 192,
        /**
        * Category "Good"
        * The process value was overwritten manually.
        */
        LocalOverride = 216
    }
    /**
    * public enum ChangeSource
    * Encompasses the possible sources for the change of a process variable.
    * @enum ChangeSource
    */
    enum ChangeSource {
        /**
        * The PLC has changed the value.
        */
        Process = 0,
        /**
        * An application that has logged on with the variable server as an OPC client has changed the process variable value.
        */
        ExternalOPCClient = 1,
        /**
        * The value was changed through a system function (e.g. a trigger variable reset by the archive system).
        */
        System = 2,
        /**
        * An access from the application changes the process variable value. The access was triggered from another item instance or through 'SetValue'.
        */
        Application = 3,
        /**
        *  The value was changed by the 'Value' property being written to in this instance.
        */
        ValueProperty = 4,
        /**
        * The value was changed through an input (access of StopEdit of an item object).
        */
        StopEdit = 5,
        /**
        * The process variable value was changed through the transfer functions of a recipe.
        */
        Recipe = 6,
        /**
        * The display of the item object was changed over between recipe cache and variable kernel.
        */
        View = 7,
        /**
        * The value was changed by a unit changeover.
        */
        UnitConversion = 8,
        /**
        * The quality flag of the process variable has changed.
        */
        Quality = 9,
        /**
        * The linked process variable was changed (change in 'Name'/'BitNumber', changeover of a multiplexer).
        */
        Configuration = 10,
        /**
        * Through the alarm system a bit of a process variable determined as an event variable was reset. The reason here was the acknowledgement of the alarm.
        */
        Alarm = 11
    }
    /**
    * public enum AccessRight
    * Contains the settings for the parameter "access type"
    * @enum AccessRight
    */
    enum AccessRight {
        /**
        * No access rights
        */
        None = 0,
        /**
        * Read only allowed
        */
        Read = 1,
        /**
        * Only write access allowed
        */
        Write = 2,
        /**
        * Read and write access allowed
        */
        ReadWrite = 3,
        /**
        * Single reading, then allowed only write access
        */
        ReadOnce = 4
    }
    /**
    * public enum Format
    * @enum Format
    */
    enum Format {
        Number = 0,
        Binary = 1,
        Hex = 2,
        AutoFloat = 3,
        Scientific = 4
    }
    /**
    * Enumeration for the possible process variable interpretations
    * public enum ItemMode
    * @enum ItemMode
    */
    enum ItemMode {
        Bits = 0,
        Value = 1,
        Masked = 2
    }
    /**
    * public enum LimitCheckMode
    * @enum LimitCheckMode
    */
    enum LimitCheckMode {
        None = 0,
        OnInput = 1,
        OnEnter = 2
    }
    /**
    * public enum VariableValueErrorCode
    * @enum VariableValueErrorCode
    */
    enum VariableValueErrorCode {
        /**
         * The function has been successfully executed.
         */
        Succeeded = 0,
        /**
         * Unknown error. This code is always set if none of the other ErrorCodes apply.
         * Further information could be found in the log file of the project server.
         */
        Error = -1,
        /**
         * Variable information cannot be determined (the variable name is invalid or not configured).
         */
        VariableDoesNotExist = -2,
        /**
        * Communication error between the variable server and the PLC.
        * Possible causes:
        * - The variable server is not connected to the PLC.
        * - An error occurred when calling the write or read function in the PLC. After that, the quality is typically no longer good.
        *
        * The error can occur when reading and writing variables.
        */
        CommFailure = -6,
        /**
        * Writing is not allowed for the variable.
        * Possible causes:
        * - Is currently only triggered for read-only system variables.
        *
        * The error can only occur when writing variables.
        */
        NoWriteAccess = -10,
        /**
        * Reading is not permitted for the variable (is currently not triggered).
        *
        * The error can only occur when reading variables.
        */
        NoReadAccess = -11,
        /**
        * The transferred value cannot be converted into the VisiWin 7 data type.
        * Examples:
        * - String in integer ("Hello world" in VT_I2 "write variable)
        *
        * The error can only occur when writing variables.
         */
        TypeMismatch = -12,
        /**
        * The value is too large or too small for the data type.
        * Possible causes:
        * - An attempt was made to write a value that lies outside the limits of the data type.
        * - The transferred array is too large for the defined array.
        *
        * The error can only occur when writing variables.
         */
        TypeOverflow = -13
    }
}
/**
* @namespace
* @name VisiWin.System.DataAccess
*/
declare namespace VisiWin.System.DataAccess {
    /**
    * @class
    * @name VisiWin.System.DataAccess.Quality
    * @description Structure for access to the status information of a process value.
    * @memberof VisiWin.System.DataAccess
    */
    abstract class Quality extends VisiWin.Internal.System.BaseClass implements VisiWin.System.DataAccess.IQuality {
        /**
        * Returns whether in the transfer of practical value, an error occurred.
        * @member { boolean }  IsBad
        */
        IsBad: boolean;
        /**
        * Returns whether the transfer of the value of the PLC has expired for visualization without clear error.
        * @member { boolean }
        */
        IsGoodOrUncertain: boolean;
        /**
        * The 'Value' property returns a numerical value from which 'Data' and 'Limit' are deduced.
        * @member { number }
        */
        Value: number;
        /**
        * Status information as to the transmitted process value.
        * @member { VisiWin.System.DataAccess.DataQuality }
        */
        Data: VisiWin.System.DataAccess.DataQuality;
        /**
        * Additional information as to the transmitted variable value relating to defined value area limitations.
        * @member { VisiWin.System.DataAccess.LimitQuality }
        */
        Limit: VisiWin.System.DataAccess.LimitQuality;
    }
}
/**
* @namespace
* @name VisiWin.System.DataAccess
*/
declare namespace VisiWin.System.DataAccess {
    /**
    * @class VisiWin.System.DataAccess.VariableService
    * @description Entry point into the process connection.
    * @memberof VisiWin.System.DataAccess
    */
    class VariableService extends VisiWin.Internal.System.BaseClass implements VisiWin.System.DataAccess.IVariableService {
        static getService(): VariableService;
        /**
        * @function GetValueAsync
        * @description Reads the value of the variable.
        * @param {string} variableName The alias of the variable.
        * @returns {Promise<VisiWin.System.DataAccess.VariantType>} The value of the variable.
        */
        GetValueAsync(variableName: string): Promise<VisiWin.System.DataAccess.VariantType>;
        /**
        * @function GetValueAsync
        * @description Reads the value of the variable.
        * @param {string} variableName The alias of the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.IGetValueResult>} the extended result of the operation
        */
        GetValueAsync(variableName: string, resultDetails: boolean): Promise<VisiWin.System.DataAccess.IGetValueResult>;
        /**@function GetValuesAsync
        * @description Reads the values of variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @returns {Promise<VisiWin.System.DataAccess.VariantType[]>} The values of the variables.
        */
        GetValuesAsync(variableName: string[]): Promise<VisiWin.System.DataAccess.VariantType[]>;
        /**@function GetValuesAsync
        * @description Reads the values of variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.IGetValueResult[]>} The extended result of the operation.
        */
        GetValuesAsync(variableNames: string[], resultDetails: boolean): Promise<VisiWin.System.DataAccess.IGetValueResult[]>;
        /**@function GetRawValueAsync
        * @description Reads the raw value of the variable.
        * @param {string} variableName The alias of the variable.
        * @returns {Promise<VisiWin.System.DataAccess.VariantType[]>} The value of the variable.
        */
        GetRawValueAsync(variableName: string): Promise<VisiWin.System.DataAccess.VariantType>;
        /**@function GetRawValueAsync
        * @description Reads the values of variables.
        * @param {string} variableName The alias of the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.IGetValueResult>} the extended result of the operation
        */
        GetRawValueAsync(variableName: string, resultDetails: boolean): Promise<VisiWin.System.DataAccess.IGetValueResult>;
        /**@function GetRawValuesAsync
        * @description Reads the raw values of the variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @returns {Promise<VisiWin.System.DataAccess.VariantType[]>} The values of the variables.
        */
        GetRawValuesAsync(variableName: string[]): Promise<VisiWin.System.DataAccess.VariantType[]>;
        /**@function GetRawValuesAsync
        * @description Reads the values of variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.IGetValueResult[]>} the extended result of the operation
        */
        GetRawValuesAsync(variableNames: string[], resultDetails: boolean): Promise<VisiWin.System.DataAccess.IGetValueResult[]>;
        /**@function SetValueAsync
        * @description Writes the value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {VisiWin.System.DataAccess.VariantType} newValue The value for the variable.
        * @returns {Promise<boolean>} Determines whether the operation was successful.
        */
        SetValueAsync(variableName: string, newValue: VisiWin.System.DataAccess.VariantType): Promise<boolean>;
        /**@function ISetValueAsync
        * @description Writes the value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {VisiWin.System.DataAccess.VariantType} newValue The value for the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetValueResult>} The extended result of the operation
        */
        SetValueAsync(variableName: string, newValue: VisiWin.System.DataAccess.VariantType, resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetValueResult>;
        /**@function SetValuesAsync
        * @description Writes the values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {VisiWin.System.DataAccess.VariantType[]} newValues The values for the variables.
        * @returns {Promise<boolean[]>} Determines whether the operation was successful.
        */
        SetValuesAsync(variableNames: string[], newValues: VisiWin.System.DataAccess.VariantType[]): Promise<boolean[]>;
        /**@function SetValuesAsync
        * @description Writes the values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {VisiWin.System.DataAccess.VariantType[]} newValues The values for the variables.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetValueResult[]>} The extended result of the operation
        */
        SetValuesAsync(variableNames: string[], newValues: VisiWin.System.DataAccess.VariantType[], resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetValueResult[]>;
        /**@function SetRawValueAsync
        * @description Writes the raw value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {VisiWin.System.DataAccess.VariantType} newValue The raw value for the variable.
        * @returns {Promise<boolean>} Determines whether the operation was successful.
        */
        SetRawValueAsync(variableName: string, newValue: VisiWin.System.DataAccess.VariantType): Promise<boolean>;
        /**@function SetRawValueAsync
        * @description Writes the valuespassed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {VisiWin.System.DataAccess.VariantType} newValue The raw value for the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetValueResult>} The extended result of the operation
        */
        SetRawValueAsync(variableName: string, newValue: VisiWin.System.DataAccess.VariantType, resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetValueResult>;
        /**@function SetRawValuesAsync
        * @description Writes the raw values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {VisiWin.System.DataAccess.VariantType[]} newValues The raw values for the variables.
        * @returns {Promise<boolean[]>} Determines whether the operation was successful.
        */
        SetRawValuesAsync(variableNames: string[], newValues: VisiWin.System.DataAccess.VariantType[]): Promise<boolean[]>;
        /**@function SetRawValuesAsync
        * @description Writes the values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {VisiWin.System.DataAccess.VariantType[]} newValues The raw values for the variables.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetValueResult[]>} The extended result of the operation
        */
        SetRawValuesAsync(variableNames: string[], newValues: VisiWin.System.DataAccess.VariantType[], resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetValueResult[]>;
        /**@function SetBitAsync
        * @description Writes the value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {number} bitNumber The bit number for the variable.
        * @param {boolean} The bit value for the variable.
        * @returns {Promise<boolean>} Determines whether the operation was successful.
        */
        SetBitAsync(variableName: string, bitNumber: number, newValue: boolean): Promise<boolean>;
        /**@function SetBitAsync
        * @description Writes the value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {number} bitNumber The bit number for the variable.
        * @param {boolean} newValue The bit value for the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetBitResult>} The extended result of the operation
        */
        SetBitAsync(variableName: string, bitNumber: number, newValue: boolean, resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetBitResult>;
        /**@function SetBitsAsync
        * @description Writes the values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {number[]} bitNumbers The bit numbers for the variables.
        * @param {boolean[]} newValues The bit values for the variables.
        * @returns {Promise<boolean[]>} Determines whether the operation was successful
        */
        SetBitsAsync(variableNames: string[], bitNumbers: number[], newValues: boolean[]): Promise<boolean[]>;
        /**@function SetBitsAsync
        * @description Writes the values passed in the given process variables.
        * @param {string[]} variableNames The aliases of the variables.
        * @param {number[]} bitNumbers The bit numbers for the variables.
        * @param {boolean[]} newValues The bit values for the variables.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetBitResult[]>} The extended result of the operation
        */
        SetBitsAsync(variableNames: string[], bitNumbers: number[], newValues: boolean[], resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetBitResult[]>;
        /**@function GetVariable
        * @description An empty IVariable object by variable name.
        * @param The alias of the variable.
        * @returns {VisiWin.System.DataAccess.IVariable}
        * @remarks Add Change handler before calling Variable.AttachAsync()
        */
        GetVariable(name: string): VisiWin.System.DataAccess.IVariable;
        /**@function GetUnitClassAsync
        * @description Returns a unit class object.
        * @param The name of the required UnitClass.
        * @returns {Promise<VisiWin.System.DataAccess.IUnitClass>}
        */
        GetUnitClassAsync(unitClassName: string): Promise<VisiWin.System.DataAccess.IUnitClass>;
        /**@function GetCurrentUnitAsync
        * @description  Returns the active unit object of the unit class.
        * @param The name of the required UnitClass.
        * @returns {Promise<VisiWin.System.DataAccess.IUnit>}
        */
        GetCurrentUnitAsync(unitClassName: string): Promise<VisiWin.System.DataAccess.IUnit>;
    }
}
/**
* @namespace
* @name VisiWin.System.DataAccess
*/
declare namespace VisiWin.System.DataAccess {
    /**
    * @class
    * @name VisiWin.System.DataAccess.Unit
    * @description Class for access to the unit conversion in a unit class currently used in the system.
    * @memberof VisiWin.System.DataAccess
    */
    abstract class Unit extends VisiWin.Internal.System.BaseClass implements VisiWin.System.DataAccess.IUnit {
        /**
        * Decimal adjustment with whole-numbered values or specification of decimal place with floating point figures.
        * @member { number }  DecPoint
        */
        DecPoint: number;
        /**
        * Value addend/offset.
        * @member { number }  Offset
        */
        Offset: number;
        /**
        * Value factor.
        * @member { number }  Slope
        */
        Slope: number;
        /**
        * Value of the "Unit text" definition parameter.
        * @member { string }  Text
        */
        Text: string;
        /**
        * Name of the unit.
        * @member { string }  Name
        */
        Name: string;
        /**
        * X coordinate of the first straight line base point.
        * @member { number }  X1
        */
        X1: number;
        /**
        * X coordinate of the second straight line point.
        * @member { number }  X2
        */
        X2: number;
        /**
        * Y coordinate of the first straight line point.
        * @member { number }  Y1
        */
        Y1: number;
        /**
        * Y coordinate of the first straight line point.
        * @member { number }  Y2
        */
        Y2: number;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
    }
}
/**
* @namespace
* @name VisiWin.System.DataAccess
*/
declare namespace VisiWin.System.DataAccess {
    /**
    * @class
    * @name VisiWin.System.DataAccess.UnitClass
    * @description Class for access to the unit conversion in a unit class currently used in the system.
    * @memberof VisiWin.System.DataAccess
    * @summary UnitClass is only available for attached variables.
    */
    abstract class UnitClass extends VisiWin.Internal.System.BaseClass implements VisiWin.System.DataAccess.IUnitClass {
        UnitClassType: VisiWin.System.DataAccess.UnitClassType;
        /**
        * A unit class currently used in the system.
        * @member { VisiWin.System.DataAccess.IUnit }  CurrentUnit
        */
        CurrentUnit: VisiWin.System.DataAccess.IUnit;
        /**
        *  Name of the unit class.
        * @member { string } Name
        */
        Name: string;
        /**
        * Is triggered when the information of the unit conversion was changed.
        * @member { Event } Change
        */
        Change: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.DataAccess.IUnit>;
    }
}
/**
* @namespace
* @name VisiWin.System.DataAccess
*/
declare namespace VisiWin.System.DataAccess {
    /**
    * @class
    * @name VisiWin.System.DataAccess.Variable
    * @description Object for accessing a process variable from the process databank.
    * @memberof VisiWin.System.DataAccess
    */
    abstract class Variable extends VisiWin.Internal.System.BaseClass implements VisiWin.System.DataAccess.IVariable {
        /**
        * Is triggered when the variable changes.
        * @event  VisiWin.System.DataAccess.Variable
        * @param { ChangeEventArgs } VisiWin.System.DataAccess.IVariableChangeEventArgs
        */
        Change: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.DataAccess.IVariableChangeEventArgs>;
        /**
        * Returns the point shifting calculated from 'DecPoint' and 'UnitConversion'.
        * @member { number }  CalculatedDecPoint
        */
        CalculatedDecPoint: number;
        /**
        * Determines whether the variable value can be edited using this control in the recipe buffer.
        * @member { boolean }  CanRecipeEdit
        */
        CanRecipeEdit: boolean;
        /**
        * Determines the value for the "Comment" definition parameter.
        * @member { string }  Comment
        */
        Comment: string;
        /**
        * Decimal adjustment with whole-numbered values or specification of decimal places with floating point figures.
        * @member { number }  DecPoint
        */
        DecPoint: number;
        /**
        * Establishes whether the object is currently administering a valid process variable registration.
        * @member { boolean }  IsAttached
        */
        IsAttached: boolean;
        /**
        * Returns whether the specified variable is in the editing mode.
        * @member { string }  IsEditing
        */
        IsEditing: boolean;
        /**
        * Returns whether the variable represents a numeric data type.
        * @member { boolean }  IsNumeric
        */
        IsNumeric: boolean;
        /**
        * Returns whether the quality information to the transmitted value indicates a trouble-free data exchange.
        * @member { boolean }  IsQualityGood
        */
        IsQualityGood: boolean;
        /**
        * Returns whether the value of the variable is currently based on the recipe buffer.
        * @member { boolean }  IsRecipeEditing
        */
        IsRecipeEditing: boolean;
        /**
        * Returns whether the specified variable was found in the variable kernel.
        * @member { boolean }  IsValid
        */
        IsValid: boolean;
        /**
        * Name of the process variable from the project databank
        * @member { string }  Name
        */
        Name: string;
        /**
        * Returns the value of the "maximum value" from the variable definition (without unit conversion).
        * @member { VisiWin.System.DataAccess.VariantType }  RawMaxValue
        */
        RawMaxValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Returns the value of the "minimum value" from the variable definition (without unit conversion).
        * @member { string }  RawMinValue
        */
        RawMinValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Specifies the new variable value (without unit conversion).
        * @member { VisiWin.System.DataAccess.VariantType }  RawValue
        */
        RawValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Allows the user caching of any object.
        * @member { object }  Tag
        */
        Tag: object;
        /**
        * Returns the localizable text on the variable.
        * @member { string }  Text
        */
        Text: string;
        /**
        * Returns the value of the "Unit text" parameter.
        * @member { string }  UnitText
        */
        UnitText: string;
        /**
        * Determines whether the properties Value/MinValue/MaxValue associated with a device class (display) to be converted.
        * @member { boolean }  UseUnitConversion
        */
        UseUnitConversion: boolean;
        /**
        * Returns the old value (without unit conversion) before the change of the variable value.
        * @member { VisiWin.System.DataAccess.VariantType }  PreviousRawValue
        */
        PreviousRawValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Returns the old value (with unit conversion) before the change of the variable value.
        * @member { VisiWin.System.DataAccess.VariantType }  PreviousValue
        */
        PreviousValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Returns whether the linked variable is to be obtained through the recipe cache of the variable
        * @member { boolean }  RecipeMode
        */
        RecipeMode: boolean;
        /**
        * Registers the object with the process variable core
        */
        AttachAsync(): Promise<boolean>;
        /**
        * unregisters the object with the process variable core
        */
        Detach(): void;
        /**
        * Value from the variable core.
        * @member { VisiWin.System.DataAccess.VariantType }  Value
        */
        Value: VisiWin.System.DataAccess.VariantType;
        /**
        * Value of the 'Maximum' parameter from the project databank.
        * @member { VisiWin.System.DataAccess.VariantType }  MaxValue
        */
        MaxValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Value of the 'Minimum' parameter from the project databank.
        * @member { VisiWin.System.DataAccess.VariantType }  MinValue
        */
        MinValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Evaluating information from the variable core.
        * @member { VisiWin.System.DataAccess.IQuality }  Quality
        */
        Quality: VisiWin.System.DataAccess.IQuality;
        /**
        * Returns the raw data type of the associated variables.
        * @member { VisiWin.System.DataAccess.TypeCode }  RawTypeCode
        */
        RawTypeCode: VisiWin.System.DataAccess.TypeCode;
        /**
        * Time stamp of the last transmitted value.
        * @member { Date }  TimeStamp
        */
        TimeStamp: Date;
        /**
        * Returns the data type of the sssociated variables.
        * @member { VisiWin.System.DataAccess.TypeCode }  TypeCode
        */
        TypeCode: VisiWin.System.DataAccess.TypeCode;
        /**
        * Returns the unit class specified in the variable definition.
        * @member { VisiWin.System.DataAccess.IUnitClass }  UnitClass
        */
        UnitClass: VisiWin.System.DataAccess.IUnitClass;
        /**
        * Returns a detailed reason for the value change
        * @member { VisiWin.System.DataAccess.ChangeSource }  Source
        */
        Source: VisiWin.System.DataAccess.ChangeSource;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Returns the name of the max value variable, if available.
        * @description This variable name is required for the UI, to implement a limit check, when the limits came from variables.
        * @description MaxValue,MinValue,RawMaxValue,RawMinValue are not available in IVariable, if a variable dependent limit value is set.
        * available with WebGatewayProtocolVersion == 3 (2019.2)
        */
        MaxValueVariableName?: string;
        /**
        * Returns the name of the min value variable, if available.
        * @description This variable name is required for the UI, to implement a limit check, when the limits came from variables.
        * @description MaxValue,MinValue,RawMaxValue,RawMinValue are not available in IVariable, if a variable dependent limit value is set.
        * available with WebGatewayProtocolVersion == 3 (2019.2)
        */
        MinValueVariableName?: string;
        /**
        *@description Contains the settings for the "Access type" parameter from the project database
        * @member { VisiWin.System.DataAccess.AccessRight } AccessRight
        */
        AccessRight?: VisiWin.System.DataAccess.AccessRight;
        /**
        *@description Returns the "field size" of the variable.
        *
        *@version Rumtime version 7.2 only!
        *
        * @member { number[] } FieldSize
        */
        FieldSize?: number[];
        /**
        *@description Returns the "field sizes" of the variable.
        *
        *@version Rumtime version 7.3 only!
        *
        * @member { number[] } FieldSizes
        */
        FieldSizes?: number[];
        /**
        *@description Returns the "field offset" of the variable.
        *
        *@version Rumtime version 7.2 only!
        *
        * @member {number[]} FieldOffset
        */
        FieldOffset?: number[];
        /**
        *@description Returns the "field offsets" of the variable.
        *
        *@version Rumtime version 7.3 only!
        *
        * @member {number[]} FieldOffsets
        */
        FieldOffsets?: number[];
    }
}
/**
*
<section class="tsd-panel-group tsd-index-group">
    <h4>Additional Information</h4>
    <section class="tsd-panel tsd-index-panel">
        <div class="tsd-index-content">
            <section class="tsd-index-section ">
             <h4>Examples</h4>
                <ul class="tsd-index-list">
                    <li><a href="../tutorials/Language/ILanguageService.html" class="tsd-kind-icon">ILanguageService</a></span></li>
                </ul>
                <ul class="tsd-index-list">
                    <li><a href="../tutorials/Language/ILocalizedText.html" class="tsd-kind-icon">ILocalizedText</a></span></li>
                    <li><a href="../tutorials/Language/GetTextAsync.html" class="tsd-kind-icon">GetText</a></span></li>
                    <li><a href="../tutorials/Language/ChangeLanguageAsync.html" class="tsd-kind-icon">ChangeLanguage</a></span></li>
                </ul>
            </section>
        </div>
    </section>
</section>

*/
declare namespace VisiWin.System.Language { }
/**
* @namespace
* @name VisiWin.System.Language
*/
declare namespace VisiWin.System.Language {
    /**
    * @class
    * @name VisiWin.System.Language.LanguageService
    * @description Entry point into the VisiWin language switching
    * @memberof VisiWin.System.Language
    */
    interface ILanguageService extends VisiWin.Internal.System.IBaseClass {
        /**
        * Shows information on the language currently set in the application.
        * @member { VisiWin.System.Language.IProjectLanguage } CurrentLanguage
        */
        CurrentLanguage: VisiWin.System.Language.IProjectLanguage;
        /**
        * Determines the language to be displayed in the application via the "Locale Identifier"
        * @member { number }
        */
        CurrentLCID: number;
        /**
        * Returns the languages present in the project as a collection
        * @member { VisiWin.System.Language.IProjectLanguage }  ProjectLanguages
        */
        ProjectLanguages: VisiWin.System.Language.IProjectLanguage[];
        /**
        * Provides data for the "LanguageChange" event
        * @event LanguageService#LanguageChanged
        * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Language.LCID>}
        */
        LanguageChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Language.LCID>;
        /**@function
        * @description Change the project language
        * @name  ChangeLanguageAsync
        * @returns  Promise<VisiWin.System.Language.LCID>
        */
        ChangeLanguageAsync(newLanguage: VisiWin.System.Language.IProjectLanguage): Promise<VisiWin.System.Language.LCID>;
        ChangeLanguageAsync(LCID: number): Promise<VisiWin.System.Language.LCID>;
        ChangeLanguageAsync(LCID: number | VisiWin.System.Language.IProjectLanguage): Promise<VisiWin.System.Language.LCID>;
        /**@function
        * @description Returns a 'LocalizedText' for the specified language switchable text
        * @name  GetLocalizedTextAsync
        * @returns Promise<VisiWin.System.Language.ILocalizedText>
        */
        GetLocalizedTextAsync(text: string): Promise<VisiWin.System.Language.ILocalizedText>;
        GetLocalizedTextAsync(textGroup: string, text: string): Promise<VisiWin.System.Language.ILocalizedText>;
        GetLocalizedTextAsync(textType: VisiWin.System.Language.TextType, text: string): Promise<VisiWin.System.Language.ILocalizedText>;
        GetLocalizedTextAsync(textType: VisiWin.System.Language.TextType, textGroup: string, text: string): Promise<VisiWin.System.Language.ILocalizedText>;
        GetLocalizedTextAsync(param1?: unknown, param2?: unknown, param3?: unknown): Promise<VisiWin.System.Language.ILocalizedText>;
        /**@function
        * @description Queries an index text
        * @name  GetTextAsync
        * @returns Promise<VisiWin.System.Language.DisplayText>
        */
        GetTextAsync(fullQualifiedText: string): Promise<VisiWin.System.Language.DisplayText>;
        /**
        * Returns the languages present in the server project as a collection
        * available with WebGatewayProtocolVersion == 6 (2020.1)
        */
        GetServerProjectLanguagesAsync(): Promise<VisiWin.System.Language.IProjectLanguage[]>;
        /**@function
        * @description Changes multiple text formats in the passed languages.
        * @version Rumtime version 7.3 only!
        * @name ChangeTextFormats
        * @param { VisiWin.System.Language.IChangedTextFormats[]} changedTextFormats
        * @returns Promise<boolean>
        */
        ChangeTextFormats(changedTextFormats: VisiWin.System.Language.IChangedTextFormats[]): Promise<boolean>;
        /**@function
        * @description Resets a text changed at runtime in a specific language.
        * @version Rumtime version 7.3 only!
        * @name ResetTextFormat
        * @param { string } textKey
        * @param { number } lcid
        * @returns Promise<boolean>
        */
        ResetTextFormat(textKey: string, lcid: number): Promise<boolean>;
    }
}
declare namespace VisiWin.System.Language {
    /**
     * Class for access to a localized text from the project databank
     */
    interface IProjectLanguage extends VisiWin.Internal.System.IBaseClass {
        /**
        * Gets the culture name in the localized version of the .NET Framework language from "(<Full Country / Region>) <Complete Language>" format.
        */
        CultureDisplayName: string;
        /**
        * Indication of the 'LCID' property value
        */
        LCID: number;
        /**
        * Indication of the 'locale' property value eg: "en-US" "language-Country"
        */
        Locale?: string;
        /**
        * Indication of the text name
        */
        Text: string;
        /**
        * Gets english language name from Intl.DisplayNames(["en-US"], { type: "language" }).of(this.ShortLocale);
        */
        EnglishName?: string;
        /**
        * Gets native language name from Intl.DisplayNames([this.Locale], { type: "language" }).of(this.ShortLocale);
        */
        NativeName?: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Language
*/
declare namespace VisiWin.System.Language {
    /**
    * @class
    * @name VisiWin.System.Language.LocalizedText
    * @description Class for access to localized texts from the project databank
    * @memberof VisiWin.Language.DataAccess
    */
    interface ILocalizedText extends VisiWin.Internal.System.IBaseClass {
        /**
        * Return of the text
        * @member { string }
        */
        DisplayText: string;
        /**
        * Indication of the text group
        * @member { string }
        */
        TextGroup: string;
        /**
        * Name of the text from the language switching
        * @member { string }
        */
        TextName: string;
        /**
        * Determines where the text is searched for.
        * @member { VisiWin.System.Language.TextType }
        */
        TextType: VisiWin.System.Language.TextType;
        /**
        * Reports a change in the 'DisplayText' property
        * @event Changed
        * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Language.ILocalizedTextChangedEventArgs>}
        */
        Changed: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Language.ILocalizedTextChangedEventArgs>;
        /**
        * The combination of TextGroup.TextName
        * @member {string}
        */
        FullQualifiedText: string;
    }
    interface ILocalizedFormats {
        Lcid: number;
        Format: string;
    }
    interface IChangedTextFormats {
        TextKey: string;
        LocalizedFormats: ILocalizedFormats[];
    }
}
declare namespace VisiWin.System.Language {
    type DisplayText = string;
    type LCID = number;
    /**
    * Contains information about the ILocalizedText.Changed event that reports when a language-switchable text that is logged on for monitoring changes
    */
    interface ILocalizedTextChangedEventArgs {
        /**
        *  Returns the text in the current project language
        */
        DisplayText: string;
        /**
        * Full identifier (hierarchy of all superordinate text groups separated by ".") of the text group
        */
        TextGroup: string;
        /**
        * Name of the text from the language switch
        */
        TextName: string;
        /**
        * The category (for example, ClientApplication)
        */
        TextType: VisiWin.System.Language.TextType;
    }
}
/**
* @namespace
* @name VisiWin.System.Language
*/
declare namespace VisiWin.System.Language {
    /**
    * @class
    * @name VisiWin.System.Language.ProjectLanguage
    * @description Class for access to a localized text from the project databank
    * @memberof VisiWin.System.Language
    */
    abstract class ProjectLanguage extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Language.IProjectLanguage {
        /**
        * Gets the culture name in the localized version of the .NET Framework language from "(<Full Country / Region>) <Complete Language>" format.
        * @member { string }
        */
        CultureDisplayName: string;
        /**
        * Indication of the 'LCID' property value
        * @member { number }
        */
        LCID: number;
        /**
        * Indication of the 'locale' property value eg: "en-US" "language-Country"
        */
        Locale: string;
        /**
        * Indication of the text name
        * @member { string }
        */
        Text: string;
        /**
        * Gets english language name from Intl.DisplayNames(["en-US"], { type: "language" }).of(this.ShortLocale);
        */
        EnglishName: string;
        /**
        * Gets native language name from Intl.DisplayNames([this.Locale], { type: "language" }).of(this.ShortLocale);
        */
        NativeName: string;
    }
}
declare namespace VisiWin.System.Language {
    /**
    * @class
    * @name VisiWin.System.Language.LanguageService
    * @description Entry point into the VisiWin language switching
    * @memberof VisiWin.System.Language
    */
    class LanguageService extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Language.ILanguageService {
        static getService(): ILanguageService;
        /**
        * Shows information on the language currently set in the application.
        * @member { VisiWin.System.Language.IProjectLanguage } CurrentLanguage
        */
        CurrentLanguage: VisiWin.System.Language.IProjectLanguage;
        /**
        * Determines the language to be displayed in the application via the "Locale Identifier"
        * @member { number }
        */
        CurrentLCID: number;
        /**
        * Returns the languages present in the project as a collection
        * @member { VisiWin.System.Language.IProjectLanguage }  ProjectLanguages
        */
        ProjectLanguages: VisiWin.System.Language.IProjectLanguage[];
        /**
        * Provides data for the "LanguageChange" event
        * @event LanguageService#LanguageChanged
        * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Language.LCID>}
        */
        LanguageChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Language.LCID>;
        /**@function
        * @description Change the project language
        * @name  ChangeLanguageAsync
        * @returns  Promise<VisiWin.System.Language.LCID>
        */
        ChangeLanguageAsync(newLanguage: VisiWin.System.Language.IProjectLanguage): Promise<VisiWin.System.Language.LCID>;
        ChangeLanguageAsync(LCID: number): Promise<VisiWin.System.Language.LCID>;
        /**@function
        * @description Returns a 'LocalizedText' for the specified language switchable text
        * @name  GetLocalizedTextAsync
        * @returns Promise<VisiWin.System.Language.ILocalizedText>
        */
        GetLocalizedTextAsync(text: string): Promise<VisiWin.System.Language.ILocalizedText>;
        GetLocalizedTextAsync(textGroup: string, text: string): Promise<VisiWin.System.Language.ILocalizedText>;
        GetLocalizedTextAsync(textType: VisiWin.System.Language.TextType, text: string): Promise<VisiWin.System.Language.ILocalizedText>;
        GetLocalizedTextAsync(textType: VisiWin.System.Language.TextType, textGroup: string, text: string): Promise<VisiWin.System.Language.ILocalizedText>;
        /**@function
        * @description Queries an index text
        * @name  GetTextAsync
        * @returns Promise<VisiWin.System.Language.DisplayText>
         */
        GetTextAsync(fullQualifiedText: string): Promise<VisiWin.System.Language.DisplayText>;
        /**
        * Returns the languages present in the server project as a collection
        * available with WebGatewayProtocolVersion == 6 (2020.1)
        */
        GetServerProjectLanguagesAsync(): Promise<VisiWin.System.Language.IProjectLanguage[]>;
        /**@function
        * @description Changes multiple text formats in the passed languages.
        * @version Rumtime version 7.3 only!
        * @name ChangeTextFormats
        * @param { VisiWin.System.Language.IChangedTextFormats[]} changedTextFormats
        * @returns Promise<boolean>
        */
        ChangeTextFormats(changedTextFormats: VisiWin.System.Language.IChangedTextFormats[]): Promise<boolean>;
        /**@function
        * @description Resets a text changed at runtime in a specific language.
        * @version Rumtime version 7.3 only!
        * @name ResetTextFormat
        * @param { string } textKey
        * @param { number } lcid
        * @returns Promise<boolean>
        */
        ResetTextFormat(textKey: string, Lcid: number): Promise<boolean>;
    }
}
/**
* @namespace
* @name VisiWin.System.Language
*/
declare namespace VisiWin.System.Language {
    /**
    * @class
    * @name VisiWin.System.Language.LocalizedText
    * @description Class for access to localized texts from the project databank
    * @memberof VisiWin.Language.DataAccess
    */
    abstract class LocalizedText extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Language.ILocalizedText {
        /**
        * Return of the text
        * @member { string }
        */
        DisplayText: string;
        /**
        * Indication of the text group
        * @member { string }
        */
        TextGroup: string;
        /**
        * Name of the text from the language switching
        * @member { string }
        */
        TextName: string;
        /**
        * Determines where the text is searched for.
        * @member { VisiWin.System.Language.TextType }
        */
        TextType: VisiWin.System.Language.TextType;
        /**
        * Reports a change in the 'DisplayText' property
        * @event Changed
        * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Language.ILocalizedTextChangedEventArgs>}
        */
        Changed: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Language.ILocalizedTextChangedEventArgs>;
        /**
        * The combination of TextGroup.TextName
        * @member {string}
        */
        FullQualifiedText: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Language
*/
declare namespace VisiWin.System.Language {
    /**
    * Enumeration of the different date/time format display modes
    * @readonly
    * @enum {number} DateTimeMode
    */
    enum DateTimeMode {
        /**
        * Only the time is indicated.
        */
        TimeOnly = 0,
        /**
        * Only the date is indicated.
        */
        DateOnly = 1,
        /**
        * The time is indicated followed by the date.
        */
        TimeDate = 2,
        /**
        * The date is indicated followed by the time.
        */
        DateTime = 3,
        /**
        * The time is indicated followed by the date. Time and date are displayed separated by a word wrap.
        */
        TimeCRDate = 4,
        /**
        * The date is indicated followed by the time. Date and time are displayed separated by a word wrap.
        */
        DateCRTime = 5
    }
    /**
    * Lists the possible causes of a text change in the 'LocalizedText' class.
    * @readonly
    * @enum {number} TextChangedBy
    */
    enum TextChangedBy {
        /**
        * The language was changed in the application.
        */
        Language = 0,
        /**
        * A different text was selected via the properties of the 'LocalizedText' class.
        */
        Property = 1,
        /**
        * The value of a dynamic parameter that was incorporated in the text has changed.
        */
        Param = 2
    }
    /**
    * Enumeration containing the different text categories for querying index texts as elements
    * @readonly
    * @enum {number} TextType
    */
    enum TextType {
        /**
        * The query refers to the texts in the "User texts" branch of the client project.
        */
        ClientApplication = 0,
        /**
        * The query refers to the texts in the "Components" and "Dialogs" branches of the client project.
        */
        ClientSystem = 1,
        /**
        * The query refers to the texts in the "User texts" branch of the server project.
        */
        ServerApplication = 2,
        /**
        * The query refers to the texts in the "Components" and "Dialogs" branches of the server project.
        */
        ServerSystem = 3
    }
}
/**
* @namespace
* @name VisiWin.System.Language
*/
declare namespace VisiWin.System.Language {
    /**
     * Better DateTimeFormatOptions types
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat for representation details
     *
     * KUT Carful with safari!
     *
     */
    /** @ignore */
    interface DateTimeFormatOptions extends Intl.DateTimeFormatOptions {
        localeMatcher?: "best fit" | "lookup";
        weekday?: "long" | "short" | "narrow";
        era?: "long" | "short" | "narrow";
        year?: "numeric" | "2-digit";
        month?: "numeric" | "2-digit" | "long" | "short" | "narrow";
        day?: "numeric" | "2-digit";
        hour?: "numeric" | "2-digit";
        minute?: "numeric" | "2-digit";
        second?: "numeric" | "2-digit";
        timeZoneName?: "long" | "short";
        formatMatcher?: "best fit" | "basic";
        hour12?: boolean;
        /**
         * Timezone string must be one of IANA. UTC is a universally required recognizable value
         */
        timeZone?: "UTC" | string;
        calendar?: "buddhist" | "chinese" | " coptic" | "ethiopia" | "ethiopic" | "gregory" | " hebrew" | "indian" | "islamic" | "iso8601" | " japanese" | "persian" | "roc";
        dayPeriod?: "narrow" | "short" | "long";
        numberingSystem?: "arab" | "arabehot" | "bali" | "beng" | "deva" | "fullwide" | " gujr" | "guru" | "hanidec" | "khmr" | " knda" | "laoo" | "latn" | "limb" | "mlym" | " mong" | "mymr" | "orya" | "tamldec" | " telu" | "thai" | "tibt";
        hourCycle?: "h11" | "h12" | "h23" | "h24";
        /**
         * Warning! Partial support //KUT Carful with safari!
         */
        fractionalSecondDigits?: 0 | 1 | 2 | 3;
        dateStyle?: "full" | "long" | "medium" | "short";
        timeStyle?: "full" | "long" | "medium" | "short";
    }
    export interface IDateTimeFormats {
        LongDate: DateTimeFormatOptions;
        ShortDate: DateTimeFormatOptions;
        NamedLongDate: DateTimeFormatOptions;
        NamedShortDate: DateTimeFormatOptions;
        LongTime: DateTimeFormatOptions;
        ShortTime: DateTimeFormatOptions;
    }
    export class DateTimeFormats implements VisiWin.System.Language.IDateTimeFormats {
        /** @ignore */
        private _LongDate;
        get LongDate(): DateTimeFormatOptions;
        set LongDate(value: DateTimeFormatOptions);
        /** @ignore */
        private _ShortDate;
        get ShortDate(): DateTimeFormatOptions;
        set ShortDate(value: DateTimeFormatOptions);
        /** @ignore */
        private _NamedLongDate;
        get NamedLongDate(): DateTimeFormatOptions;
        set NamedLongDate(value: DateTimeFormatOptions);
        /** @ignore */
        private _NamedShortDate;
        get NamedShortDate(): DateTimeFormatOptions;
        set NamedShortDate(value: DateTimeFormatOptions);
        /** @ignore */
        private _LongTime;
        get LongTime(): DateTimeFormatOptions;
        set LongTime(value: DateTimeFormatOptions);
        /** @ignore */
        private _ShortTime;
        get ShortTime(): DateTimeFormatOptions;
        set ShortTime(value: DateTimeFormatOptions);
    }
    /** @ignore */
    export function _locale2lcid(locale: string): number;
    /** @ignore */
    export function _lcid2locale(lcid: number): string;
    export {};
}
declare namespace VisiWin.System.Logging {
    /**
    * @class
    * @name HistoricalLoggingStreamRequest
    * @description Object for retrieving historical data as data stream
    * @memberof VisiWin.System.Logging
    */
    interface IHistoricalLoggingStreamRequest {
        /**
        * 'HistoricalLoggingEntry' encapsulates the properties of a recorded logging entry. It is used to return information on the recorded logging events.
        * @member {  VisiWin.System.Logging.HistoricalLoggingEntry[] } HistoricalLoggingEntries
        */
        HistoricalLoggingEntries: VisiWin.System.Logging.IHistoricalLoggingEntry[];
        /**
        * The 'HistoricalLoggingFilter' describes the filter settings for querying recorded logging events.
        * @member {  VisiWin.System.Logging.HistoricalLoggingFilter } Filter
        */
        Filter: VisiWin.System.Logging.IHistoricalLoggingFilter;
        /**
        * ID to keep the different requests, unique.
        * @member { VisiWin.IGuid } RequestID
        */
        RequestID: VisiWin.IGuid;
        /**
        * The current position in the data stream.
        * @member { number } Position
        */
        Position: number;
        /**
        * The length of the data stream.
        * @member { number } Length
        */
        Length: number;
        /**
        * The number of requested data.
        * @member { number } Count
        */
        Count: number;
        /**
        * Additional information on the result.
        * @member { string } Result
        */
        Result: string;
        /**
        * @method
        * GetHistoricalLoggingEntriesStream
        * @description Entry point for reading a historical data stream.
        * @returns {  Promise<VisiWin.System.Logging.IHistoricalLoggingStreamRequest> }
        */
        GetHistoricalLoggingEntriesStream(): Promise<VisiWin.System.Logging.IHistoricalLoggingStreamRequest>;
        /**
        * @method
        * ReadHistoricalLoggingEntriesStream
        * @description Entry point for reading a historical data stream.
        * @param { number }  position The current position inside the data stream.
        * @param { number }  count The number of objects to retrieve.
        * @returns {  Promise<VisiWin.System.Logging.IHistoricalLoggingStreamRequest> }
        */
        ReadHistoricalLoggingEntriesStream(position: number, count: number): Promise<VisiWin.System.Logging.IHistoricalLoggingStreamRequest>;
        /**
        * @method
        * CloseHistoricalLoggingEntriesStream.
        * @description Required method call, at the end of a streaming session.
        * @description The memory consumption otherwise increases over time.
        */
        CloseHistoricalLoggingEntriesStream(): void;
    }
}
declare namespace VisiWin.System.Logging {
    /**
    * Entry point in the VisiWin logging system
    */
    interface ILoggingService extends VisiWin.Internal.System.IBaseClass {
        /**
        * Logging category names of the project
        */
        CategoryNames: string[];
        /**
        * Categories are used to access the parameters of a logging category and the logging events defined therein.
        */
        Categories: VisiWin.System.Logging.ILoggingCategory[];
        /**
        * method for recording a self-defined logging event
        */
        LogAsync(categoryName: string, eventName: string, logText: string): Promise<VisiWin.System.Logging.LogSuccess>;
        /**
        * Get a class representing the logging category
        */
        GetEventAsync(eventFullName: string): Promise<VisiWin.System.Logging.ILoggingEvent>;
        /**
        * Get a class representing the logging event
        */
        GetCategoryAsync(categoryFullName: string): Promise<VisiWin.System.Logging.ILoggingCategory>;
        /**
        * Method to read out logging entries
        */
        GetHistoricalLoggingEntriesAsync(filter: VisiWin.System.Logging.IHistoricalLoggingFilter): Promise<boolean>;
        /**
        * Event reporting the end of the asynchronous querying of logging events
        */
        GetHistoricalLoggingEntriesAsyncCompleted: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Logging.IHistoricalLoggingEntry[]>;
        /**
        * @method
        * CreateHistoricalLoggingFilter
        * @description The 'HistoricalLoggingFilter' describes the filter settings for querying recorded logging events.
        * @returns {   VisiWin.System.Logging.HistoricalLoggingFilter }
        */
        CreateHistoricalLoggingFilter(): VisiWin.System.Logging.IHistoricalLoggingFilter;
        /**
        * @method
        * CreateHistoricalLoggingStream
        * @description Entry point to initalize a historical data stream.
        * @returns {  VisiWin.System.Logging.HistoricalLoggingStreamRequest }
        */
        CreateHistoricalLoggingStream(): VisiWin.System.Logging.IHistoricalLoggingStreamRequest;
    }
}
declare namespace VisiWin.System.Logging {
    /**
    * The 'LoggingCategory' is used to access the parameters of a logging category and the logging events defined therein.
    */
    interface ILoggingCategory {
        /**
        * Returns the recording status of the category
        */
        Enabled: boolean;
        /**
        * Localized indentifier of the category
        */
        LocalizedName: string;
        /**
        * Name of the category
        */
        Name: string;
        /**
        * Array of Event names projected in this category
        */
        EventNames: string[];
        /**
        * Events are used to access the parameters of a logging event.
        */
        Events: ILoggingEvent[];
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
    }
}
declare namespace VisiWin.System.Logging {
    /**
    * The 'LoggingEvent' is used to access the parameters of a logging event.
    */
    interface ILoggingEvent {
        /**
        * Name of the category
        */
        CategoryName: string;
        /**
        * Returns the recording status of the logging event
        */
        Enabled: boolean;
        /**
        * Localized indentifier of the event
        */
        LocalizedName: string;
        /**
        * Name of the logging event
        */
        Name: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
    }
}
declare namespace VisiWin.System.Logging {
    /**
    * Logging event recorded by the server
    */
    interface ILoggingEntry extends VisiWin.Internal.System.IBaseClass {
        /**
        * Name of the logging category
        */
        CategoryFullName: string;
        /**
        * Name of the logging event
        */
        EventName: string;
        /**
        * Logging text
        */
        LogText: string;
    }
}
declare namespace VisiWin.System.Logging {
    /**
    * 'HistoricalLoggingEntry' encapsulates the properties of a recorded logging entry. It is used to return information on the recorded logging events.
    */
    interface IHistoricalLoggingEntry extends VisiWin.Internal.System.IBaseClass {
        /**
        * The 'ID' property determines an unequivocal numeric identifier
        */
        ID: number;
        /**
        * Name of the logging category + "." + Name of the logging event
        */
        FullName: string;
        /**
        * Name of the logging category
        */
        CategoryName: string;
        /**
        * Returns the category name in the language currently set in the application
        */
        LocalizedCategoryName: string;
        /**
        * Name of the logging event
        */
        EventName: string;
        /**
        * Returns the event name in the language currently set in the application
        */
        LocalizedEventName: string;
        /**
        * User name recorded to the entry
        */
        User: string;
        /**
        * Returns the machnie name
        */
        Machine: string;
        /**
        * Time stamp recorded to the entry
        */
        TimeStamp: Date;
        /**
        * Logging text
        */
        LocalizedText: string;
    }
}
declare namespace VisiWin.System.Logging {
    /**
    * The 'HistoricalLoggingFilter' describes the filter settings for querying recorded logging events.
    */
    interface IHistoricalLoggingFilter extends VisiWin.Internal.System.IBaseClass {
        /**
        * Array of category names
        */
        CategoryNames: string[];
        /**
        * Array of event names
        */
        EventNames: string[];
        /**
        * The 'MinTime' property determines the start point of the temporal filter. Logging events whose time stamps are younger than the value indicated here are not returned in the query.
        */
        MinTime: Date;
        /**
        * The 'MaxTime' property determines the end point of the temporal filter. Logging events whose time stamps are younger than the value indicated here are not returned in the query.
        */
        MaxTime: Date;
        /**
        * The 'Users' property determines the names of the user by which the filtering is to be conducted. Logging events whose user names differ from the value indicated here are not returned in the query.
        */
        Users: string[];
    }
}
/**
* @namespace
* @name VisiWin.System.Logging
*/
declare namespace VisiWin.System.Logging {
    /**
     * public enum LogSuccess
     *
     * @enum LogSuccess
     */
    enum LogSuccess {
        Failed = 0,
        Succeeded = 1,
        UnknownCategory = 2,
        UnknownEvent = 3,
        UnknownParameter = 4,
        Disabled = 5,
        ParameterNotSerializable = 6
    }
    /**
     * public enum HistoricalLoggingEntriesSuccess
     *
     * @enum HistoricalLoggingEntriesSuccess
     */
    enum HistoricalLoggingEntriesSuccess {
        Success = 0,
        SuccessTimeLimitArrived = 1,
        SuccessEntryLimitArrived = 2,
        CanceledByUser = 3,
        Failed = 4
    }
    /**
     * public enum ParameterType
     *
     * @enum ParameterType
     */
    enum ParameterType {
        FixedValue = 0,
        VariableValue = 1,
        VariableText = 2,
        LocalizableText = 3
    }
    enum ItemModifiedCause {
        Changed = 0,
        Added = 1,
        Removed = 2
    }
    enum HistoricalLogEntryColumns {
        CategoryFullName = 0,
        EventName = 1,
        Timestamp = 2,
        User = 3,
        Machine = 4,
        FileName = 5,
        RowNum = 6
    }
    enum HistoricalLogNotesColumns {
        Id = 0,
        User = 1,
        Timestamp = 2
    }
}
/**
* @namespace
* @name VisiWin.System.Logging
*/
declare namespace VisiWin.System.Logging {
    /**
    * @class
    * @name VisiWin.System.Logging.LoggingService
    * @description Entry point into the logging management.
    * @memberof VisiWin.System.Logging
    */
    class LoggingService extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Logging.ILoggingService {
        static getService(): LoggingService;
        /**
        * Logging category names of the project
        */
        CategoryNames: string[];
        /**
        * Categories are used to access the parameters of a logging category and the logging events defined therein.
        */
        Categories: VisiWin.System.Logging.ILoggingCategory[];
        /**
        * Event reporting the end of the asynchronous querying of logging events
        */
        GetHistoricalLoggingEntriesAsyncCompleted: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Logging.IHistoricalLoggingEntry[]>;
        /**
        * method for recording a self-defined logging event
        */
        LogAsync(categoryName: string, eventName: string, logText: string): Promise<VisiWin.System.Logging.LogSuccess>;
        /**
        * Get a class representing the logging category
        */
        GetEventAsync(eventFullName: string): Promise<VisiWin.System.Logging.ILoggingEvent>;
        /**
        * Get a class representing the logging event
        */
        GetCategoryAsync(categoryFullName: string): Promise<VisiWin.System.Logging.ILoggingCategory>;
        /**
        * Method to read out logging entries
        */
        GetHistoricalLoggingEntriesAsync(filter: VisiWin.System.Logging.IHistoricalLoggingFilter): Promise<boolean>;
        /**
        * @method
        * CreateHistoricalLoggingFilter
        * @description The 'HistoricalLoggingFilter' describes the filter settings for querying recorded logging events.
        * @returns {   VisiWin.System.Logging.HistoricalLoggingFilter }
        */
        CreateHistoricalLoggingFilter(): VisiWin.System.Logging.IHistoricalLoggingFilter;
        /**
        * @method
        * CreateHistoricalLoggingStream
        * @description Entry point to initalize a historical data stream.
        * @returns {  VisiWin.System.Logging.HistoricalLoggingStreamRequest }
        */
        CreateHistoricalLoggingStream(): VisiWin.System.Logging.IHistoricalLoggingStreamRequest;
    }
}
/**
* @namespace
* @name VisiWin.System.Logging
*/
declare namespace VisiWin.System.Logging {
    /**
    * @class
    * @name VisiWin.System.Logging.LoggingEntry
    * @description
    * @memberof VisiWin.System.Logging
    */
    abstract class LoggingEntry extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Logging.ILoggingEntry {
        CategoryFullName: string;
        EventName: string;
        LogText: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Logging
*/
declare namespace VisiWin.System.Logging {
    /**
    * @class
    * @name VisiWin.System.Logging.HistoricalLoggingFilter
    * @description
    * @memberof VisiWin.System.Logging
    */
    abstract class HistoricalLoggingFilter extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Logging.IHistoricalLoggingFilter {
        CategoryNames: string[];
        EventNames: string[];
        MinTime: Date;
        MaxTime: Date;
        Users: string[];
    }
}
/**
* @namespace
* @name VisiWin.System.Logging
*/
declare namespace VisiWin.System.Logging {
    /**
    * @class
    * @name VisiWin.System.Logging.LoggingSeHistoricalLoggingEntryrvice
    * @description
    * @memberof VisiWin.System.Logging
    */
    abstract class HistoricalLoggingEntry extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Logging.IHistoricalLoggingEntry {
        ID: number;
        FullName: string;
        CategoryName: string;
        LocalizedCategoryName: string;
        EventName: string;
        LocalizedEventName: string;
        User: string;
        Machine: string;
        TimeStamp: Date;
        LocalizedText: string;
    }
}
declare namespace VisiWin.System.Project {
    /**
     * @class VisiWin.System.Project.IProjectService
     * @description Class for starting the VisiWin project. Access to global properties of the project.
     * @memberof VisiWin.System.Project
     */
    interface IProjectService extends VisiWin.Internal.System.IBaseClass {
        /**
         * @description Returns the name of the server project
         * @member { string } ServerProjectName
         */
        ServerProjectName: string;
        /**
         * @description Returns the current state of the server project
         * @member { enum } VisiWin.System.Project.ServerRuntimeStatus
         */
        ServerProjectRuntimeState: VisiWin.System.Project.ServerRuntimeStatus;
        /**
         * @description ServerProjectStateChange the server project state changed
         * @event ProjectService#ServerProjectStateChange
         * @type {object}
         * @property {VisiWin.System.Project.ServerRuntimeStatus}
         */
        ServerProjectStateChange: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Project.ServerRuntimeStatus>;
        /**
         * @description ServerProjectStateChange the server project state changed
         * @event ProjectService#onServerError
         * @type {object}
         * @property {VisiWin.System.Project.IOnServerErrorEventArgs}
         */
        onServerError: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Project.IOnServerErrorEventArgs>;
        /**
         * @function RunProjectAsync
         * @description Starts the VisiWin project on the server
         * @returns { Promise<VisiWin.System.Project.ServerRuntimeStatus> }
         */
        RunProjectAsync(): Promise<VisiWin.System.Project.ServerRuntimeStatus>;
    }
    /**
     * @ignore
     */
    interface IProject {
        ServerProjectName: string;
    }
    /**
     * @description IOnServerErrorEventArgs change arguments for the server error event
     */
    interface IOnServerErrorEventArgs {
        /**
         * Error string
         * @member { string } Error
         */
        Error: string;
        /**
         * Server state
         * @member { enum } RuntimeState
         */
        RuntimeState: VisiWin.System.Project.ServerRuntimeStatus;
        /**
         * ProjectName
         * @member { string } ProjectName
         */
        ProjectName: string;
        /**
         * RuntimeStatus
         * ServerRuntimeStatus as string
         * @member { string } RuntimeStatus
         */
        RuntimeStatus: string;
    }
    /**
     * @ignore
     */
    interface IRRunProject {
        Result: string;
        RequestID: VisiWin.IGuid;
        Succeeded: boolean;
    }
}
declare namespace VisiWin.System.Project {
    /**
     * @class VisiWin.System.Project.ProjectService
     * @description Class for starting the VisiWin project. Access to global properties of the project.
     * @memberof VisiWin.System.Project
     */
    class ProjectService extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Project.IProjectService {
        /**
         * @function getService
         * @description Get an instance of the service
         * @static
         * @returns { VisiWin.System.Project.IProjectService }
         */
        static getService(): VisiWin.System.Project.IProjectService;
        /**
         * @description Returns the name of the server project
         * @member { string } ServerProjectName
         */
        ServerProjectName: string;
        /**
         * @description Returns the current state of the server project
         * @member { enum } VisiWin.System.Project.ServerRuntimeStatus
         */
        ServerProjectRuntimeState: VisiWin.System.Project.ServerRuntimeStatus;
        /**
         * @description ServerProjectStateChange the server project state changed
         * @event ProjectService#ServerProjectStateChange
         * @type {object}
         * @property {VisiWin.System.Project.ServerRuntimeStatus}
         */
        ServerProjectStateChange: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Project.ServerRuntimeStatus>;
        /**
         * @description ServerProjectStateChange the server project state changed
         * @event ProjectService#onServerError
         * @type {object}
         * @property {VisiWin.System.Project.IOnServerErrorEventArgs}
         */
        onServerError: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Project.IOnServerErrorEventArgs>;
        /**
         * @function RunProjectAsync
         * @description Starts the VisiWin project on the server
         * @returns { Promise<VisiWin.System.Project.ServerRuntimeStatus> }
         */
        RunProjectAsync(): Promise<VisiWin.System.Project.ServerRuntimeStatus>;
    }
}
declare namespace VisiWin.System.Project {
    /**
     * Enumeration of the status of the server project
     * public enum ServerRuntimeStatus
     * @enum ServerRuntimeStatus
     */
    enum ServerRuntimeStatus {
        Unloaded = 0,
        Loaded = 1,
        Starting = 2,
        Running = 3,
        Stopped = 4,
        OnExit = 5,
        ErrorOnLoading = 6,
        RunningWithTimeout = 7,
        RunningWithError = 8,
        ErrorOnStarting = 9,
        ErrorWatchDog = 10,
        ErrorUnhandledException = 11,
        ErrorFatal = 12,
        ErrorDoesNotExist = 13,
        ErrorNoConfiguration = 14,
        ErrorHostConnectionLost = 15,
        ErrorNoLicense = 16,
        ErrorNoRuntime = 17,
        ErrorPowerDown = 18,
        InvalidProjectRegistration = 19
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IMemberError
    * @description If the use of a variable fails
    * @memberof VisiWin.System.Recipe
    */
    interface IMemberError {
        /**
        * Name of the problematic variable
        */
        VariableName: string;
        /**
        * RecipeMemberErrorCode Enum.
        */
        ErrorCode: VisiWin.System.Recipe.RecipeMemberErrorCode;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeActionResult
    * @description Contains information about the execution of a recipe action.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeActionResult {
        /**
        * Contains information about changing a recipe.
        * @member { VisiWin.System.Recipe.IRecipeResultData } Data
        */
        Data: VisiWin.System.Recipe.IRecipeResultData;
        /**
        * Contains information about changing the subrecipes.
        * @member { VisiWin.System.Recipe.IRecipeResultData[] } SubRecipesData
        */
        SubRecipesData: VisiWin.System.Recipe.IRecipeResultData[];
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeBufferChangedEventArgs
    * @description Contains information about the recipe buffer change event.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeBufferChangedEventArgs {
        /**
        * Enumeration of recipe change actions
        * @member { VisiWin.System.Recipe.RecipeChangedAction } Action
        */
        Action: VisiWin.System.Recipe.RecipeChangedAction | null;
        /**
        * Enumeration of sources of a recipe change
        * @member { VisiWin.System.Recipe.RecipeChangedSource } Source
        */
        Source: VisiWin.System.Recipe.RecipeChangedSource | null;
        /**
        *  Contains information about changing a recipe.
        * @member { VisiWin.System.Recipe.IRecipeResultData } Result
        */
        Result: VisiWin.System.Recipe.IRecipeResultData;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
      * @class
      * @name VisiWin.System.Recipe.IRecipeChange
      * @description Class that encapsulates a recipe value change recorded by the change history.
      * @memberof VisiWin.System.Recipe
      */
    interface IRecipeChange {
        /**
        * New recorded value of the variable.
        * @member { VisiWin.System.DataAccess.VariantType } NewValue
        */
        NewValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Prior recorded value of the variable.
        * @member { VisiWin.System.DataAccess.VariantType } OldValue
        */
        OldValue: VisiWin.System.DataAccess.VariantType;
        /**
        * Returns the time stamp that was passed when the note was added.
        * @member { date } Timestamp
        */
        Timestamp: Date;
        /**
        * Indicates the name of the user who was logged on with the application when the note was added.
        * @member { string } UserName
        */
        UserName: string;
        /**
        * The name of the varibale
        * @member { string } VariableName
        */
        VariableName: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
      * @class
      * @name VisiWin.System.Recipe.IRecipeChangeFilter
      * @description Filter for the GetChanges call in IRecipeFile or IRecipeClass
      * @memberof VisiWin.System.Recipe
      */
    interface IRecipeChangeFilter {
        /**
        * UserName
        * @member { string } UserName
        */
        UserName: string;
        /**
        * MachineName
        * @member { string } MachineName
        */
        MachineName: string;
        /**
        * Sets the final point of the time filter.
        * @member { date } MaxTime
        */
        MaxTime: Date;
        /**
        * Sets the starting point of the time filter.
        * @member { date } MinTime
        */
        MinTime: Date;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.RecipeClass
    * @description Class for access to a recipe
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeClass extends VisiWin.Internal.System.IBaseClass {
        /**
        * LockStateChanged the recipe object blocked changed
        * @event RecipeClass#LockStateChanged
        * @type {object}
        * @property {VisiWin.System.Recipe.IRecipeLockStateChangedEventArgs}
        */
        LockStateChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Recipe.IRecipeLockStateChangedEventArgs>;
        /**
        * SubRecipes of the RecipeClass
        * @member { VisiWin.System.Recipe.ISubRecipe[] } SubRecipes
        */
        SubRecipes: VisiWin.System.Recipe.ISubRecipe[];
        /**
        * Name of recipe definition
        * @member { string } Name
        */
        Name: string;
        /**
        * FileNames of the RecipeClass
        * @member { string [] } FileNames
        */
        FileNames: string[];
        /**
        * @function GetFileNamesAsync
        * @description List of all recipe file names in the current directory
        * @returns { Promise<string[]> }
        */
        GetFileNamesAsync(): Promise<string[]>;
        /**
        * Returns whether the recipe object is blocked
        * @member { VisiWin.System.Recipe.RecipeLockState[] } LockState
        */
        LockState: VisiWin.System.Recipe.RecipeLockState;
        /**
        * @function GetRecipeFileAsync
        * @description Get the recipe file from a given recipe class name
        * @param { string } recipeFileName Name of the requested file
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeFileResult> }
        */
        GetRecipeFileAsync(recipeFileName: string): Promise<VisiWin.System.Recipe.IGetRecipeFileResult>;
        /**
        * @function GetVariableNamesAsync
        * @description Returns the variable names of the recipe elements.
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassGetVariableNamesResult> }
        */
        GetVariableNamesAsync(): Promise<VisiWin.System.Recipe.IRecipeClassGetVariableNamesResult>;
        /**@function GetValueAsync
        * @description Allows reading a value from the recipe cache.
        * @param { string } variableName Designator of the process variable.
        * @returns {Promise<VisiWin.System.Recipe.IRecipeClassGetValueResult>>} the result of the operation.
        */
        GetValueAsync(variableName: string): Promise<VisiWin.System.Recipe.IRecipeClassGetValueResult>;
        /**@function GetValuesAsync
        * @description Allows reading multiple values from the recipe cache
        * @param { string[] } variableNames Array of recipe element designators. If variableName not set, the values from all variables are retrieved.
        * @returns {Promise<VisiWin.System.Recipe.IRecipeClassGetValuesResult>>}
        */
        GetValuesAsync(variableNames?: string[]): Promise<VisiWin.System.Recipe.IRecipeClassGetValuesResult>;
        GetValuesAsync(variableNames: string[]): Promise<VisiWin.System.Recipe.IRecipeClassGetValuesResult>;
        /**
        * @function LoadFromFileToBufferAsync
        * @deprecated use LoadFileToBufferAsync
        * @description Loads the recipe values from a file into the recipe cache
        * @param { string } fileName Name of recipe file
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassLoadFromFileToBufferResult> }
        */
        LoadFromFileToBufferAsync(fileName: string): Promise<VisiWin.System.Recipe.IRecipeClassLoadFromFileToBufferResult>;
        /**
         * @function LoadFileToBufferAsync
         * @description Loads the recipe values from a file into the recipe buffer
         * @param { string } fileName Recipe file name (without path and extension)
         * @param { boolean } normalized Recipe values can be interpreted absolutely or relatively.
         * @returns { Promise<VisiWin.System.Recipe.ILoadFileToBufferResult> }
         */
        LoadFileToBufferAsync(fileName: string, normalized?: boolean): Promise<VisiWin.System.Recipe.ILoadFileToBufferResult>;
        /**
        * @function LoadFromFileToProcessAsync
        * @deprecated use LoadFromFileToProcessAsync
        * @description Loads the recipe values from a file into the process
        * @param { string } fileName Name of recipe file
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassLoadFromFileToProcessResult> }
        */
        LoadFromFileToProcessAsync(fileName: string): Promise<VisiWin.System.Recipe.IRecipeClassLoadFromFileToProcessResult>;
        /**
         * @function LoadFileToProcessAsync
         * @description Loads the recipe values from a file directly into the variable core without detour via the recipe buffer.
         * @param { string } fileName Recipe file name (without path and extension).
         * @param { boolean } normalized Recipe values can be interpreted absolutely or relatively.
         * @returns { Promise<VisiWin.System.Recipe.ILoadFileToProcessResult> }
         */
        LoadFileToProcessAsync(fileName: string, normalized?: boolean): Promise<VisiWin.System.Recipe.ILoadFileToProcessResult>;
        /**
        * @function ReadProcessToBufferAsync
        * @description Loads the recipe values from the process into the recipe buffer
        * @returns { VisiWin.System.Recipe.IRecipeClassReadProcessToBufferResult }
        */
        ReadProcessToBufferAsync(): Promise<VisiWin.System.Recipe.IRecipeClassReadProcessToBufferResult>;
        /**
        * @function SetValueAsync
        * @description Writes a value into the recipe cache.
        * @param { string } variableName Designator of the recipe element whose new value is to be written
        * @param { VisiWin.System.DataAccess.VariantType } recipeValue the recipe element value to be written
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassSetValueResult> }
        */
        SetValueAsync(variableName: string, recipeValue: VisiWin.System.DataAccess.VariantType): Promise<VisiWin.System.Recipe.IRecipeClassSetValueResult>;
        /**
        * @function SetValuesAsync
        * @description Writes a value into the recipe cache.
        * The 'SetValuesAsync' method writes multiple values into the recipe cache.
        * @param { string[] } variableNames Field of recipe element designators
        * @param { VisiWin.System.DataAccess.VariantType[] } recipeValues array containing the recipe element values to be written
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassSetValueResult[]> }
        */
        SetValuesAsync(variableNames: string[], recipeValues: VisiWin.System.DataAccess.VariantType[]): Promise<VisiWin.System.Recipe.IRecipeClassSetValueResult[]>;
        /**
       * @function SaveToFileFromBufferAsync
       * @deprecated use SaveBufferToFileAsync
       * @description Saves the current values of the recipe cache in the recipe file indicated in the 'fileName' parameter.
       * @param { string } fileName Name of recipe file
       * @param { string } description Description of recipe file
       * @param { string } forceOverwrite True: If the recipe file indicated in the 'fileName' parameter already exists the values in this file are overwritten. Default=false.
       * @returns { Promise<VisiWin.System.Recipe.IRecipeClassLoadFromFileToProcessResult> }
       */
        SaveToFileFromBufferAsync(fileName: string, description: string, forceOverwrite: boolean): Promise<VisiWin.System.Recipe.IRecipeClassSaveToFileFromBufferResult>;
        /**
         * @function SaveBufferToFileAsync
         * @description Saves the recipe values from the buffer as a file.
         * @param { string } fileName Recipe file name (without path and extension).
         * @param { string } description description
         * @param { boolean } forceOverwrite True: If the recipe file specified in the 'fileName' parameter already exists, the values in this file will be overwritten.
         * @param { boolean } normalized Recipe values can be interpreted absolutely or relatively.
         * @returns { Promise<VisiWin.System.Recipe.ISaveBufferToFileResult> }
         */
        SaveBufferToFileAsync(fileName: string, description: string, forceOverwrite: boolean, normalized: boolean): Promise<VisiWin.System.Recipe.ISaveBufferToFileResult>;
        /**
        * @function WriteBufferToProcessAsync
        * @description Writes the current buffer values into the process
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassWriteBufferToProcessResult> }
        */
        WriteBufferToProcessAsync(): Promise<VisiWin.System.Recipe.IRecipeClassWriteBufferToProcessResult>;
        /**
         * @function GetChangesAsync
         * The 'GetChangesAsync' method returns the information of the change history for the given file.
         * @param { string } fileName Name of recipe file
         * @returns { Promise<VisiWin.System.Recipe.IGetChangesResult> }
         */
        GetChangesAsync(fileName?: string, filter?: VisiWin.System.Recipe.RecipeChangeFilter): Promise<VisiWin.System.Recipe.IGetChangesResult>;
        /**
         * @function AddNoteAsync
         * The 'AddNoteAsync' method adds a new note to the loaded recipe into the recipe buffer.
         * @param { string } note string of the note to be added
         * @returns { Promise<VisiWin.System.Recipe.IAddNoteResult> }
         */
        AddNoteAsync(note: string): Promise<VisiWin.System.Recipe.IAddNoteResult>;
        AddNoteAsync(note: string, timestamp: Date): Promise<VisiWin.System.Recipe.IAddNoteResult>;
        /**
         * @function GetNotesAsync
         * The 'GetNotesAsync' method returns the notes for the file loaded in the recipe buffer.
         * @param { string } fileName Name of recipe file
         * @returns { Promise<VisiWin.System.Recipe.IGetNotesResult> }
         */
        GetNotesAsync(): Promise<VisiWin.System.Recipe.IGetNotesResult>;
        GetNotesAsync(fileName?: string): Promise<VisiWin.System.Recipe.IGetNotesResult>;
        GetNotesAsync(fileName?: string, filter?: VisiWin.System.Recipe.IRecipeNotesFilter): Promise<VisiWin.System.Recipe.IGetNotesResult>;
        /**
         * @function ClearChangesAsync
         * The 'ClearChangesAsync' method deletes all information on recipe changes.
         * @returns { Promise<VisiWin.System.Recipe.IClearChangesResult> }
         */
        ClearChangesAsync(): Promise<VisiWin.System.Recipe.IClearChangesResult>;
        /**
         * @function ClearNotesAsync
         * The 'ClearNotesAsync' method deletes all recipe notes.
         * @returns { Promise<VisiWin.System.Recipe.IClearNotesResult> }
         */
        ClearNotesAsync(): Promise<VisiWin.System.Recipe.IClearNotesResult>;
        /**
         * @function LockRecipeAsync
         * The 'LockRecipeAsync' method locks a recipe class on the server against changes from other clients.
         * @returns { Promise<VisiWin.System.Recipe.ILockRecipeResult> }
         */
        LockRecipeAsync(timeout?: number): Promise<VisiWin.System.Recipe.ILockRecipeResult>;
        /**
         * @function UnlockRecipeAsync
         * The 'UnlockRecipeAsync' method unlocks a recipe class on the server.
         * @returns { Promise<VisiWin.System.Recipe.IUnlockRecipeResult> }
         */
        UnlockRecipeAsync(): Promise<VisiWin.System.Recipe.IUnlockRecipeResult>;
        UnlockRecipeAsync(forece: boolean): Promise<VisiWin.System.Recipe.IUnlockRecipeResult>;
        /**
         * @function GetSubRecipesAsync
         * The 'GetSubRecipesAsync' method returns the subrecipes of the class.
         * @returns { Promise<VisiWin.System.Recipe.IGetSubRecipesResult> }
         */
        GetSubRecipesAsync(): Promise<VisiWin.System.Recipe.IGetSubRecipesResult>;
        /**
         * @function DeleteFileAsync
         * @description Deletes the given file.
         * @param { string } fileName Name of recipe file wich is to be deleted.
         * @returns { Promise<VisiWin.System.Recipe.IDeleteFileResult> }
         */
        DeleteFileAsync(fileName: string): Promise<VisiWin.System.Recipe.IDeleteFileResult>;
        /**
        * Indicates whether the recipe edit mode is active
        * @member { boolean } IsEditing
        */
        IsEditing: boolean;
        /**
        * Localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Comment
        * available with WebGatewayProtocolVersion >= 19 (2022-3)
        * available with CP Server
        * @member { string } Comment
        */
        Comment: string;
        /**
        * Save subrecipe class values here
        * @member { boolean } IncludeSubRecipesInStorage
        */
        IncludeSubRecipesInStorage: boolean;
        /**
        * Directory
        * @member { string } InitialDirectory
        */
        InitialDirectory: string;
        /**
        * Inital rcipe description
        * @member { string } InitialRecipeDescription
        */
        InitialRecipeDescription: string;
        /**
        * Recipe name.
        * @member { string } InitialRecipeName
        */
        InitialRecipeName: string;
        /**
        * Indicates if there are changes for the file.
        * @member { boolean } HasChangesForFile
        */
        HasChangesForFile: boolean;
        /**
        * Indicates if there are changes for the process.
        * @member { boolean } HasChangesForProcess
        */
        HasChangesForProcess: boolean;
        /**
        * Specifies whether the recipe uses a common recipe buffer for all clients
        * @member { boolean } IsServerSideRecipe
        */
        IsServerSideRecipe: boolean;
        /**
        * The last recipe that was loaded into the buffer
        * @member { VisiWin.System.Recipe.IRecipeInfoDetails } LastRecipeLoadedToBuffer
        */
        LastRecipeLoadedToBuffer: VisiWin.System.Recipe.IRecipeInfoDetails;
        /**
        * The last recipe that was saved to file.
        * @member { VisiWin.System.Recipe.IRecipeInfoDetails } LastRecipeSavedToFile
        */
        LastRecipeSavedToFile: VisiWin.System.Recipe.IRecipeInfoDetails;
        /**
        * The last recipe that was sent to process.
        * @member { VisiWin.System.Recipe.IRecipeInfoDetails } LastRecipeSentToProcess
        */
        LastRecipeSentToProcess: VisiWin.System.Recipe.IRecipeInfoDetails;
        /**
        * Load last recipe file at startup
        * @member { boolean } LoadOnStartup
        */
        LoadOnStartup: boolean;
        /**
        * Logging category name
        * @member { string } LoggingCategoryName
        */
        LoggingCategoryName: string;
        /**
        * Read modified variable server values directly
        * @member { boolean } ReadValuesOnProcessChange
        */
        ReadValuesOnProcessChange: boolean;
        /**
        *  Save changed values directly
        * @member { boolean } SaveRecipeValueChanges
        */
        SaveRecipeValueChanges: boolean;
        /**
        * Save changed variable server values directly
        * @member { boolean } SaveRecipeValuesOnChange
        */
        SaveRecipeValuesOnChange: boolean;
        /**
        * Save changed values directly
        * @member { boolean } SetRecipeValuesToProcessOnChange
        */
        SetRecipeValuesToProcessOnChange: boolean;
        /**
        * The current path.
        * @member { string } CurrentPath
        */
        CurrentPath: string;
        /**
        * The recipe buffer changed.
        * @event RecipeClass#BufferChanged
        * @type {object}
        * @property {VisiWin.System.Recipe.IRecipeBufferChangedEventArgs}
        */
        BufferChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Recipe.IRecipeBufferChangedEventArgs>;
        /**
        * The recipe file changed.
        * @event RecipeClass#FilesChanged
        * @type {object}
        * @property {VisiWin.System.Recipe.IRecipeFilesChangedEventArgs}
        */
        FilesChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Recipe.IRecipeFilesChangedEventArgs>;
        /**
        * LockStateChanged the recipe object blocked changed
        * @event RecipeClass#WrittenToProcess
        * @type {object}
        * @property {VisiWin.System.Recipe.IRecipeWrittenToProcessEventArgs}
        */
        WrittenToProcess: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Recipe.IRecipeWrittenToProcessEventArgs>;
        /**
         * @function GetCurrentPathAsync
         * @description Returns the current path of the recipe files
         * @returns { Promise<string> }
         */
        GetCurrentPathAsync(): Promise<string>;
        /**
         * @function GetMemberDefinitionsAsync
         * @description Returns a listing of the associated member definitions
         * @returns { Promise<VisiWin.System.Recipe.IRecipeMemberDefinition[]> }
         */
        GetMemberDefinitionsAsync(): Promise<VisiWin.System.Recipe.IRecipeMemberDefinition[]>;
        /**
         * @function IsExistingRecipeFileAsync
         * @description Returns if the specified recipe file exists
         * @param { string } fileName File name to check
         * @returns { Promise<boolean> }
         */
        IsExistingRecipeFileAsync(fileName: string): Promise<boolean>;
        /**
         * @function SetDefaultValuesToBufferAsync
         * @description Sets the default values from the project file into the recipe buffer.
         * @param { VisiWin.System.Recipe.ClearBufferDefaultValues } defaultValues  Possible default value for ClearBuffer
         * @param { boolean } recursive
         * @returns { Promise<VisiWin.System.Recipe.ISetDefaultValuesToBufferResult> }
         */
        SetDefaultValuesToBufferAsync(defaultValues: VisiWin.System.Recipe.ClearBufferDefaultValues, recursive: boolean): Promise<VisiWin.System.Recipe.ISetDefaultValuesToBufferResult>;
        /**
         * @function StartEditAsync
         * @description Starts the recipe editing mode.
         * @returns { Promise<boolean> }
         */
        StartEditAsync(): Promise<boolean>;
        /**
         * @function StopEditAsync
         * @description Starts the recipe editing mode.
         * @returns { Promise<boolean> }
         */
        StopEditAsync(): Promise<boolean>;
        /**
         * @function RemoveNoteAsync
         * @description Deletes a note from the recipe buffer
         * @param { number } id Note identifier
         * @returns { Promise<boolean> }
         */
        RemoveNoteAsync(id: number): Promise<boolean>;
        /**
         * @function SetCurrentPathAsync
         * @description Sets the current path of the recipe files
         * @param { string } value
         * @returns { Promise<boolean> }
         */
        SetCurrentPathAsync(value: string): Promise<VisiWin.System.Recipe.ChangeDirectorySuccess>;
        /**
         * @function GetRecipeClassDefinitionAsync
         * @description Retrieves the definition for a recipe class.
         * @param { string } className
         * @returns { Promise<VisiWin.System.Recipe.IRecipeClassDefinition> }
         */
        GetRecipeClassDefinitionAsync(className: string): Promise<VisiWin.System.Recipe.IRecipeClassDefinition>;
        /**
        * @function GetRecipeLockStateAsync
        * @description Retrieving the lock state of the recipe class
        * @returns { Promise<VisiWin.System.Recipe.RecipeLockState> }
        */
        GetRecipeLockStateAsync(): Promise<VisiWin.System.Recipe.RecipeLockState>;
    }
    /**
    * Files of the RecipeClass
    * @member { VisiWin.System.Recipe.IRecipeFile[] } Files
    */
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeClassDefinition
    * @description Recipe class definition.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeClassDefinition {
        /**
        * Name of the recipe class.
        * @member { string } Name
        */
        Name: string;
        /**
        * Listing of recipe subclasses.
        * @member { VisiWin.System.Recipe.IRecipeSubClassDefinition[ } SubClasses
        */
        SubClasses: VisiWin.System.Recipe.IRecipeSubClassDefinition[];
        /**
        * Initial recipe file configuration.
        * @member { VisiWin.System.Recipe.IStorageHandlerConfiguration } InitialRecipeFileConfiguration
        */
        InitialRecipeFileConfiguration: VisiWin.System.Recipe.IStorageHandlerConfiguration;
        /**
        * Inital rcipe description
        * @member { string } InitialRecipeDescription
        */
        InitialRecipeDescription: string;
        /**
        * Save subrecipe class values here
        * @member { boolean } IncludeSubRecipesInStorage
        */
        IncludeSubRecipesInStorage: boolean;
        /**
        * Description of the recipe members.
        * @member { VisiWin.System.Recipe.IRecipeMemberDefinition[] } MemberDefinitions
        */
        MemberDefinitions: VisiWin.System.Recipe.IRecipeMemberDefinition[];
        /**
        * Localizable text
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Comment
        * @member { string } Comment
        */
        Comment: string;
        /**
        * Specifies whether the recipe uses a common recipe buffer for all clients
        * @member { boolean } IsServerSideRecipe
        */
        IsServerSideRecipe: boolean;
        /**
        * Load last recipe file at startup
        * @member { boolean } LoadOnStartup
        */
        LoadOnStartup: boolean;
        /**
        *  Save changed values directly
        * @member { boolean } SaveRecipeValueChanges
        */
        SaveRecipeValueChanges: boolean;
        /**
        * Save changed values directly
        * @member { boolean } SetRecipeValuesToProcessOnChange
        */
        SetRecipeValuesToProcessOnChange: boolean;
        /**
        * Save changed variable server values directly
        * @member { boolean } SaveRecipeValuesOnChange
        */
        SaveRecipeValuesOnChange: boolean;
        /**
        * Read modified variable server values directly
        * @member { boolean } ReadValuesOnProcessChange
        */
        ReadValuesOnProcessChange: boolean;
        /**
        * Logging category name
        * @member { string } LoggingCategoryName
        */
        LoggingCategoryName: string;
        /**
        * Directory
        * @member { string } InitialDirectory
        */
        InitialDirectory: string;
        /**
        * Recipe name.
        * @member { string } InitialRecipeName
        */
        InitialRecipeName: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.RecipeFile
    * @description Encapsulates the information of a recipe file
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeFile extends VisiWin.Internal.System.IBaseClass {
        /**
        * Returns the description to the file
        * @member { string } Description
        */
        Description: string;
        /**
        * Returns the name of the file
        * @member { String } FileName
        */
        FileName: string;
        /**
        * Name of recipe definition
        * @member { string } RecipeClassName
        */
        RecipeClassName: string;
        /**
        * Returns the date of the latest file change
        * @member { Date } TimeOfLastChange
        */
        TimeOfLastChange: Date;
        /**
        * Returns the name of the user how saved the recipe
        * @member { string } WhoSavedRecipe
        */
        WhoSavedRecipe: string;
        /**
         * @function GetChangesAsync
         * @discription The method returns the information of the change history for the file currently loaded in the recipe buffer.
         * @param { VisiWin.System.Recipe.RecipeChangeFilter } recipeChangeFilter
         * @returns { Promise<VisiWin.System.Recipe.IGetChangesResult> }
         */
        GetChangesAsync(): Promise<VisiWin.System.Recipe.IGetChangesResult>;
        GetChangesAsync(recipeChangeFilter?: VisiWin.System.Recipe.RecipeChangeFilter): Promise<VisiWin.System.Recipe.IGetChangesResult>;
        /**
        * @function GetNotesAsync
        * @discription The method returns the notes for the file loaded in the recipe buffer.
        * @param { VisiWin.System.Recipe.IRecipeNotesFilter } recipeNotesFilter
        * @returns { Promise<VisiWin.System.Recipe.IGetNotesResult> }
        */
        GetNotesAsync(): Promise<VisiWin.System.Recipe.IGetNotesResult>;
        GetNotesAsync(recipeNotesFilter?: VisiWin.System.Recipe.IRecipeNotesFilter): Promise<VisiWin.System.Recipe.IGetNotesResult>;
        /**
        * Returns the name of the user who saved the file
        * available with WebGatewayProtocolVersion >= 19 (2022-3)
        * available with CP Server
        * @member { String } SavedByUser
        */
        SavedByUser: string;
        /**
        * Returns the name of the server who saved the file
        * available with WebGatewayProtocolVersion >= 19 (2022-3)
        * available with CP Server
        * @member { String } SavedByMachine
        */
        SavedByMachine: string;
        /**
        * @function GetValuesAsync
        * @discription Returns all values in the recipe as a list
        * @param { boolean } normalized
        * @returns { Promise<VisiWin.System.Recipe.IRecipeValue[]> }
        */
        GetValuesAsync(normalized?: boolean): Promise<VisiWin.System.Recipe.IRecipeValue[]>;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeFilesChangedEventArgs
    * @description Class that encapsulates a recipe file change event args.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeFilesChangedEventArgs {
        /**
        * Enumeration of file action
        */
        FileAction: VisiWin.System.Recipe.FileAction;
        /**
        * ClassName
        * @member { string } ClassName
        */
        ClassName: string;
        /**
        * Directory
        * @member { string } Directory
        */
        Directory: string;
        /**
        * User
        * @member { string } User
        */
        User: string;
        /**
        * Machine
        * @member { string } Machine
        */
        Machine: string;
        /**
        * Name
        * @member { string } Name
        */
        Name: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeInfoDetails
    * @description Contains information details about the recipe.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeInfoDetails {
        /**
        * The directory for recipes
        */
        Directory: string;
        /**
        * The recipe name
        */
        Name: string;
        /**
        * The recipe description
        */
        Description: string;
        /**
        * Latest timestamp for the recipe
        */
        Timestamp: Date;
        /**
        * The user who edited the recipe
        */
        User: string;
        /**
        * The machine name
        */
        Machine: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeLockStateChangedEventArgs
    * @description Class that encapsulates a recipe lock state change event.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeLockStateChangedEventArgs {
        /**
        * Enumeration for the recipe lock state.
        */
        LockState: RecipeLockState;
        /**
        * The recipe class name.
        * @member { string } RecipeClassName
        */
        RecipeClassName: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeMemberDefinition
    * @description Description of the recipe members.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeMemberDefinition {
        /**
        * Full qualified variable name.
        * @member { string } VariableFullName
        */
        VariableFullName: string;
        /**
        * Default value. Used when SetDefaultValuesToBufferAsync is called.
        * @member { VisiWin.System.DataAccess.VariantType } DefaultValue
        */
        DefaultValue?: VisiWin.System.DataAccess.VariantType;
        /**
        * Sort order in the display.
        * @member { number } SortIndex
        */
        SortIndex: number;
        /**
        * Localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Comment
        * @member { string } Comment
        */
        Comment: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeMemberResult
    * @description Result for the recipe members.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeMemberResult {
        /**
        * Recipe member.
        * @member { string } Member
        */
        Member: string;
        /**
        * Enumeration containing the possible causes of errors when handling a value from a recipe.
        * @member { VisiWin.System.Recipe.RecipeErrorCode } ErrorCode
        */
        ErrorCode: VisiWin.System.Recipe.RecipeErrorCode;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
      * @class
      * @name VisiWin.System.Recipe.IRecipeNote
      * @description Class that encapsulates the information of a note in a recipe file.
      * @memberof VisiWin.System.Recipe
      */
    interface IRecipeNote {
        /**
        * Returns the unique identifier of the note within the recipe buffer
        * @member { number } Id
        */
        Id: number;
        /**
        * Returns the text of the note
        * @member { string } Text
        */
        Text: string;
        /**
        * Returns the timestamp passed when adding the note.
        * @member { date } Timestamp
        */
        Timestamp: Date;
        /**
        * Specifies the login name of the user who was logged in at the time the note was added. was logged into the application.
        * @member { string } UserName
        */
        UserName: string;
        /**
        * Returns the machine name.
        * @member { string } MachineName
        */
        MachineName: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeNoteChange
    * @description Recipe note change information.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeNoteChange {
        /**
        * Recipe notes change action.
        * @member { VisiWin.System.Recipe.RecipeNotesChangeAction } Action
        */
        Action: VisiWin.System.Recipe.RecipeNotesChangeAction;
        /**
        * Class that encapsulates the information of a note in a recipe file.
        * @member { VisiWin.System.Recipe.IRecipeNote } Note
        */
        Note: VisiWin.System.Recipe.IRecipeNote | null;
        /**
        * Recipe class name.
        * @member { string } Class
        */
        Class: string;
        /**
        * Recipe class name.
        * @member { string } Recipe
        */
        Recipe: string;
    }
}
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeNotesFilter
    * @description Filter for recipe notes.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeNotesFilter {
        /**
        * Login name of the user who added or edited notes.
        * @member { string } User
        */
        UserName: string;
        /**
        * Earliest time according to which filtering is to be performed.
        * @member { date } MinTime
        */
        MinTime: Date;
        /**
        * Latest time after which filtering is to be performed.
        * @member { date } MaxTime
        */
        MaxTime: Date;
        /**
        * Teh machine name.
        * @member { string } Machine
        */
        MachineName: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeResultData
    * @description Contains information about changing a recipe.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeResultData {
        /**
        * Recipe class name
        */
        Class: string;
        /**
        * Recipe file name
        */
        Recipe: string;
        /**
        * Detailed recipe information
        */
        Details: VisiWin.System.Recipe.IRecipeInfoDetails;
        /**
        * Whether there are changes for the file.
        */
        HasChangesForFile: boolean;
        /**
        * Whether there are changes for the plc.
        */
        HasChangesForPlc: boolean;
        /**
        * Enumeration containing the possible results of the recipe action.
        */
        Error: VisiWin.System.Recipe.RecipeActionSuccess;
        /**
        * Contains information details about the recipe value.
        */
        MemberResults: VisiWin.System.Recipe.IRecipeValue[];
    }
}
declare namespace VisiWin.System.Recipe {
    interface IRecipeClassGetValueResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Name of the variable.
        */
        VariableName: string;
        /**
        * Value of the variable.
        */
        Value: VisiWin.System.DataAccess.VariantType;
        /**
        * Enumeration for the type code of a process variable.
        */
        DataType: VisiWin.System.DataAccess.TypeCode;
        /**
        * Enumeration for the recipe handling.
        */
        ErrorCode: VisiWin.System.Recipe.RecipeMemberErrorCode;
    }
    interface IRecipeClassGetValuesResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Names of the variables.
        */
        VariableNames: string[];
        /**
        * Values of the variables.
        */
        Values: VisiWin.System.DataAccess.VariantType[];
        /**
        * Enumerations for the type code of a process variables.
        */
        DataTypes: VisiWin.System.DataAccess.TypeCode[];
        /**
        * Enumeration for the recipe handling.
        */
        ErrorCodes: VisiWin.System.Recipe.RecipeMemberErrorCode[];
    }
    interface IGetRecipeFileResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Encapsulates the information of a recipe file
        */
        RecipeFile: VisiWin.System.Recipe.IRecipeFile;
    }
    interface IRecipeClassGetVariableNamesResult {
        /**
        * Determines whether the resipe class contains variable names.
        */
        Result: boolean;
        /**
        * Names of the recipe variables
        */
        VariableNames: string[];
    }
    interface IRecipeClassLoadFromFileToBufferResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Enumeration for the recipe load operation.
        */
        LoadRecipeSuccess: VisiWin.System.Recipe.LoadRecipeSuccess;
        /**
        * Error extension for the recipe failure result.
        */
        MemberErrors: VisiWin.System.Recipe.IMemberError[];
    }
    interface IRecipeClassLoadFromFileToProcessResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Enumeration for the recipe load operation.
        */
        LoadRecipeSuccess: VisiWin.System.Recipe.LoadRecipeSuccess;
        /**
        * Error extension for the recipe failure result.
        */
        MemberErrors: VisiWin.System.Recipe.IMemberError[];
    }
    interface IRecipeClassReadProcessToBufferResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Enumeration for the recipe recive operation.
        */
        GetRecipeSuccess: VisiWin.System.Recipe.GetRecipeSuccess;
        /**
        * Contains information about the execution of a recipe action.
        * available with WebGatewayProtocolVersion >= 19 (2022-2)
        */
        RecipeActionResult?: VisiWin.System.Recipe.IRecipeActionResult;
    }
    interface IRecipeClassSetValueResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Enumeration for the recipe handling.
        */
        RecipeMemberErrorCode: VisiWin.System.Recipe.RecipeMemberErrorCode;
        /**
        * Contains information about the execution of a recipe action.
        * available with WebGatewayProtocolVersion >= 19 (2022-2)
        */
        RecipeActionResult?: VisiWin.System.Recipe.IRecipeActionResult;
    }
    interface IRecipeClassSaveToFileFromBufferResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Enumeration for the recipe saving.
        */
        SaveRecipeSuccess: VisiWin.System.Recipe.SaveRecipeSuccess;
        /**
        * Contains information about the execution of a recipe action.
        * available with WebGatewayProtocolVersion >= 19 (2022-2)
        */
        RecipeActionResult?: VisiWin.System.Recipe.IRecipeActionResult;
    }
    interface IRecipeClassWriteBufferToProcessResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Enumeration for the recipe set operation.
        */
        SetRecipeSuccess: VisiWin.System.Recipe.SetRecipeSuccess;
        /**
        * Contains information about the execution of a recipe action.
        * available with WebGatewayProtocolVersion >= 19 (2022-2)
        */
        RecipeActionResult?: VisiWin.System.Recipe.IRecipeActionResult;
    }
    interface IRecipeServiceLoadRecipeFileValuesResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Names of the variables.
        */
        VariableNames: string[];
        /**
        * Values of the variables.
        */
        Values: VisiWin.System.DataAccess.VariantType[];
        /**
        * Enumerations for the type code of a process variables.
        */
        DataTypes: VisiWin.System.DataAccess.TypeCode[];
        /**
        * Enumeration for the recipe handling.
        */
        ErrorCodes: VisiWin.System.Recipe.RecipeMemberErrorCode[];
    }
    interface IDeleteFileResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Enumeration for the recipe delete opration.
        */
        DeleteRecipeFileSuccess: VisiWin.System.Recipe.DeleteRecipeFileSuccess;
    }
    interface IGetNotesResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Structure encapsulating the information of a note in a recipe file
        */
        Notes: VisiWin.System.Recipe.IRecipeNote[];
    }
    interface IGetChangesResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * The 'RecipeChange' structure represents a recipe value change recorded by the change history.
        */
        Changes: VisiWin.System.Recipe.IRecipeChange[];
    }
    interface IGetRecipeClassNamesResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * The names property contains a collection of the recipes.
        */
        RecipeClassNames: string[];
    }
    interface IGetRecipeClassResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * The RecipeCkass property contains the recipe.
        */
        RecipeClass: VisiWin.System.Recipe.IRecipeClass;
    }
    interface IGetRecipeFileNamesResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * The RecipeFileNames property contains a collection of the recipe files.
        */
        RecipeFileNames: string[];
    }
    interface IGetSubRecipesResult {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * SubRecipes contains
        */
        SubRecipes: VisiWin.System.Recipe.ISubRecipe[];
    }
    interface IAddNoteResult {
        Result: boolean;
    }
    interface IClearChangesResult {
        Result: boolean;
    }
    interface IClearNotesResult {
        Result: boolean;
    }
    interface ILockRecipeResult {
        Result: boolean;
    }
    interface IUnlockRecipeResult {
        Result: boolean;
    }
    interface ILoadFileToBufferResult {
        Class: string;
        ErrorParams: VisiWin.System.Recipe.IRecipeErrorParam[];
        FileName: string;
        FilePath: string;
        Result: VisiWin.System.Recipe.LoadRecipeResults;
        SubRecipesResults: VisiWin.System.Recipe.ILoadFileToBufferResult[];
    }
    interface IRecipeErrorParam {
        Member: string;
        Error: VisiWin.System.Recipe.RecipeErrorCode;
    }
    interface ISetDefaultValuesToBufferResult {
        Result: VisiWin.System.Recipe.SetValuesResult;
        Values: VisiWin.System.Recipe.IRecipeValue[];
        SubRecipesData: VisiWin.System.Recipe.ISetDefaultValuesToBufferResult[];
    }
    interface ISaveBufferToFileResult {
        FileName: string;
        FilePath: string;
        Result: VisiWin.System.Recipe.SaveRecipeResult;
    }
    interface ILoadFileToProcessResult {
        Class: string;
        ErrorParams: VisiWin.System.Recipe.IRecipeErrorParam[];
        FileName: string;
        FilePath: string;
        Result: VisiWin.System.Recipe.SendRecipeResult;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.RecipeService
    * @description Entry point to the recipe system
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeService extends VisiWin.Internal.System.IBaseClass {
        /**
        * Names of recipe definition
        * @member { string[] } RecipeClassNames
        */
        RecipeClassNames: string[];
        /**
        * @function DeleteFileAsync
        * @description Deletes the given file.
        * @param { string } recipeClassName Name of recipe class.
        * @param { string } fileName Name of recipe file wich is to be deleted.
        * @returns { Promise<VisiWin.System.Recipe.IDeleteFileResult> }
        */
        DeleteFileAsync(recipeClassName: string, recipeFileName: string): Promise<VisiWin.System.Recipe.IDeleteFileResult>;
        /**
        * @function GetRecipeClassNamesAsync
        * @description Get all names of recipe definition
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeClassNamesResult> }
        */
        GetRecipeClassNamesAsync(): Promise<VisiWin.System.Recipe.IGetRecipeClassNamesResult>;
        /**
        * @function GetRecipeClassAsync
        * @description Get a recipe class to access a recipe
        * @param { string } recipeClassName Name from the recipe definition
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeClassResult }
        */
        GetRecipeClassAsync(recipeClassName: string): Promise<VisiWin.System.Recipe.IGetRecipeClassResult>;
        /**
        * @function GetRecipeFileNamesAsync
        * @description Get the recipe file names from a given recipe class name.
        * @param { string } recipeClassName Name from the recipe definition
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeFileNamesResult> }
        */
        GetRecipeFileNamesAsync(recipeClassName: string): Promise<VisiWin.System.Recipe.IGetRecipeFileNamesResult>;
        /**
        * @function GetRecipeFileAsync
        * @description Get the recipe file from a given recipe class name
        * @param { string } recipeClassName Name from the recipe definition
        * @param { string } recipeFileName Name of the requested file
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeFileResult> }
        */
        GetRecipeFileAsync(recipeClassName: string, recipeFileName: string): Promise<VisiWin.System.Recipe.IGetRecipeFileResult>;
        /**
        * @function LoadRecipeFileValuesAsync
        * @description Returns all recipe values from a recipe file.
        * @param { string } recipeClassName Name from the recipe definition
        * @param { string } recipeFileName Name of the requested file
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeFileResult> }
        */
        LoadRecipeFileValuesAsync(recipeClassName: string, recipeFileName: string, variableNames?: string[]): Promise<VisiWin.System.Recipe.IRecipeServiceLoadRecipeFileValuesResult>;
        /**
        * @function UnlockAllAsync
        * @description Unlocks all 'RecipeClass' objects
        * available with WebGatewayProtocolVersion >= 19 (2022-3)
        * @returns { boolean } true: The operation was successfully executed, otherwise false.
        */
        UnlockAllAsync(): Promise<boolean>;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeSubClassDefinition
    * @description Definition of the recipe subclass.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeSubClassDefinition {
        /**
        * Subrecipe class name.
        * @member { string } Name
        */
        Name: string;
        /**
        * RecipeFileNameVariableName the variable file name
        * @member { string } RecipeFileNameVariableFullName
        */
        RecipeFileNameVariableFullName: string;
        /**
        * Sort order in the display.
        * @member { number } SortIndex
        */
        SortIndex: number;
        /**
        * The Comment.
        * @member { string } Comment
        */
        Comment: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeTriggeredEventArgs
    * @description Base class for various recipe eventArgs.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeTriggeredEventArgs {
        /**
        *  Server name.
        * @member { string } Server
        */
        Server: string;
        /**
        * Enumeration of sources of a recipe change.
        * @member { VisiWin.System.Recipe.RecipeChangedSource } Source
        */
        Source: VisiWin.System.Recipe.RecipeChangedSource;
        /**
        *  Enumeration of recipe change actions.
        * @member { VisiWin.System.Recipe.RecipeChangedAction } Action
        */
        Action: VisiWin.System.Recipe.RecipeChangedAction;
        /**
        * Recipe class name.
        * @member { string } ClassName
        */
        ClassName: string;
        /**
        * Contains information details about the recipe.
        * @member {  VisiWin.System.Recipe.IRecipeInfoDetails } Details
        */
        Details: VisiWin.System.Recipe.IRecipeInfoDetails;
    }
}
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeValue
    * @description Contains information details about the recipe value.
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeValue {
        /**
        * The variable value
        * @member { VisiWin.System.DataAccess.VariantType } Value
        */
        Value: VisiWin.System.DataAccess.VariantType | null;
        /**
        * The variable name
        * @member { string } VariableName
        */
        VariableName: string;
        /**
        * RecipeMemberErrorCode
        * @member { VisiWin.System.Recipe.RecipeMemberErrorCode } ErrorCode
        */
        ErrorCode: VisiWin.System.Recipe.RecipeMemberErrorCode;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IRecipeWrittenToProcessEventArgs
    * @description Is passed on WrittenToProcess
    * @memberof VisiWin.System.Recipe
    */
    interface IRecipeWrittenToProcessEventArgs extends VisiWin.System.Recipe.IRecipeTriggeredEventArgs {
        /**
        * Result for the recipe members
        * @member { VisiWin.System.Recipe.IRecipeMemberResult[] } Results
        */
        Results: VisiWin.System.Recipe.IRecipeMemberResult[];
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.IStorageHandlerConfiguration
    * @description Configuration for the staorage handler.
    * @memberof VisiWin.System.Recipe
    */
    interface IStorageHandlerConfiguration {
        /**
        *  Relative name of the directory for the Current data recording.
        * @member { string } Directory
        */
        Directory: string;
        /**
        * File name or file name format template for the file name of the current file
        * @member { string } StorageName
        */
        StorageName: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.ISubRecipe
    * @description Structure encapsulating the information of a sub recipe.
    * @memberof VisiWin.System.Recipe
    */
    interface ISubRecipe {
        /**
        * The nem of the sub recipe.
        * @member { string } Name
        */
        Name: string;
        /**
        * FileNameVariableName the variable file name
        * @member { string } FileNameVariableName
        */
        FileNameVariableName: string;
        /**
        * Sort order in the display.
        * @member { number } SortIndex
        */
        SortIndex: number;
        /**
        * Comment of the sub recipe
        * @member { string } Comment
        */
        Comment: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * Filters for the GetChangesAsync call in IRecipeFile or IRecipeClass
    */
    class RecipeChangeFilter implements VisiWin.System.Recipe.IRecipeChangeFilter {
        /**
        * UserName
        * @member { string } UserName
        */
        UserName: string;
        /**
        * MachineName
        * @member { string } MachineName
        */
        MachineName: string;
        /**
        * Sets the final point of the time filter.
        */
        MaxTime: Date;
        /**
        * Sets the starting point of the time filter.
        */
        MinTime: Date;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.RecipeNotesFilter
    * @description Filter for recipe notes.
    * @memberof VisiWin.System.Recipe
    */
    class RecipeNotesFilter {
        /**
        * Login name of the user who added or edited notes.
        * @member { string } User
        */
        UserName: string;
        /**
        * Earliest time according to which filtering is to be performed.
        * @member { date } MinTime
        */
        MinTime: Date;
        /**
        * Latest time after which filtering is to be performed.
        * @member { date } MaxTime
        */
        MaxTime: Date;
        /**
        * Teh machine name.
        * @member { string } Machine
        */
        MachineName: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.RecipeClass
    * @description Class for access to a recipe
    * @memberof VisiWin.System.Recipe
    */
    abstract class RecipeClass extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Recipe.IRecipeClass {
        /**
        * LockStateChanged the recipe object blocked changed
        * @event RecipeClass#LockStateChanged
        * @type {object}
        * @property {VisiWin.System.Recipe.IRecipeLockStateChangedEventArgs}
        */
        LockStateChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Recipe.IRecipeLockStateChangedEventArgs>;
        /**
        * SubRecipes of the RecipeClass
        * @member { VisiWin.System.Recipe.ISubRecipe[] } SubRecipes
        */
        SubRecipes: VisiWin.System.Recipe.ISubRecipe[];
        /**
        * Name of recipe definition
        * @member { string } Name
        */
        Name: string;
        /**
        * FileNames of the RecipeClass
        * @member { string [] } FileNames
        */
        FileNames: string[];
        /**
        * Returns whether the recipe object is blocked
        * @member { VisiWin.System.Recipe.RecipeLockState[] } LockState
        */
        LockState: VisiWin.System.Recipe.RecipeLockState;
        /**
        * @function GetRecipeFileAsync
        * @description Get the recipe file from a given recipe class name
        * @param { string } recipeFileName Name of the requested file
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeFileResult> }
        */
        GetRecipeFileAsync(recipeFileName: string): Promise<VisiWin.System.Recipe.IGetRecipeFileResult>;
        /**
        * @function GetVariableNamesAsync
        * @description Returns the variable names of the recipe elements.
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassGetVariableNamesResult> }
        */
        GetVariableNamesAsync(): Promise<VisiWin.System.Recipe.IRecipeClassGetVariableNamesResult>;
        /**@function GetValueAsync
        * @description Allows reading a value from the recipe cache.
        * @param { string } variableName Designator of the process variable.
        * @returns {Promise<VisiWin.System.Recipe.IRecipeClassGetValueResult>>} the result of the operation.
        */
        GetValueAsync(variableName: string): Promise<VisiWin.System.Recipe.IRecipeClassGetValueResult>;
        /**@function GetValuesAsync
        * @description Allows reading multiple values from the recipe cache
        * @param { string[] } variableNames Array of recipe element designators. If variableName not set, the values from all variables are retrieved.
        * @returns {Promise<VisiWin.System.Recipe.IRecipeClassGetValuesResult>>}
        */
        GetValuesAsync(variableName?: string[]): Promise<VisiWin.System.Recipe.IRecipeClassGetValuesResult>;
        /**
        * @function LoadFromFileToBufferAsync
        * @deprecated use LoadFileToBufferAsync
        * @description Loads the recipe values from a file into the recipe cache
        * @param { string } fileName Name of recipe file
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassLoadFromFileToBufferResult> }
        */
        LoadFromFileToBufferAsync(fileName: string): Promise<VisiWin.System.Recipe.IRecipeClassLoadFromFileToBufferResult>;
        /**
        * @function LoadFromFileToProcessAsync
        * @deprecated use LoadFromFileToProcessAsync
        * @description Loads the recipe values from a file into the process
        * @param { string } fileName Name of recipe file
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassLoadFromFileToProcessResult> }
        */
        LoadFromFileToProcessAsync(fileName: string): Promise<VisiWin.System.Recipe.IRecipeClassLoadFromFileToProcessResult>;
        /**
        * @function ReadProcessToBufferAsync
        * @description Loads the recipe values from the process into the recipe buffer
        * @returns { VisiWin.System.Recipe.IRecipeClassReadProcessToBufferResult }
        */
        ReadProcessToBufferAsync(): Promise<VisiWin.System.Recipe.IRecipeClassReadProcessToBufferResult>;
        /**
        * @function SetValueAsync
        * @description Writes a value into the recipe cache.
        * @param { string } variableName Designator of the recipe element whose new value is to be written
        * @param { TypVisiWin.System.AnyValuee } recipeValue the recipe element value to be written
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassSetValueResult> }
        */
        SetValueAsync(variableName: string, recipeValue: VisiWin.System.DataAccess.VariantType): Promise<VisiWin.System.Recipe.IRecipeClassSetValueResult>;
        /**
        * @function SetValuesAsync
        * @description Writes a value into the recipe cache.
        * The 'SetValuesAsync' method writes multiple values into the recipe cache.
        * @param { string[] } variableNames Field of recipe element designators
        * @param { VisiWin.System.DataAccess.VariantType[] } recipeValues array containing the recipe element values to be written
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassSetValueResult[]> }
        */
        SetValuesAsync(variableNames: string[], recipeValues: VisiWin.System.DataAccess.VariantType[]): Promise<VisiWin.System.Recipe.IRecipeClassSetValueResult[]>;
        /**
        * @function SaveToFileFromBufferAsync
        * @description Saves the current values of the recipe cache in the recipe file indicated in the 'fileName' parameter.
        * @param { string } fileName Name of recipe file
        * @param { string } description Description of recipe file
        * @param { string } forceOverwrite True: If the recipe file indicated in the 'fileName' parameter already exists the values in this file are overwritten. Default=false.
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassLoadFromFileToProcessResult> }
        */
        SaveToFileFromBufferAsync(fileName: string, description: string, forceOverwrite: boolean): Promise<VisiWin.System.Recipe.IRecipeClassSaveToFileFromBufferResult>;
        /**
        * @function WriteBufferToProcessAsync
        * @description Writes the current buffer values into the process
        * @returns { Promise<VisiWin.System.Recipe.IRecipeClassWriteBufferToProcessResult> }
        */
        WriteBufferToProcessAsync(): Promise<VisiWin.System.Recipe.IRecipeClassWriteBufferToProcessResult>;
        /**
        * @function GetChangesAsync
        * The 'GetChangesAsync' method returns the information of the change history for the given file.
        * @param { string } fileName Name of recipe file
        * @returns { Promise<VisiWin.System.Recipe.IGetChangesResult> }
        */
        GetChangesAsync(fileName?: string, filter?: VisiWin.System.Recipe.RecipeChangeFilter): Promise<VisiWin.System.Recipe.IGetChangesResult>;
        /**
         * @function AddNoteAsync
         * The 'AddNoteAsync' method adds a new note to the loaded recipe into the recipe buffer.
         * @param { string } note string of the note to be added
         * @returns { Promise<VisiWin.System.Recipe.IAddNoteResult> }
         */
        AddNoteAsync(note: string): Promise<VisiWin.System.Recipe.IAddNoteResult>;
        /**
         * @function GetNotesAsync
         * The 'GetNotesAsync' method returns the notes for the file loaded in the recipe buffer.
         * @param { string } fileName Name of recipe file
         * @returns { Promise<VisiWin.System.Recipe.IGetNotesResult> }
         */
        GetNotesAsync(): Promise<VisiWin.System.Recipe.IGetNotesResult>;
        GetNotesAsync(filter?: VisiWin.System.Recipe.IRecipeNotesFilter): Promise<VisiWin.System.Recipe.IGetNotesResult>;
        GetNotesAsync(fileName?: string): Promise<VisiWin.System.Recipe.IGetNotesResult>;
        /**
         * @function ClearChangesAsync
         * The 'ClearChangesAsync' method deletes all information on recipe changes.
         * @returns { Promise<VisiWin.System.Recipe.IClearChangesResult> }
         */
        ClearChangesAsync(): Promise<VisiWin.System.Recipe.IClearChangesResult>;
        /**
         * @function ClearNotesAsync
         * The 'ClearNotesAsync' method deletes all recipe notes.
         * @returns { Promise<VisiWin.System.Recipe.IClearNotesResult> }
         */
        ClearNotesAsync(): Promise<VisiWin.System.Recipe.IClearNotesResult>;
        /**
         * @function LockRecipeAsync
         * The 'LockRecipeAsync' method locks a recipe class on the server against changes from other clients.
         * @returns { Promise<VisiWin.System.Recipe.ILockRecipeResult> }
         */
        LockRecipeAsync(): Promise<VisiWin.System.Recipe.ILockRecipeResult>;
        /**
         * @function UnlockRecipeAsync
         * The 'UnlockRecipeAsync' method unlocks a recipe class on the server.
         * @returns { Promise<VisiWin.System.Recipe.IUnlockRecipeResult> }
         */
        UnlockRecipeAsync(): Promise<VisiWin.System.Recipe.IUnlockRecipeResult>;
        /**
         * @function GetSubRecipesAsync
         * The 'GetSubRecipesAsync' method returns the subrecipes of the class.
         * @returns { Promise<VisiWin.System.Recipe.IGetSubRecipesResult> }
         */
        GetSubRecipesAsync(): Promise<VisiWin.System.Recipe.IGetSubRecipesResult>;
        /**
         * @function DeleteFileAsync
         * @description Deletes the given file.
         * @param { string } fileName Name of recipe file wich is to be deleted.
         * @returns { Promise<VisiWin.System.Recipe.IDeleteFileResult> }
         */
        DeleteFileAsync(fileName: string): Promise<VisiWin.System.Recipe.IDeleteFileResult>;
        /**
        * Comment
        * @member { string } Comment
        */
        Comment: string;
        /**
        * The current path.
        * @member { string } CurrentPath
        */
        CurrentPath: string;
        /**
        * Save subrecipe class values here
        * @member { boolean } IncludeSubRecipesInStorage
        */
        IncludeSubRecipesInStorage: boolean;
        /**
        * Directory
        * @member { string } InitialDirectory
        */
        InitialDirectory: string;
        /**
        * Inital rcipe description
        * @member { string } InitialRecipeDescription
        */
        InitialRecipeDescription: string;
        /**
        * Recipe name.
        * @member { string } InitialRecipeName
        */
        InitialRecipeName: string;
        /**
        * Indicates if there are changes for the file.
        * @member { boolean } HasChangesForFile
        */
        HasChangesForFile: boolean;
        /**
        * Indicates if there are changes for the process.
        * @member { boolean } HasChangesForProcess
        */
        HasChangesForProcess: boolean;
        /**
        * Specifies whether the recipe uses a common recipe buffer for all clients
        * @member { boolean } IsServerSideRecipe
        */
        IsServerSideRecipe: boolean;
        /**
        * The last recipe that was loaded into the buffer
        * @member { VisiWin.System.Recipe.IRecipeInfoDetails } LastRecipeLoadedToBuffer
        */
        LastRecipeLoadedToBuffer: VisiWin.System.Recipe.IRecipeInfoDetails;
        /**
        * The last recipe that was saved to file.
        * @member { VisiWin.System.Recipe.IRecipeInfoDetails } LastRecipeSavedToFile
        */
        LastRecipeSavedToFile: VisiWin.System.Recipe.IRecipeInfoDetails;
        /**
        * The last recipe that was sent to process.
        * @member { VisiWin.System.Recipe.IRecipeInfoDetails } LastRecipeSentToProcess
        */
        LastRecipeSentToProcess: VisiWin.System.Recipe.IRecipeInfoDetails;
        /**
        * Load last recipe file at startup
        * @member { boolean } LoadOnStartup
        */
        LoadOnStartup: boolean;
        /**
        * Logging category name
        * @member { string } LoggingCategoryName
        */
        LoggingCategoryName: string;
        /**
        * Read modified variable server values directly
        * @member { boolean } ReadValuesOnProcessChange
        */
        ReadValuesOnProcessChange: boolean;
        /**
        *  Save changed values directly
        * @member { boolean } SaveRecipeValueChanges
        */
        SaveRecipeValueChanges: boolean;
        /**
        * Save changed variable server values directly
        * @member { boolean } SaveRecipeValuesOnChange
        */
        SaveRecipeValuesOnChange: boolean;
        /**
        * Save changed values directly
        * @member { boolean } SetRecipeValuesToProcessOnChange
        */
        SetRecipeValuesToProcessOnChange: boolean;
        /**
        * Indicates whether the recipe edit mode is active
        * @member { boolean } IsEditing
        */
        IsEditing: boolean;
        /**
        * Localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * The recipe buffer changed.
        * @event RecipeClass#BufferChanged
        * @type {object}
        * @property {VisiWin.System.Recipe.IRecipeBufferChangedEventArgs}
        */
        BufferChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Recipe.IRecipeBufferChangedEventArgs>;
        /**
        * The recipe file changed.
        * @event RecipeClass#FilesChanged
        * @type {object}
        * @property {VisiWin.System.Recipe.IRecipeFilesChangedEventArgs}
        */
        FilesChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Recipe.IRecipeFilesChangedEventArgs>;
        /**
        * LockStateChanged the recipe object blocked changed
        * @event RecipeClass#WrittenToProcess
        * @type {object}
        * @property {VisiWin.System.Recipe.IRecipeWrittenToProcessEventArgs}
        */
        WrittenToProcess: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Recipe.IRecipeWrittenToProcessEventArgs>;
        /**
         * @function GetCurrentPathAsync
         * @description Returns the current path of the recipe files
         * @returns { Promise<string> }
         */
        GetCurrentPathAsync(): Promise<string>;
        /**
         * @function GetMemberDefinitionsAsync
         * @description Returns a listing of the associated member definitions
         * @returns { Promise<VisiWin.System.Recipe.IRecipeMemberDefinition[]> }
         */
        GetMemberDefinitionsAsync(): Promise<VisiWin.System.Recipe.IRecipeMemberDefinition[]>;
        /**
         * @function IsExistingRecipeFileAsync
         * @description Returns if the specified recipe file exists
         * @param { string } fileName File name to check
         * @returns { Promise<boolean> }
         */
        IsExistingRecipeFileAsync(fileName: string): Promise<boolean>;
        /**
         * @function LoadFileToBufferAsync
         * @description Loads the recipe values from a file into the recipe buffer
         * @param { string } fileName Recipe file name (without path and extension)
         * @param { boolean } normalized Recipe values can be interpreted absolutely or relatively.
         * @returns { Promise<VisiWin.System.Recipe.ILoadFileToBufferResult> }
         */
        LoadFileToBufferAsync(fileName: string, normalized?: boolean): Promise<VisiWin.System.Recipe.ILoadFileToBufferResult>;
        /**
         * @function SetDefaultValuesToBufferAsync
         * @description Sets the default values from the project file into the recipe buffer.
         * @param { VisiWin.System.Recipe.ClearBufferDefaultValues } defaultValues  Possible default value for ClearBuffer
         * @param { boolean } recursive
         * @returns { Promise<VisiWin.System.Recipe.ISetDefaultValuesToBufferResult> }
         */
        SetDefaultValuesToBufferAsync(defaultValues: VisiWin.System.Recipe.ClearBufferDefaultValues, recursive: boolean): Promise<VisiWin.System.Recipe.ISetDefaultValuesToBufferResult>;
        /**
         * @function SaveBufferToFileAsync
         * @description Saves the recipe values from the buffer as a file.
         * @param { string } fileName Recipe file name (without path and extension).
         * @param { string } description description
         * @param { boolean } forceOverwrite True: If the recipe file specified in the 'fileName' parameter already exists, the values in this file will be overwritten.
         * @param { boolean } normalized Recipe values can be interpreted absolutely or relatively.
         * @returns { Promise<VisiWin.System.Recipe.ISaveBufferToFileResult> }
         */
        SaveBufferToFileAsync(fileName: string, description: string, forceOverwrite: boolean, normalized: boolean): Promise<VisiWin.System.Recipe.ISaveBufferToFileResult>;
        /**
         * @function LoadFileToProcessAsync
         * @description Loads the recipe values from a file directly into the variable core without detour via the recipe buffer.
         * @param { string } fileName Recipe file name (without path and extension).
         * @param { boolean } normalized Recipe values can be interpreted absolutely or relatively.
         * @returns { Promise<VisiWin.System.Recipe.ILoadFileToProcessResult> }
         */
        LoadFileToProcessAsync(fileName: string, normalized?: boolean): Promise<VisiWin.System.Recipe.ILoadFileToProcessResult>;
        /**
         * @function StartEditAsync
         * @description Starts the recipe editing mode.
         * @returns { Promise<boolean> }
         */
        StartEditAsync(): Promise<boolean>;
        /**
         * @function StopEditAsync
         * @description Starts the recipe editing mode.
         * @returns { Promise<boolean> }
         */
        StopEditAsync(): Promise<boolean>;
        /**
         * @function RemoveNoteAsync
         * @description Deletes a note from the recipe buffer
         * @param { number } id Note identifier
         * @returns { Promise<boolean> }
         */
        RemoveNoteAsync(id: number): Promise<boolean>;
        /**
         * @function SetCurrentPathAsync
         * @description Sets the current path of the recipe files
         * @param { string } value
         * @returns { Promise<boolean> }
         */
        SetCurrentPathAsync(value: string): Promise<VisiWin.System.Recipe.ChangeDirectorySuccess>;
        /**
         * @function GetRecipeClassDefinitionAsync
         * @description Retrieves the definition for a recipe class.
         * @param { string } className
         * @returns { Promise<VisiWin.System.Recipe.IRecipeClassDefinition> }
         */
        GetRecipeClassDefinitionAsync(className: string): Promise<VisiWin.System.Recipe.IRecipeClassDefinition>;
        /**
        * @function GetFileNamesAsync
        * @description List of all recipe file names in the current directory
        * @returns { Promise<string[]> }
        */
        GetFileNamesAsync(): Promise<string[]>;
        /**
        * @function GetRecipeLockStateAsync
        * @description Retrieving the lock state of the recipe class
        * @returns { Promise<VisiWin.System.Recipe.RecipeLockState> }
        */
        GetRecipeLockStateAsync(): Promise<VisiWin.System.Recipe.RecipeLockState>;
        SetDefaultValuesAsync(defaultValues: VisiWin.System.Recipe.ClearBufferDefaultValues, recursive: boolean): Promise<VisiWin.System.Recipe.IRecipeActionResult>;
    }
}
declare namespace VisiWin.System.Recipe {
    /**
    * Enumeration for the recipe handling.
    * public enum RecipeMemberErrorCode
    * @enum RecipeMemberErrorCode
    */
    enum RecipeMemberErrorCode {
        /**
        * Success
        */
        Succeeded = 0,
        /**
        * An unknown error occurred while loading the value (an error occurred in the sub-recipe)
        */
        Unknown = 1,
        /**
        * No value was found in the recipe file for the element in the recipe definition
        */
        MemberNotFound = 2,
        /**
        * A value was found in the recipe file for which there is no element in the recipe definition
        */
        NoMember = 3,
        /**
        * The data type of the value from the recipe file does not match the data type of the variables from the recipe server
        */
        DatatypeConversionError = 4,
        /**
        * A variable present in a recipe definition does not exist.
        */
        VariableDoesNotExist = 5,
        /**
        * The attempt to write a value to the PLC or to read a value from the PLC fails.
        */
        CommunicationError = 6,
        /**
        * An error occurred when loading a subrecipe with the value of the recipe variable.
        */
        SubRecipeHasError = 7
    }
    /**
    * Enumeration for the recipe load opration.
    * public enum LoadRecipeSuccess
    * @enum LoadRecipeSuccess
    */
    enum LoadRecipeSuccess {
        /**
        * Loading the recipe values from the recipe file into the recipe buffer was successful
        */
        Succeeded = 0,
        /**
        * An error occurred while loading. The specified recipe file was not found.
        */
        FileNotFound = 1,
        /**
        * An error occurred while loading. The recipe file may be damaged.
        */
        FileCorrupted = 2,
        /**
        * Errors occurred while loading the recipe values.
        * One or more recipe values could not be loaded from the file.
        * The recipe values determined as incorrect are listed in the 'ErrorParams' property
        */
        LoadedWithErrors = 3,
        /**
        * obsolet
        */
        NoRecipeClass = 4,
        /**
        * all other error messages (internal error)
        */
        UnknownError = 5,
        /**
        * obsolet
        */
        InvalidParameter = 6,
        /**
        * Recipe class locked by another client
        */
        Locked = 7
    }
    /**
    * Enumeration for the recipe recive opration.
    * public enum GetRecipeSuccess
    * @enum GetRecipeSuccess
    */
    enum GetRecipeSuccess {
        Succeeded = 0,
        CommunicationFailure = 1,
        NoRecipeClass = 2,
        UnknownError = 3,
        InvalidParameter = 4,
        Locked = 5
    }
    /**
    * Enumeration for the recipe set opration.
    * public enum SetRecipeSuccess
    * @enum SetRecipeSuccess
    */
    enum SetRecipeSuccess {
        /**
        * The writing of the recipe values from the recipe buffer into the variable kernel was successful
        */
        Succeeded = 0,
        /**
        * Writing at least one of the recipe values from the variable kernel to the recipe buffer was not successful
        */
        CommunicationFailure = 1,
        /**
        * A nonexistent recipe class was specified
        */
        NoRecipeClass = 2,
        /**
        * obsolet
        */
        NoBufferedValues = 3,
        /**
        * all other error messages (internal error, data type error, sub-recipe error)
        */
        UnknownError = 4,
        /**
        * obsolet
        */
        InvalidParameter = 5,
        /**
        * Recipe class locked by another client
        */
        Locked = 6
    }
    /**
    * Enumeration for the recipe save opration.
    * public enum SaveRecipeSuccess
    * @enum SaveRecipeSuccess
    */
    enum SaveRecipeSuccess {
        /**
         *  Saving the recipe values from the recipe buffer in the recipe file was successful
         */
        Succeeded = 0,
        /**
         * Currently UnknownError.
         */
        FileNotCreated = 1,
        /**
         * The specified recipe file already exists and cannot be overwritten
         */
        UnableToOverwrite = 2,
        /**
         * obsolet
         */
        NoRecipeClass = 3,
        /**
         * obsolet
         */
        NoBufferedValues = 4,
        /**
         * All other error messages (internal error, recipe value cannot be determined)
         */
        UnknownError = 5,
        /**
         * obsolet
         */
        InvalidParameter = 6,
        /**
         * obsolet
         */
        ExceededMaxFiles = 7,
        /**
         * Recipe class locked by another client
         */
        Locked = 8,
        /**
         * not yet used, in preparation
         */
        SavedWithErrors = 9
    }
    /**
    * Enumeration for the recipe delete opration.
    * public enum SaveRecipeSuccess
    * @enum SaveRecipeSuccess
    */
    enum DeleteRecipeFileSuccess {
        /**
        * The recipe file could not be deleted
        */
        Failed = 0,
        /**
        * The recipe file has been deleted
        */
        Succeeded = 1
    }
    /**
    * Enumeration for the recipe lock state.
    * public enum RecipeLockState
    * @enum RecipeLockState
    */
    enum RecipeLockState {
        /**
        * The recipe is unlocked
        */
        Unlocked = 0,
        /**
        * The recipe is locked by this client.
        */
        LockedByThisClient = 1,
        /**
        * The recipe is locked by another client.
        */
        LockedByOtherClient = 2
    }
    /**
    * Enumeration of recipe change actions
    * public enum RecipeChangedAction
    * @enum RecipeChangedAction
    */
    enum RecipeChangedAction {
        /**
        * File was loaded into the buffer
        */
        LoadFileToBuffer = 0,
        /**
        * Process values were read into the buffer
        */
        ReadProcessToBuffer = 1,
        /**
        * The buffer was cleared
        */
        Clear = 2,
        /**
        * The buffer was reset to default values
        */
        SetDefaults = 3,
        /**
        * Values were written to the buffer
        */
        SetValues = 4,
        /**
        *  A file was loaded into the process
        */
        LoadFileToProcess = 5,
        /**
        * The values were written from the buffer to the process
        */
        WriteBufferToProcess = 6,
        /**
        * The values were saved from the buffer to a file
        */
        SaveBufferToFile = 7
    }
    /**
    * Enumeration of sources of a recipe change
    * public enum RecipeChangedSource
    * @enum RecipeChangedSource
    */
    enum RecipeChangedSource {
        /**
        * Change triggered by the application
        */
        Application = 0,
        /**
        * Change was triggered by a trigger variable
        */
        TriggerVariable = 1,
        /**
        *  Change was triggered by the system
        */
        System = 2
    }
    /**
    * Enumeration of file actions
    * public enum FileAction
    * @enum FileAction
    */
    enum FileAction {
        /**
        * File was saved
        */
        Saved = 0,
        /**
        * File was deleted
        */
        Deleted = 1
    }
    /**
    * Enumeration of possible default values for ClearBuffer
    * public enum ClearBufferDefaultValues
    * @enum ClearBufferDefaultValues
    */
    enum ClearBufferDefaultValues {
        /**
        *  Data type default values
        */
        DataType = 0,
        /**
        *  Variable default values
        */
        Variable = 1,
        /**
        * Recipe default values
        */
        Recipe = 2
    }
    /**
    * Enumeration for recipe notes change action
    * public enum RecipeNotesChangeAction
    * @enum RecipeNotesChangeAction
    */
    enum RecipeNotesChangeAction {
        /**
        * Note added
        */
        Add = 0,
        /**
        * Note changed
        */
        Change = 1,
        /**
        * Note removed
        */
        Remove = 2
    }
    /**
    * Enumeration containing the possible causes of errors when handling a value from a recipe.
    * public enum RecipeErrorCode
    * @enum RecipeErrorCode
    */
    enum RecipeErrorCode {
        /**
        *  Loading the value was successful
        */
        Succeeded = 0,
        /**
        * An unknown error occurred while loading the value
        */
        Unknown = 1,
        /**
        * No value was found in the recipe file for the element in the recipe definition
        */
        MemberNotFound = 2,
        /**
        * A value was found in the recipe file for which there is no element in the recipe definition
        */
        NoMember = 3,
        /**
        * The data type of the value from the recipe file does not match the data type of the variable from the recipe server
        */
        DatatypeConversionError = 4,
        /**
        * File was not found
        */
        FileNotFound = 5,
        /**
        * File is corrupted
        */
        FileCorrupted = 6,
        /**
        * File was loaded with errors
        */
        LoadedWithErrors = 7
    }
    /**
    * Enumeration containing the possible results of the LoadFileToBufferAsync  method.
    * public enum LoadRecipeResults
    * @enum LoadRecipeResults
    */
    enum LoadRecipeResults {
        /**
        * Loading the recipe values from the recipe file into the recipe buffer was successful.
        */
        Succeeded = 0,
        /**
        *  An error occurred while loading. The specified recipe file was not found.
        */
        FileNotFound = 1,
        /**
        * An error occurred during loading. The recipe file may be corrupted.
        */
        FileCorrupted = 2,
        /**
        * Errors occurred while loading the recipe values.
        */
        LoadedWithErrors = 3,
        /**
        * Recipe class does not exist
        */
        ClassDoesNotExist = 4,
        /**
        * Das Rezept wurde blockiert(LockRecipeAsync).
        */
        RecipeLocked = 5,
        /**
        * The method call has failed, e.g. connection abort
        */
        MethodCallFailed = 6
    }
    /**
    * Enumeration containing the possible results of the SaveBufferToFileAsync method.
    * public enum SaveRecipeResult
    * @enum SaveRecipeResult
    */
    enum SaveRecipeResult {
        /**
        * Saving the recipe values from the recipe buffer to the recipe file was successful
        */
        Succeeded = 0,
        /**
        * The specified recipe file could not be created
        */
        FileNotCreated = 1,
        /**
        *  The specified recipe file already exists and could not be overwritten.
        */
        UnableToOverwrite = 2,
        /**
        * An error in the recipe server prevented saving the recipe file
        */
        InternalError = 3,
        /**
        * Recipe class does not exist
        */
        ClassDoesNotExist = 4,
        /**
        * Das Rezept wurde blockiert. "LockRecipeAsync"
        */
        RecipeLocked = 5,
        /**
        * The method call has failed, e.g. connection abort
        */
        MethodCallFailed = 6
    }
    /**
    * Enumeration containing the possible results of the "LoadFileToProcessAsync" method.
    * public enum SendRecipeResult
    * @enum SendRecipeResult
    */
    enum SendRecipeResult {
        /**
        * Loading the recipe values from the recipe file into the process was successful
        */
        Succeeded = 0,
        /**
        * An error occurred while loading. The specified recipe file was not found.
        */
        FileNotFound = 1,
        /**
        * An error occurred during loading. The recipe file may be corrupted.
        */
        FileCorrupted = 2,
        /**
        * Errors occurred while loading the recipe values.
        * One or more recipe values could not be loaded from the file.
        */
        SentWithErrors = 3,
        /**
        * Recipe class does not exist
        */
        ClassDoesNotExist = 4,
        /**
        * The recipe was blocked. "LockRecipeAsync"
        */
        RecipeLocked = 5,
        /**
        * The method call has failed, e.g. connection abort
        */
        MethodCallFailed = 6
    }
    /**
    * Enumeration containing the possible results of the recipe action.
    * public enum RecipeActionSuccess
    * @enum RecipeActionSuccess
    */
    enum RecipeActionSuccess {
        None = 0,
        Succeeded = 1,
        FileNotFound = 2,
        FileCorrupted = 3,
        HasMemberErrors = 4,
        CommunicationFailure = 5,
        NoRecipeClass = 6,
        UnknownError = 7,
        InvalidParameter = 8,
        Locked = 9,
        FileNotCreated = 10,
        UnableToOverwrite = 11,
        NoBufferedValues = 12,
        ExceededMaxFiles = 13,
        ExceededRecursionsDepth = 14
    }
    enum SetValuesResult {
        Succeeded = 0,
        ClassDoesNotExist = 1,
        RecipeLocked = 2,
        SetValuesWithErrors = 1,
        MethodCallFailed = 2
    }
    enum ChangeDirectorySuccess {
        Failed = 0,
        Succeeded = 1,
        InsufficientDiskSpace = 2,
        InvalidDirectory = 3
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.RecipeFile
    * @description Encapsulates the information of a recipe file
    * @memberof VisiWin.System.Recipe
    */
    abstract class RecipeFile extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Recipe.IRecipeFile {
        /**
        * Returns the description to the file
        * @member { string } Description
        */
        Description: string;
        /**
        * Returns the name of the file
        * @member { String } FileName
        */
        FileName: string;
        /**
        * Name of recipe definition
        * @member { string } RecipeClassName
        */
        RecipeClassName: string;
        /**
        * Returns the date of the latest file change
        * @member { Date } TimeOfLastChange
        */
        TimeOfLastChange: Date;
        /**
        * Returns the name of the user how saved the recipe
        * @member { string } WhoSavedRecipe
        */
        WhoSavedRecipe: string;
        /**
         * @function GetChangesAsync
         * @discription The method returns the information of the change history for this file.
         * @param {  VisiWin.System.Recipe.RecipeChangeFilter } recipeChangeFilter
         * @returns { Promise<VisiWin.System.Recipe.IGetChangesResult> }
         */
        GetChangesAsync(): Promise<VisiWin.System.Recipe.IGetChangesResult>;
        /**
        * @function GetNotesAsync
        * @discription The method returns the notes for this file.
        * @param { VisiWin.System.Recipe.IRecipeNotesFilter } recipeNotesFilter
        * @returns { Promise<VisiWin.System.Recipe.IGetNotesResult> }
        */
        GetNotesAsync(): Promise<VisiWin.System.Recipe.IGetNotesResult>;
        /**
        * @function GetValuesAsync
        * @discription Returns all values in the recipe as a list
        * @param { boolean } normalized
        * @returns { Promise<VisiWin.System.Recipe.IRecipeValue[]> }
        */
        GetValuesAsync(normalized?: boolean): Promise<IRecipeValue[]>;
        /**
        * Returns the name of the user who saved the file
        * available with WebGatewayProtocolVersion >= 19 (2022-3)
        * @member { String } SavedByUser
        */
        SavedByUser: string;
        /**
        * Returns the name of the server who saved the file
        * available with WebGatewayProtocolVersion >= 19 (2022-3)
        * @member { String } SavedByMachine
        */
        SavedByMachine: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Recipe
*/
declare namespace VisiWin.System.Recipe {
    /**
    * @class
    * @name VisiWin.System.Recipe.RecipeService
    * @description Entry point to the recipe system
    * @memberof VisiWin.System.Recipe
    */
    class RecipeService extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Recipe.IRecipeService {
        static getService(): RecipeService;
        /**
        * Names of recipe definition
        * @member { string[] } RecipeClassNames
        */
        RecipeClassNames: string[];
        /**
        * @function DeleteFileAsync
        * @description Deletes the given file.
        * @param { string } recipeClassName Name of recipe class.
        * @param { string } fileName Name of recipe file wich is to be deleted.
        * @returns { Promise<VisiWin.System.Recipe.IDeleteFileResult> }
        */
        DeleteFileAsync(recipeClassName: string, recipeFileName: string): Promise<VisiWin.System.Recipe.IDeleteFileResult>;
        /**
        * @function GetRecipeClassNamesAsync
        * @description Get all names of recipe definition
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeClassNamesResult> }
        */
        GetRecipeClassNamesAsync(): Promise<VisiWin.System.Recipe.IGetRecipeClassNamesResult>;
        /**
        * @function GetRecipeClassAsync
        * @description Get a recipe class to access a recipe
        * @param { string } recipeClassName Name from the recipe definition
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeClassResult }
        */
        GetRecipeClassAsync(recipeClassName: string): Promise<VisiWin.System.Recipe.IGetRecipeClassResult>;
        /**
        * @function GetRecipeFileNamesAsync
        * @description Get the recipe file names from a given recipe class name.
        * @param { string } recipeClassName Name from the recipe definition
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeFileNamesResult> }
        */
        GetRecipeFileNamesAsync(recipeClassName: string): Promise<VisiWin.System.Recipe.IGetRecipeFileNamesResult>;
        /**
        * @function GetRecipeFileAsync
        * @description Get the recipe file from a given recipe class name
        * @param { string } recipeClassName Name from the recipe definition
        * @param { string } recipeFileName Name of the requested file
        * @returns { Promise<VisiWin.System.Recipe.IGetRecipeFileResult> }
        */
        GetRecipeFileAsync(recipeClassName: string, recipeFileName: string): Promise<VisiWin.System.Recipe.IGetRecipeFileResult>;
        /**
        * @function LoadRecipeFileValues
        * @description Returns all recipe values from a recipe file.
        * @param { string } recipeClassName Name from the recipe definition
        * @param { string } recipeFileName Name of the requested file
        * @returns { Promise<VisiWin.System.Recipe.IRecipeServiceLoadRecipeFileValuesResult> }
        */
        LoadRecipeFileValuesAsync(recipeClassName: string, recipeFileName: string, variableNames?: string[] | null): Promise<VisiWin.System.Recipe.IRecipeServiceLoadRecipeFileValuesResult>;
        /**
        * @function UnlockAllAsync
        * @description Unlocks all 'RecipeClass' objects
        * available with WebGatewayProtocolVersion >= 19 (2022-3)
        * @returns { boolean } true: The operation was successfully executed, otherwise false.
        */
        UnlockAllAsync(): Promise<boolean>;
    }
}
declare namespace VisiWin.System.ServerObjects {
    /**
    * @deprecated do not use
    * @ignore
    */
    interface IServerObject {
        /**
        *  FullName (with Namespace) of the Interface witch is implementedby "ServerObject".
        */
        Namespace: string;
        /**
        * ConnectToServerObject was successfully created
        */
        isAttached: boolean;
        /**
        * RequestID to keep apart of diffrent ServerObjects
        */
        id: VisiWin.IGuid;
        /**
        * Is triggered if a connection to "ServerObject" is established
        */
        OnConnectToServerObject: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseSucceded>;
        /**
        * Is triggered if a property was requested
        */
        OnGetServerObjectPropertyValue: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseValue>;
        /**
        * Is triggered if a property was set
        */
        OnSetServerObjectPropertyValue: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseCommandBase>;
        /**
        * Is triggered if an EventHandler was added
        */
        OnAddServerObjectEventHandler: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseCommandBase>;
        /**
        * Is triggered if an EventHandler was removed
        */
        OnRemoveServerObjectEventHandler: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseCommandBase>;
        /**
        * Is triggered if a "ServerObject" raises an Event
        */
        OnServerObjectEventRaised: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectEventRaised>;
        /**
        * Is triggered if a Method was invoked
        */
        OnInvokeServerObjectMethod: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseValue>;
        /**
        * Attach the ServerObject, this is required as the first call
        */
        ConnectToServerObject(): void;
        /**
        * Get a property value by name
        */
        GetServerObjectPropertyValue(PropertyName: string): void;
        /**
        * Set a property value by given name
        */
        SetServerObjectPropertyValue(PropertyName: string, PropertyValue: VisiWin.System.DataAccess.VariantType): void;
        /**
        * Add an EventHandler for "ServerObject" event
        */
        AddServerObjectEventHandler(EventName: string): void;
        /**
        * Remove an EventHandler for "ServerObject" event
        */
        RemoveServerObjectEventHandler(EventName: string): void;
        /**
        * Invoke a method on the Server
        */
        InvokeServerObjectMethod(MethodName: string, Parameters?: unknown[]): void;
    }
    interface IServerObjectResponseCommandBase {
        RequestID: VisiWin.IGuid;
        Authorized: boolean;
        Result: VisiWin.System.ServerObjects.Result;
    }
    interface IServerObjectResponseValue extends IServerObjectResponseCommandBase {
        Value: unknown;
    }
    interface IServerObjectResponseSucceded extends IServerObjectResponseCommandBase {
        Succeeded: boolean;
    }
    interface IServerObjectEventRaised {
        RequestID: string;
        EventName: string;
        EventArgs: unknown;
    }
    enum Result {
        Succeeded = 0,
        NotConnectedWithGivenRequestId = 1,
        AlreadyConnectedWithSameRequestId = 2,
        InterfaceTypeNotFound = 3,
        ChannelIsNotRegistered = 4,
        MethodDoesNotExistOrWrongParamCount = 5,
        PropertyDoesNotExist = 6,
        EventDoesNotExist = 7,
        EventHasNoHandler = 8,
        EventAlreadyHasHandler = 9,
        MissingTypeProperty = 10,
        PropertyHasNoSetter = 11,
        PropertyHasNoGetter = 12,
        ParameterTypeError = 13,
        ParameterCastingError = 14,
        ErroneousParameter = 15
    }
    /**
    * @deprecated do not use
    * @ignore
    */
    class ServerObject implements VisiWin.System.ServerObjects.IServerObject {
        Namespace: string;
        isAttached: boolean;
        id: VisiWin.IGuid;
        OnConnectToServerObject: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseSucceded>;
        OnGetServerObjectPropertyValue: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseValue>;
        OnSetServerObjectPropertyValue: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseCommandBase>;
        OnAddServerObjectEventHandler: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseCommandBase>;
        OnRemoveServerObjectEventHandler: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseCommandBase>;
        OnServerObjectEventRaised: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectEventRaised>;
        OnInvokeServerObjectMethod: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.ServerObjects.IServerObjectResponseValue>;
        constructor(fullInterfaceName: string);
        ConnectToServerObject(): void;
        GetServerObjectPropertyValue(PropertyName: string): void;
        SetServerObjectPropertyValue(PropertyName: string, PropertyValue: unknown): void;
        AddServerObjectEventHandler(EventName: string): void;
        RemoveServerObjectEventHandler(EventName: string): void;
        InvokeServerObjectMethod(MethodName: string, Parameters?: unknown[]): void;
    }
}
declare namespace VisiWin.System.Trend {
    /**
    * Entery point to the VisiWin trend system.
    */
    interface ITrendService extends VisiWin.Internal.System.IBaseClass {
        /**
        *  Listing the names of all available archives
        */
        ArchiveNames: string[];
        /**
        * Loading an archive and give back their instance.
        */
        GetArchive(archiveName: string): VisiWin.System.Trend.IArchive;
        /**
        * Loading a trend and give back their instance.
        */
        GetTrend(archiveName: string, trendName: string): VisiWin.System.Trend.ITrend;
        /**
        *  Lists the names of all the trends in an archive.
        */
        GetTrendNames(archiveName: string): string[];
    }
}
declare namespace VisiWin.System.Trend {
    /**
    *  Represents the access to an archive definition.
    */
    interface IArchive extends VisiWin.Internal.System.IBaseClass {
        /**
        * Name of the archive definition.
        */
        Name: string;
        /**
        * Array of included trend names.
        */
        TrendNames: string[];
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Function that returns a trend object
        */
        GetTrend(trendName: string): VisiWin.System.Trend.ITrend;
        /**
        * Starts an asynchronous query of X/Y trend data.
        */
        GetTrendData(requestID: string, minTime: Date, maxTime: Date, trendNames: string, maxSamples: number): Promise<VisiWin.System.Trend.ITrendDataPromise>;
        GetTrendsData(requestID: string, minTime: Date, maxTime: Date, trendNames: string[], maxSamples: number): Promise<VisiWin.System.Trend.ITrendDataPromise>;
        /**
        * Trend is made known to the server.
        */
        InitializeTrends(trendNames: string[]): Promise<VisiWin.System.Trend.IInitializeTrendsPromise>;
        /**
        * Sets the state of a trend.
        */
        SetTrendOnlineState(requestID: string, state: VisiWin.System.Trend.SetTrendOnlineState): Promise<VisiWin.System.Trend.ISetTrendOnlineStatePromise>;
        /**
        * Provides data for the 'TrendDataRecorded' event.(Formerly "NewTrendData")
        */
        TrendDataRecorded: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.ITrendDataRecordedEventArgs>;
        TrendsDataRecorded: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.ITrendsDataRecordedEventArgs>;
        /**
        * Trend request completed
        */
        GetTrendDataCompleted: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.IGetTrendDataCompletedEventArgs>;
        GetTrendsDataCompleted: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.IGetTrendsDataCompletedEventArgs>;
    }
}
declare namespace VisiWin.System.Trend {
    /**
    * Represents the access to a trend definition.
    */
    interface ITrend extends VisiWin.Internal.System.IBaseClass {
        /**
        * Name of the archive definition the trend is allocated to.
        */
        ArchiveName: string;
        /**
        * Name of the trend definition.
        */
        Name: string;
        /**
        * Returns the localizable definition name in the language currently selected in the project.
        */
        Text: string;
        /**
        * Provides data for the 'TrendDataRecorded' event.(Formerly "NewTrendData")
        */
        TrendDataRecorded: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.ITrendDataRecordedEventArgs>;
        /**
        * FullName "ArchiveName.TrendName"
        */
        FullName: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
    }
}
declare namespace VisiWin.System.Trend {
    /**
    * Structure containing the information about a record value.
    */
    interface IDataSample extends VisiWin.Internal.System.IBaseClass {
        /**
        * Additional information about the recording apparatus.
        */
        State: VisiWin.System.Trend.SampleState;
        /**
        *  Recorded timestamp.
        */
        Time: Date;
        /**
        * The recorded X-variable value in an XY recording.
        */
        XValue: any;
        /**
        * The recorded trend value (for Y/t and X/Y recording))
        */
        YValue: any;
        /**
        * JSON Object { Time: Time, Value: YValue }
        */
        toJSON(): object;
    }
}
declare namespace VisiWin.System.Trend {
    interface IGetTrendDataCompletedEventArgs {
        TrendName: string;
        MaxTime: Date;
        MaxX: unknown;
        MinTime: Date;
        MinX: unknown;
        RequestID: VisiWin.IGuid;
        Data: VisiWin.System.Trend.IDataSample[];
        ArchiveName?: string;
    }
    interface IGetTrendsDataCompletedEventArgs {
        TrendName: string[];
        MaxTime: Date;
        MaxX: unknown;
        MinTime: Date;
        MinX: unknown;
        RequestID: VisiWin.IGuid;
        Data: VisiWin.System.Trend.IDataSample[][];
        ArchiveName?: string;
    }
}
declare namespace VisiWin.System.Trend {
    interface ITrendDataRecordedEventArgs {
        Count: number;
        TrendName: string;
        Data: VisiWin.System.Trend.IDataSample;
        ArchiveName: string;
    }
    interface ITrendsDataRecordedEventArgs {
        Count: number;
        TrendName: string[];
        Data: VisiWin.System.Trend.IDataSample[][];
    }
}
declare namespace VisiWin.System.Trend {
    /**
    * Promise Event Arguments GetArchives
    */
    interface IGetArchivesPromise {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Archives name array
        */
        Archives: string[];
    }
    /**
    * Promise Event Arguments GetTrends
    */
    interface IGetTrendsPromise {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Archives name array
        */
        Archives: string[];
        /**
        * Trends name array
        */
        Trends: string[];
    }
    /**
    * Promise Event Arguments InitializeTrends
    */
    interface IInitializeTrendsPromise {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        *  RequestID for further accesses
        */
        RequestID: VisiWin.IGuid;
        /**
        * Results for each Trend
        */
        DesiredTrendResults: string[];
        /**
        * Archive Name
        */
        Archive: VisiWin.System.Trend.IArchive;
        Trends: VisiWin.System.Trend.ITrend[];
    }
    /**
    * Promise Event Arguments SetTrendOnlineState
    */
    interface ISetTrendOnlineStatePromise {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        /**
        * Sample counter
        */
        Count: number;
        /**
        * Archive Name
        */
        ArchiveName: string;
        /**
        * Array of IDataSample
        */
        Data: IDataSample[];
        /**
        * Trends Name array
        */
        TrendNames: string[];
    }
    /**
    * Promise Event Arguments GetTrendData
    */
    interface ITrendDataPromise {
        /**
        * Determines whether the request was successfully processed.
        */
        Result: boolean;
        RequestID: VisiWin.IGuid;
    }
}
/**
* @namespace
* @name VisiWin.System.Trend
*/
declare namespace VisiWin.System.Trend {
    /**
    * @class
    * @name VisiWin.System.Trend.Archive
    * @description Represents the access to an archive definition.
    * @memberof VisiWin.System.Trend
    */
    abstract class Archive extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Trend.IArchive {
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Name of the archive definition.
        * @member { string }
        */
        Name: string;
        /**
        * Array of included trend names.
        * @member { string }
        */
        TrendNames: string[];
        /**
        * Provides data for the 'TrendDataRecorded' event.( Formerly "NewTrendData")
        * @event TrendDataRecorded
        * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.ITrendDataRecordedEventArgs>}
        */
        TrendDataRecorded: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.ITrendDataRecordedEventArgs>;
        TrendsDataRecorded: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.ITrendsDataRecordedEventArgs>;
        /**@function
        * @description Function that returns a trend object
        * @name  GetTrend
        */
        GetTrend(trendName: string): VisiWin.System.Trend.ITrend;
        /**@function
        * @description Starts an asynchronous query of X/Y trend data.
        * @name  GetTrendData
        */
        GetTrendData(requestID: string, minTime: Date, maxTime: Date, trendName: string, maxSamples: number): Promise<VisiWin.System.Trend.ITrendDataPromise>;
        GetTrendsData(requestID: string, minTime: Date, maxTime: Date, trendNames: string[], maxSamples: number): Promise<VisiWin.System.Trend.ITrendDataPromise>;
        /**@function
        * @description Sets the state of a trend.
        * @name  SetTrendOnlineState
        */
        SetTrendOnlineState(requestID: string, state: VisiWin.System.Trend.SetTrendOnlineState): Promise<VisiWin.System.Trend.ISetTrendOnlineStatePromise>;
        /**@function
        * @description Trend is made known to the server.
        * @name  InitializeTrends
        */
        InitializeTrends(trendNames: string[]): Promise<VisiWin.System.Trend.IInitializeTrendsPromise>;
        /**
        * Trend request completed
        */
        GetTrendDataCompleted: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.IGetTrendDataCompletedEventArgs>;
        GetTrendsDataCompleted: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.IGetTrendsDataCompletedEventArgs>;
    }
}
/**
* @namespace
* @name VisiWin.System.Trend
*/
declare namespace VisiWin.System.Trend {
    /**
    * @class
    * @name VisiWin.System.Trend.DataSample
    * @description Structure containing the information about a record value.
    * @memberof VisiWin.System.Trend
    */
    abstract class DataSample extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Trend.IDataSample {
        /**
        * Additional information about the recording apparatus.
        * @member { VisiWin.System.Trend.ISampleState }
        */
        State: VisiWin.System.Trend.SampleState;
        /**
        * Recorded timestamp.
        * @member { Date }
        */
        Time: Date;
        /**
        * The recorded X-variable value in an XY recording.
        * @member { any }
        */
        XValue: any;
        /**
        * The recorded trend value (for Y/t and X/Y recording))
        * @member { any }
        */
        YValue: any;
        /**
        * JSON Object { Time: Time, Value: YValue }
        */
        toJSON(): object;
    }
}
/**
* @namespace
* @name VisiWin.System.Trend
*/
declare namespace VisiWin.System.Trend {
    /**
     * public enum SampleState
     * Enumeration containing the different additional informations on a recorded value
     * @enum SampleState
     */
    enum SampleState {
        /**
        * The value to be recorded has changed.
        */
        Standard = 0,
        /**
        * The recorded value has exceeded the maximum value or the value of the maximum variable resp.
        */
        MaxValue = 1,
        /**
        * The recorded value has fallen short ofthe minimum value or the value of the minimum variable resp.
        */
        MinValue = 2,
        /**
        * The recorded value has exceeded the maximum value or the value of the maximum variable resp.,
        * and was replaced by the substitute value maximum or the substitute value maximum variable resp.
        */
        SubstitutedMaxValue = 4,
        /**
        * The recorded value has fallen short ofthe minimum value or the value of the minimum variable resp.,
        * and was replaced by the substitute value minimum or the substitute value minimum variable resp.
        */
        SubstitutedMinValue = 8,
        /**
        * An error has occurred with the recording of the trend value and instead of the trend value the substitute value or the value of the substitute value variable resp. was recorded.
        */
        ErrorValue = 16,
        /**
        * The trend value was recorded as it is beyond the projected hysteresis.
        */
        HysteresisValue = 32,
        /**
        * At the time of recording the Quality Flag of the process variable reported an error.
        */
        BadQuality = 16777216,
        /**
        * The trend value is the first value of a new recording.
        */
        StartedRecording = 67108864,
        /**
        * No value exists as the archive file was deleted.
        */
        ArchiveCleared = 134217728,
        /**
        * The trend value is the first value in the archive file.
        */
        FirstValueinNewFile = 268435456,
        /**
        * The trend value lies beyond the requested interval.
        * The trend server delivers this value so that the curve can be displayed up to the border of the display area.
        * Example: With a recording interval of 10 minutes there can in the worst case be a gap of 9 minutes at the end of the curve display.
        * This gap can be bridged with the additional value.
        */
        OutsideInterval = 536870912,
        /**
        * The X-value belonging to this trend value was changed.
        * This flag is set when an unchanged value is not re-recorded but the time stamp on the recording is adapted.
        */
        SameYNewX = 1073741824
    }
    /**
    * public enum SampleMode
    * Enumeration of the different recording modes.
    * @enum SampleMode
    */
    enum SampleMode {
        /**
        * The cycle of the variable core is used as a time base for the recording. The 'ScanTime' property is then a multiple of this cycle.
        */
        SyncToKernel = 0,
        /**
        * The time base for the recording is a millisecond. The 'ScanTime' property indicates how many milliseconds are to pass per scan.
        */
        TimeBase = 1,
        /**
        * The recording takes place when the value of the process variable determined in the 'XVariable' property changes.
        */
        XVariable = 2
    }
    /**
    * public enum SetTrendOnlineState
    * Set the state of a trend.
    * @enum SetTrendOnlineState
    */
    enum SetTrendOnlineState {
        /**
        * Trend provide online data from server
        */
        On = 0,
        /**
        * Trend gets no data from serve
        */
        Off = 1,
        /**
        * Trend will be detached from server
        */
        Release = 2
    }
    /**
    * public enum HysteresisMode
    * Enumeration containing the possible hysteresis modes for the trend recording.
    * @enum HysteresisMode
    */
    enum HysteresisMode {
        /**
        * No hysteresis is used.
        */
        NoHysteresis = 0,
        /**
        * The value of the 'Hysteresis' property is used as recording hysteresis.
        */
        Absolute = 1,
        /**
        * The value of the 'Hysteresis' property is interpreted as 1/1000 of the difference between the "Maximum" and "Minimum" parameters.
        */
        PromilleMaxMin = 2,
        /**
        * The value of the 'Hysteresis' property is interpreted as 1/1000 of the last recorded value.
        */
        PromilleValue = 3
    }
    /**
    * public enum FilterMode
    * BEnumeration containing the possible filter types for the trend recording.
    * @enum FilterMode
    */
    enum FilterMode {
        /**
        * No filter is used.
        */
        NoFilter = 0,
        /**
        * Filter setting "Midpoint".
        */
        AverageValue = 1,
        /**
        * Filter setting "Averaging".
        */
        Averaging = 2,
        /**
        * Filter setting "Maximum".
        */
        Max = 3,
        /**
        * Filter setting "Minimum".
        */
        Min = 4
    }
    /**
    * public enum CurveMode
    * Collection of the "Output modes" of a trend definition.
    * @enum CurveMode
    */
    enum CurveMode {
        /**
        * The line is displayed as a straight line between the individual depicted points.
        */
        Interpolated = 0,
        /**
        * Die Linie wird als "Treppe" dargestellt.
        * Ausgehend von Punkt 1 verläuft die Linie in Höhe der gleichen Y-Koordinate bis sie die X-Koordinate von Punkt 2 erreicht.
        * Dann nimmt sie die Y-Koordinate von Punkt 2 anThe line is displayed as a "staircase". Starting from point 1 the line runs at the level of the same Y coordinate as far as the X coordinate of point 2. Then it assumes the Y coordinate of point 2.
        */
        StepCurve = 1
    }
}
/**
* @namespace
* @name VisiWin.System.Trend
*/
declare namespace VisiWin.System.Trend {
    /**
    * @class
    * @name VisiWin.System.Trend.Trend
    * @description Represents the access to a trend definition.
    * @memberof VisiWin.System.Trend
    */
    abstract class Trend extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Trend.ITrend {
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Name of the archive definition the trend is allocated to.
        * @member { string }
        */
        ArchiveName: string;
        /**
        * Name of the trend definition.
        * @member { string }
        */
        Name: string;
        /**
        * Returns the localizable definition name in the language currently selected in the project.
        * @member { string }
        */
        Text: string;
        /**
        * Provides data for the 'TrendDataRecorded' event.( Formerly "NewTrendData")
        * @event TrendDataRecorded
        * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.ITrendDataRecordedEventArgs>}
        */
        TrendDataRecorded: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.ITrendDataRecordedEventArgs>;
        /**
        * FullName "ArchiveName.TrendName"
        */
        FullName: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Trend
*/
declare namespace VisiWin.System.Trend {
    /**
    * @class
    * @name VisiWin.System.Trend.TrendService
    * @description Entery point to the VisiWin trend system.
    * @memberof VisiWin.System.Trend
    */
    class TrendService extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Trend.ITrendService {
        /**
        * Listing the names of all available archives.
        * @member { string }
        */
        ArchiveNames: string[];
        static getService(): VisiWin.System.Trend.TrendService;
        /**@function
        * @description Loading a trend and give back their instance.
        * @name  GetTrend
        */
        GetTrend(archiveName: string, trendName: string): VisiWin.System.Trend.ITrend;
        /**@function
        * @description Loading an archive and give back their instance.
        * @name  GetArchive
        */
        GetArchive(archiveName: string): VisiWin.System.Trend.IArchive;
        /**@function
        * @description Lists the names of all the trends in an archive.
        * @name  GetTrendNames
        */
        GetTrendNames(archiveName: string): string[];
    }
}
/**
*
<section class="tsd-panel-group tsd-index-group">
    <h4>Additional Information</h4>
    <section class="tsd-panel tsd-index-panel">
        <div class="tsd-index-content">
            <section class="tsd-index-section ">
             <h4>Examples</h4>
                <ul class="tsd-index-list">
                    <li><a href="../tutorials/UserManagement/IUserManagementService.html" class="tsd-kind-icon">IUserManagementService</a></span></li>
                </ul>
                <ul class="tsd-index-list">
                    <li><a href="../tutorials/UserManagement/LogOnAsync.html" class="tsd-kind-icon">LogOn</a></span></li>
                    <li><a href="../tutorials/UserManagement/ChangeUserPasswordAsync.html" class="tsd-kind-icon">ChangeUserPassword</a></span></li>
                </ul>
                  <ul class="tsd-index-list">
                    <li><a href="../tutorials/UserManagement/UserManagementModified.html" class="tsd-kind-icon">UserManagement Modified Events</a></span></li>
                    <li><a href="../tutorials/UserManagement/UserManagementRights.html" class="tsd-kind-icon">Rights</a></span></li>
                    <li><a href="../tutorials/UserManagement/UserManagementGroups.html" class="tsd-kind-icon">Groups</a></span></li>
                    <li><a href="../tutorials/UserManagement/UserManagementUsers.html" class="tsd-kind-icon">Users</a></span></li>
                </ul>
            </section>
        </div>
    </section>
</section>

*/
declare namespace VisiWin.System.UserManagement { }
declare namespace VisiWin.System.UserManagement {
    /**
    *  Class for functional linking of a control with the user administration.
    */
    interface IAuthorization extends VisiWin.Internal.System.IBaseClass {
        /**
        * Indication of authorization by the user administration
        */
        IsAuthorized: boolean;
        /**
        * Determines the right or the user level.
        */
        Right: string;
        /**
        * Is triggered when the authorization changes.
        */
        Changed: VisiWin.Internal.System.Events.IEventArgs<boolean>;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @class
    * @name VisiWin.System.UserManagement.Right
    * @description Class allowing access to a right of the VisiWin user administration.
    * @memberof VisiWin.System.UserManagement
    */
    interface IRight extends VisiWin.Internal.System.IBaseClass {
        /**
        * Determines whether the right is active.
        * @member { boolean }  Active
        */
        Active: boolean;
        /**
        * Determines the comment on the right.
        * @member { string }  Comment
        */
        Comment: string;
        /**
        * Specifies the names of the user groups linked with the right.
        * @member { string } UserGroupNames
        */
        UserGroupNames: string[];
        /**
        * Determines the name of the right.
        * @member { string }  Name
        */
        Name: string;
        /**
        * Value of the "Runtime name" parameter from the project databank.
        * @member { string }  Text
        */
        Text: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**@function
        * @description Returns an object encapsulating the parameters of a right of the user administration.
        * @name  GetUserGroup
        */
        GetUserGroupAsync(userGroupName: string): Promise<VisiWin.System.UserManagement.IUserGroup>;
        /**
        * Saves the changes to a rights object
        */
        ChangeAsync(changedRight: VisiWin.System.UserManagement.IRightDefinition): Promise<VisiWin.System.UserManagement.ChangeRightSuccess>;
        /**
        * Returns an object that can be used to edit the parameters of the right in the project database.
        */
        GetDefinitionAsync(): Promise<VisiWin.System.UserManagement.IRightDefinition>;
    }
}
declare namespace VisiWin.System.UserManagement {
    /**
    * Encapsulates the information of a rights definition from the project database
    */
    interface IRightDefinition {
        /**
        * Determines whether the right is active.
        */
        Active: boolean;
        /**
        * Determines the comment on the right.
        */
        Comment: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Determines the name of the right.
        */
        Name: string;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @class
    * @name VisiWin.System.UserManagement.User
    * @description Contains the information on a user contained in the user administration.
    * @memberof VisiWin.System.UserManagement
    */
    interface IUser extends VisiWin.Internal.System.IBaseClass {
        /**
        * Determines the value for the "machine code" parameter.
        * @member { string }  Code
        */
        Code: string;
        /**
        * Comment on the user.
        * @member { string }  Comment
        */
        Comment: string;
        /**
        * Specifies the time when the user was locked or deactivated.
        */
        DeactivationTime: Date;
        /**
        * Full name of the user.
        * @member { string }  FullName
        */
        FullName: string;
        /**
        * Determines the name of the user group the user belongs to.
        * @member { string }  GroupName
        */
        GroupName: string;
        /**
        * Logon name of the user.
        * @member { string }  Name
        */
        Name: string;
        /**
        * Returns how many more times the user can try to log on before he is barred.
        * @member { number }  RemainingLogOns
        */
        RemainingLogOns: number;
        /**
        * Indication of validity of current password in days.
        * @member { number }  RenewPassword
        */
        RenewPassword: number;
        /**
        * Returns a list of rights names associated with the user's user group
        */
        RightNames: string[];
        /**
        * Describes the different states a user can assume.
        */
        UserState: VisiWin.System.UserManagement.UserState;
        /**
        * Changes the user.
        */
        ChangeAsync(userDefinition: VisiWin.System.UserManagement.IUserDefinition): Promise<VisiWin.System.UserManagement.ChangeUserSuccess>;
        /**
        * Moves the user to the specified user group.
        */
        MoveToGroupAsync(groupName: string): Promise<VisiWin.System.UserManagement.ChangeUserSuccess>;
        /**
        * Changes the password of a user.
        */
        ChangePasswordAsync(oldPassword: string, newPassword: string): Promise<VisiWin.System.UserManagement.ChangePasswordSuccess>;
        /**
        * Returns the user-defined UserDefinition object
        */
        GetDefinitionAsync(): Promise<VisiWin.System.UserManagement.IUserDefinition>;
        /**
        * Returns the UserGroup object associated with the user group name.
        */
        GetGroupAsync(userGroupName: string): Promise<VisiWin.System.UserManagement.IUserGroup>;
        /**
        * Reads a right.
        */
        GetRightAsync(rightName: string): Promise<VisiWin.System.UserManagement.IRight>;
    }
}
declare namespace VisiWin.System.UserManagement {
    /**
    *  Encapsulates the information of a user in the project database
    */
    interface IUserDefinition {
        /**
        * Determines the value for the "machine code" parameter.
        */
        Code: string;
        /**
        * Comment on the user.
        */
        Comment: string;
        DeactivationTime: Date;
        FailedLogOns: number;
        /**
        * Full name of the user.
        */
        FullName: string;
        /**
        * Determines the name of the user group the user belongs to.
        */
        GroupName: string;
        Password: string;
        /**
        * Logon name of the user.
        */
        Name: string;
        /**
        * Returns how many more times the user can try to log on before he is barred.
        */
        RemainingLogOns: number;
        /**
        * Indication of validity of current password in days.
        */
        RenewPassword: number;
        /**
        * Array of right names.
        */
        RightNames: string[];
        /**
        * public enum UserState
        * Describes the different states a user can assume.
        * @enum UserState
        */
        UserState: VisiWin.System.UserManagement.UserState;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @class
    * @name VisiWin.System.UserManagement.UserGroup
    * @description Encapsulates the parameters of a user group from the user administration.
    * @memberof VisiWin.System.UserManagement
    */
    interface IUserGroup extends VisiWin.Internal.System.IBaseClass {
        /**
        * Determines the value of the "Time until automatic logoff" parameter.
        * @member { number }
        */
        AutoLogOffTime: number;
        /**
        * Determines the comment on the definition.
        * @member { string }  Comment
        */
        Comment: string;
        /**
        * Determines the user level of the user goup.
        * @member { number }  Level
        */
        Level: number;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Determines the value of the "Maximum allowed failed logon attempts" parameter.
        * @member { number }  MaxFailedLogOns
        */
        MaxFailedLogOns: number;
        /**
       * Determines the name of the user group.
       * @member { string }
       */
        Name: string;
        /**
        * Determines the value of the "Password renewal inverval" parameter.
        * @member { number }
        */
        RenewPasswordInterval: number;
        /**
        * Specifies the names of the rights linked with the user group.
        * @member { string }
        */
        RightNames: string[];
        /**
        * Value of the "Runtime name" parameter from the project databank.
        * @member { string }
        */
        Text: string;
        /**
        * Returns an array of user names belonging to the user group.
        * @member { string }
        */
        UserNames: string[];
        /**
        * Returns whether users of this group can be deleted
        */
        UsersRemovable: boolean;
        /**@function
        * @description Returns an IUser object of the specified user.
        * @name  GetUser
        */
        GetUserAsync(userName: string): Promise<VisiWin.System.UserManagement.IUser>;
        /**@function
        * @description Returns an IRight object of the specified right.
        * @name  GetRight
        */
        GetRightAsync(rightName: string): Promise<VisiWin.System.UserManagement.IRight>;
        GetDefinitionAsync(): Promise<VisiWin.System.UserManagement.IUserGroupDefinition>;
    }
}
declare namespace VisiWin.System.UserManagement {
    /**
    * Encapsulates the parameters of a user group in the project database
    */
    interface IUserGroupDefinition {
        /**
        * Determines the value of the "Time until automatic logoff" parameter.
        */
        AutoLogOffTime: number;
        /**
        * Determines the comment on the definition.
        */
        Comment: string;
        /**
        * Sets the value of the Maximum Allowed Login Failure parameter
        */
        InvalidateAfterFailedLogOns: number;
        /**
        * Determines the user level of the user goup
        */
        Level: number;
        LocalizableText?: string;
        /**
        * Determines the value of the "Maximum allowed failed logon attempts" parameter.
        */
        MaxFailedLogOns: number;
        /**
        * Determines the name of the user group.
        */
        Name: string;
        /**
        * Sets the value of the Password Renewal Interval parameter
        */
        RenewPassword: number;
        /**
        * Determines the value of the "Password renewal inverval" parameter.
        */
        RenewPasswordInterval: number;
        /**
        * Specifies the names of the rights linked with the user group.
        */
        RightNames: string[];
        /**
        * Value of the "Runtime name" parameter from the project databank.
        */
        Text: string;
        /**
        * Returns an array of user names belonging to the user group.
        */
        UserNames: string[];
        /**
        * Returns whether users of this group can be deleted
        */
        UsersRemovable: boolean;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @class
    * @name VisiWin.System.UserManagement.UserManagementService
    * @description Entry point into the user management.
    * @memberof VisiWin.System.UserManagement
    */
    interface IUserManagementService extends VisiWin.Internal.System.IBaseClass {
        /**
        * Returns the system used in the user administration.
        * @member { VisiWin.System.UserManagement.AuthorizationSystemType }  AuthorizationSystem
        */
        AuthorizationSystem: VisiWin.System.UserManagement.AuthorizationSystemType;
        /**
        * Returns the user who is currently logged on.
        * @member {  VisiWin.System.UserManagement.IUser }
        */
        CurrentUser: VisiWin.System.UserManagement.IUser;
        /**
        * Returns the logon name of the user currently logged on to the system.
        * @member { string }  CurrentUserName
        */
        CurrentUserName: string;
        /**
        * Buffers a specifying a machine code for the parameterless overload of 'LogOn' method.
        * @member { string }  NewMachineCode
        */
        NewMachineCode: string;
        /**
        * Buffers the entry of a password for the parameterless overload of 'LogOn' method.
        * @member { string }  NewPassword
        */
        NewPassword: string;
        /**
        * Buffers specifying a login name for the parameterless overload of 'LogOn' method.
        * @member { string }  NewUserName
        */
        NewUserName: string;
        /**
        * List of all the right names for the current user.
        * @member { string }  RightNames
        */
        RightNames: string[];
        /**
        * Returns the time (in seconds) after which the user currently logged on in the system is automatically logged off
        * if no further operation is made in the application.
        * @member { number }  SecondsToAutoLogOff
        */
        SecondsToAutoLogOff: number;
        /**
        * Determines the names of the user groups for the current user.
        * @member { string }  UserGroupNames
        */
        UserGroupNames: string[];
        /**
        * List of login name for the current user.
        * @member { string }  UserNames
        */
        UserNames: string[];
        /**
        * Occurs when a user has logged on.
        * @event UserLoggedOn
        * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUser>}
        */
        UserLoggedOn: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUser>;
        /**
        * Occurs when a user has logged off.
        * @event UserLoggedOff
        * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUser>}
        */
        UserLoggedOff: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUser>;
        /**
         * Adds a new right to the user administration.
         */
        AddRightAsync(right: VisiWin.System.UserManagement.IRightDefinition): Promise<VisiWin.System.UserManagement.AddRightSuccess>;
        /**
        * Adds new rights to the user administration.
        */
        AddRightsAsync(rights: VisiWin.System.UserManagement.IRightDefinition[]): Promise<VisiWin.System.UserManagement.AddRightSuccess[]>;
        /**
        * Assigns a right to a group.
        */
        AddRightToGroupAsync(userGroupName: string, rightName: string): Promise<VisiWin.System.UserManagement.ChangeGroupSuccess>;
        /**
        * Adds a new user to the user management.
        */
        AddUserAsync(userDefinition: VisiWin.System.UserManagement.IUserDefinition): Promise<VisiWin.System.UserManagement.AddUserSuccess>;
        /**
        * Adds a new user group to the user administration.
        */
        AddUserGroupsAsync(userGroups: VisiWin.System.UserManagement.IUserGroupDefinition[]): Promise<VisiWin.System.UserManagement.AddGroupSuccess[]>;
        /**
        * Adds new user groups to the user administration.
        */
        AddUserGroupAsync(userGroup: VisiWin.System.UserManagement.IUserGroupDefinition): Promise<VisiWin.System.UserManagement.AddGroupSuccess>;
        /**
        * Saves the changes to a right definition object.
        */
        ChangeRightAsync(changedRight: VisiWin.System.UserManagement.IRightDefinition): Promise<VisiWin.System.UserManagement.ChangeRightSuccess>;
        /**
        * Saves the changes to the right definition objects.
        */
        ChangeRightsAsync(changedRight: VisiWin.System.UserManagement.IRightDefinition[]): Promise<VisiWin.System.UserManagement.ChangeRightSuccess[]>;
        /**
        * Changes an existing user.
        */
        ChangeUserAsync(userDefinition: VisiWin.System.UserManagement.IUserDefinition): Promise<VisiWin.System.UserManagement.ChangeUserSuccess>;
        /**
        * Changes the parameters of an already existing user group.
        */
        ChangeUserGroupAsync(userGroup: VisiWin.System.UserManagement.IUserGroupDefinition): Promise<VisiWin.System.UserManagement.ChangeGroupSuccess>;
        /**
        * Changes the parameters of already existing user groups.
        */
        ChangeUserGroupsAsync(userGroups: VisiWin.System.UserManagement.IUserGroupDefinition[]): Promise<VisiWin.System.UserManagement.ChangeGroupSuccess[]>;
        /**
        * Changes the password of a user.
        */
        ChangeUserPasswordAsync(userName: string, oldPassword: string, newPassword: string): Promise<VisiWin.System.UserManagement.ChangePasswordSuccess>;
        /**
        * Copies the specified user definition in the project database
        */
        CopyUserDefinitionAsync(existingUserName: string, newUserName: string, fullName: string, newPassword: string, newComment: string, newMachinecode: string): Promise<VisiWin.System.UserManagement.CopyUserSuccess>;
        /**
        * Copies the specified user definition in the project database
        */
        CopyUserGroupDefinitionAsync(newUserGroupName: string, existingUserGroupName: string): Promise<VisiWin.System.UserManagement.CopyGroupSuccess>;
        /**
        * Returns an Authorization object.
        */
        CreateAuthorization(): VisiWin.System.UserManagement.IAuthorization;
        /**
        * Creates a new RightDefinition object.
        */
        CreateRightDefinition(): VisiWin.System.UserManagement.IRightDefinition;
        /**
        * Creates a new UserDefinition object (for example for the AddUser method).
        */
        CreateUserDefinition(): VisiWin.System.UserManagement.IUserDefinition;
        /**
        * Creates a new UserGroupDefinition object (for example, for the AddUserGroup method)
        */
        CreateUserGroupDefinition(): VisiWin.System.UserManagement.IUserGroupDefinition;
        /**
        * Returns a class for functional linking of a control with the user administration
        */
        GetAuthorization(rightName: string): VisiWin.System.UserManagement.IAuthorization;
        /**
        * Reads rights.
        */
        GetRightsAsync(): Promise<VisiWin.System.UserManagement.IRight[]>;
        /**
        * Reads a right.
        */
        GetRightAsync(rightName: string): Promise<VisiWin.System.UserManagement.IRight>;
        /**
        * Returns the RightDefinition object associated with the right name.
        */
        GetRightDefinitionAsync(rightName: string): Promise<VisiWin.System.UserManagement.IRightDefinition>;
        /**
        * Returns the user object associated with the given login name.
        */
        GetUserAsync(userName: string): Promise<VisiWin.System.UserManagement.IUser>;
        /**
        * Returns all user objects
        */
        GetUsersAsync(): Promise<VisiWin.System.UserManagement.IUser[]>;
        /**
        * Returns the user-defined UserDefinition object
        */
        GetUserDefinitionAsync(userName: string): Promise<VisiWin.System.UserManagement.IUserDefinition>;
        /**
        * Returns the UserGroup object associated with the user group name.
        */
        GetUserGroupAsync(userGroupName: string): Promise<VisiWin.System.UserManagement.IUserGroup>;
        /**
        * Returns all UserGroup objects.
        */
        GetUserGroupsAsync(): Promise<VisiWin.System.UserManagement.IUserGroup[]>;
        /**
        * Returns the definition object associated with the specified user group name
        */
        GetUserGroupDefinitionAsync(userGroupName: string): Promise<VisiWin.System.UserManagement.IUserGroupDefinition>;
        /**
        *  Logs a user off!
        */
        LogOff(closeConnection?: boolean): void;
        /**
        *  Logs a user on.
        *  @param {string} name the login name
        *  @param {string} password the login password
        */
        LogOnAsync(name: string, password: string): Promise<VisiWin.System.UserManagement.LogOnSuccess>;
        LogOnAsync(name: string, password: string, code: string): Promise<VisiWin.System.UserManagement.LogOnSuccess>;
        LogOnAsync(name?: string, password?: string, code?: string): Promise<VisiWin.System.UserManagement.LogOnSuccess>;
        /**
        * Moves the specified user to the specified user group.
        */
        MoveUserToGroupAsync(userName: string, groupName: string): Promise<VisiWin.System.UserManagement.ChangeUserSuccess>;
        /**
        * Removes a right from the user administration.
        */
        RemoveRightAsync(rightName: string): Promise<VisiWin.System.UserManagement.RemoveRightSuccess>;
        /**
        * Removes a right from a group.
        */
        RemoveRightFromGroupAsync(userGroupName: string, rightName: string): Promise<VisiWin.System.UserManagement.ChangeGroupSuccess>;
        /**
        * Removes the user specified by the login name from the user management
        */
        RemoveUserAsync(userName: string): Promise<VisiWin.System.UserManagement.RemoveUserSuccess>;
        /**
        * Removes the users specified by the login names from the user management
        */
        RemoveUsersAsync(userNames: string[]): Promise<VisiWin.System.UserManagement.RemoveUserSuccess[]>;
        /**
        * Removes a user group from the user administration.
        */
        RemoveUserGroupAsync(groupName: string): Promise<VisiWin.System.UserManagement.RemoveGroupSuccess>;
        /**
        * Removes a user groups from the user administration.
        */
        RemoveUserGroupsAsync(groupNames: string[]): Promise<VisiWin.System.UserManagement.RemoveGroupSuccess[]>;
        /**
        * Allows verification of credentials (login name and password) without logging in.
        */
        VerifyUserAsync(userName: string, password: string): Promise<VisiWin.System.UserManagement.LogOnSuccess>;
        /**
        * Allows verification of credentials (login name, password, and machine code) without logging in
        */
        VerifyUserAsync(userName: string, password: string, code?: string): Promise<VisiWin.System.UserManagement.LogOnSuccess>;
        /**
        * Is triggered when rights where changed.
        * @event  VisiWin.System.UserManagement.UserManagementService.RightsModified
        * @type { VisiWin.System.UserManagement.IRightsModifiedEventArgs }
        *
        * @version available with WebGatewayProtocolVersion == 16 (2020.2)
        */
        RightsModified: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IRightsModifiedEventArgs>;
        /**
        * Is triggered when groups where changed.
        * @event  VisiWin.System.UserManagement.UserManagementService.GroupsModified
        * @type { VisiWin.System.UserManagement.IGroupsModifiedEventArgs }
        *
        * @version available with WebGatewayProtocolVersion == 16 (2020.2)
        */
        GroupsModified: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IGroupsModifiedEventArgs>;
        /**
        * Is triggered when users where changed.
        * @event  VisiWin.System.UserManagement.UserManagementService.UsersModified
        * @type { VisiWin.System.UserManagement.IUsersModifiedEventArgs }
        *
        * @version available with WebGatewayProtocolVersion == 16 (2020.2)
        */
        UsersModified: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUsersModifiedEventArgs>;
        GetUsersAndGroupsAsync(): Promise<VisiWin.System.UserManagement.IUserAndGroups>;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    *  Encapsulates the information of a user
    */
    interface IUserInfo {
        /**
        * Logon name of the user.
        */
        Name: string;
        /**
        * Full name of the user.
        */
        FullName: string;
        /**
        * Comment on the user.
        */
        Comment: string;
        /**
        * Determines the value for the "machine code" parameter.
        */
        Code: string;
        DeactivationTime: Date;
        /**
        * Determines the name of the user group the user belongs to.
        */
        GroupName: string;
        UserState: VisiWin.System.UserManagement.UserState;
        /**
        * Returns how many more times the user can try to log on before he is barred.
        */
        RemainingLogOns: number;
        /**
        * Indication of validity of current password in days.
        */
        RenewPassword: number;
    }
}
declare namespace VisiWin.System.UserManagement {
    /**
    * Occurs when a user has changed.
    * @event UsersModifiedEventArgs
    * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUsersModifiedEventArgs>}
    */
    interface IUsersModifiedEventArgs {
        /**
        * Cause enum, for items modified on server.
        */
        Cause: VisiWin.System.UserManagement.ItemModifiedCause;
        /**
        * UserInfo[] contains the changed users.
        */
        Users: VisiWin.System.UserManagement.IUserInfo[];
    }
    interface IRightsModifiedEventArgs {
        /**
        * Cause enum, for items modified on server.
        */
        Cause: VisiWin.System.UserManagement.ItemModifiedCause;
        /**
        * RightDefinition[]  contains the changed rights.
        */
        Rights: VisiWin.System.UserManagement.IRightDefinition[];
    }
    interface IGroupsModifiedEventArgs {
        /**
        * Cause enum, for items modified on server.
        */
        Cause: VisiWin.System.UserManagement.ItemModifiedCause;
        /**
        * UserGroupDefinition[] contains the changed groups.
        */
        Groups: VisiWin.System.UserManagement.IUserGroupDefinition[];
    }
}
declare namespace VisiWin.System.UserManagement {
    interface IUserAndGroups {
        UserGroups: VisiWin.System.UserManagement.IUserGroup[];
        Users: VisiWin.System.UserManagement.IUser[];
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @class
    * @name VisiWin.System.UserManagement.User
    * @description Contains the information on a user contained in the user administration.
    * @memberof VisiWin.System.UserManagement
    */
    abstract class User extends VisiWin.Internal.System.BaseClass implements VisiWin.System.UserManagement.IUser {
        /**
        * Determines the value for the "machine code" parameter.
        * @member { string }  Code
        */
        Code: string;
        /**
        * Comment on the user.
        * @member { string }  Comment
        */
        Comment: string;
        /**
        * Specifies the time when the user was locked or deactivated.
        */
        DeactivationTime: Date;
        /**
        * Full name of the user.
        * @member { string }  FullName
        */
        FullName: string;
        /**
        * Determines the name of the user group the user belongs to.
        * @member { string }  GroupName
        */
        GroupName: string;
        /**
        * Logon name of the user.
        * @member { string }  Name
        */
        Name: string;
        /**
        * Returns how many more times the user can try to log on before he is barred.
        * @member { number }  RemainingLogOns
        */
        RemainingLogOns: number;
        /**
        * Indication of validity of current password in days.
        * @member { number }  RenewPassword
        */
        RenewPassword: number;
        /**
        * Returns a list of rights names associated with the user's user group
        */
        RightNames: string[];
        /**
        * Describes the different states a user can assume.
        */
        UserState: VisiWin.System.UserManagement.UserState;
        /**
        * Changes the user.
        */
        ChangeAsync(userDefinition: VisiWin.System.UserManagement.IUserDefinition): Promise<VisiWin.System.UserManagement.ChangeUserSuccess>;
        /**
        * Moves the user to the specified user group.
        */
        MoveToGroupAsync(groupName: string): Promise<VisiWin.System.UserManagement.ChangeUserSuccess>;
        /**
        * Changes the password of a user.
        */
        ChangePasswordAsync(oldPassword: string, newPassword: string): Promise<VisiWin.System.UserManagement.ChangePasswordSuccess>;
        /**
        * Returns the user-defined UserDefinition object
        */
        GetDefinitionAsync(): Promise<VisiWin.System.UserManagement.IUserDefinition>;
        /**
        * Returns the UserGroup object associated with the user group name.
        */
        GetGroupAsync(userGroupName: string): Promise<VisiWin.System.UserManagement.IUserGroup>;
        /**
        * Reads a right.
        */
        GetRightAsync(rightName: string): Promise<VisiWin.System.UserManagement.IRight>;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @class
    * @name VisiWin.System.UserManagement.UserGroup
    * @description Encapsulates the parameters of a user group from the user administration.
    * @memberof VisiWin.System.UserManagement
    */
    abstract class UserGroup extends VisiWin.Internal.System.BaseClass implements VisiWin.System.UserManagement.IUserGroup {
        /**
        * Determines the value of the "Time until automatic logoff" parameter.
        * @member { number }
        */
        AutoLogOffTime: number;
        /**
        * Determines the comment on the definition.
        * @member { string }  Comment
        */
        Comment: string;
        /**
        * Determines the user level of the user goup.
        * @member { number }  Level
        */
        Level: number;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Determines the value of the "Maximum allowed failed logon attempts" parameter.
        * @member { number }  MaxFailedLogOns
        */
        MaxFailedLogOns: number;
        /**
       * Determines the name of the user group.
       * @member { string }
       */
        Name: string;
        /**
        * Determines the value of the "Password renewal inverval" parameter.
        * @member { number }
        */
        RenewPasswordInterval: number;
        /**
        * Specifies the names of the rights linked with the user group.
        * @member { string }
        */
        RightNames: string[];
        /**
        * Value of the "Runtime name" parameter from the project databank.
        * @member { string }
        */
        Text: string;
        /**
        * Returns an array of user names belonging to the user group.
        * @member { string }
        */
        UserNames: string[];
        /**
        * Returns whether users of this group can be deleted
        */
        UsersRemovable: boolean;
        /**@function
        * @description Returns an IUser object of the specified user.
        * @name  GetUser
        */
        GetUserAsync(userName: string): Promise<VisiWin.System.UserManagement.IUser>;
        /**@function
        * @description Returns an IRight object of the specified right.
        * @name  GetRight
        */
        GetRightAsync(rightName: string): Promise<VisiWin.System.UserManagement.IRight>;
        GetDefinitionAsync(): Promise<VisiWin.System.UserManagement.IUserGroupDefinition>;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @class
    * @name VisiWin.System.UserManagement.Right
    * @description Class allowing access to a right of the VisiWin user administration.
    * @memberof VisiWin.System.UserManagement
    */
    abstract class Right extends VisiWin.Internal.System.BaseClass implements VisiWin.System.UserManagement.IRight {
        /**
        * Determines whether the right is active.
        * @member { boolean }  Active
        */
        Active: boolean;
        /**
        * Determines the comment on the right.
        * @member { string }  Comment
        */
        Comment: string;
        /**
        * Specifies the names of the user groups linked with the right.
        * @member { string } UserGroupNames
        */
        UserGroupNames: string[];
        /**
        * Determines the name of the right.
        * @member { string }  Name
        */
        Name: string;
        /**
        * Value of the "Runtime name" parameter from the project databank.
        * @member { string }  Text
        */
        Text: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**@function
        * @description Returns an object encapsulating the parameters of a right of the user administration.
        * @name  GetUserGroup
        */
        GetUserGroupAsync(userGroupName: string): Promise<VisiWin.System.UserManagement.IUserGroup>;
        /**
        * Saves the changes to a rights object
        */
        ChangeAsync(changedRight: VisiWin.System.UserManagement.IRightDefinition): Promise<VisiWin.System.UserManagement.ChangeRightSuccess>;
        /**
        * Returns an object that can be used to edit the parameters of the right in the project database.
        */
        GetDefinitionAsync(): Promise<VisiWin.System.UserManagement.IRightDefinition>;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @class
    * @name VisiWin.System.UserManagement.UserManagementService
    * @description Entry point into the user management.
    * @memberof VisiWin.System.UserManagement
    */
    class UserManagementService extends VisiWin.Internal.System.BaseClass implements VisiWin.System.UserManagement.IUserManagementService {
        /**
        * Returns the system used in the user administration.
        * @member { VisiWin.System.UserManagement.AuthorizationSystemType }  AuthorizationSystem
        */
        AuthorizationSystem: VisiWin.System.UserManagement.AuthorizationSystemType;
        /**
        * Returns the user who is currently logged on.
        * @member {  VisiWin.System.UserManagement.IUser }
        */
        CurrentUser: VisiWin.System.UserManagement.IUser;
        /**
        * Returns the logon name of the user currently logged on to the system.
        * @member { string }  CurrentUserName
        */
        CurrentUserName: string;
        /**
        * Buffers a specifying a machine code for the parameterless overload of 'LogOn' method.
        * @member { string }  NewMachineCode
        */
        NewMachineCode: string;
        /**
        * Buffers the entry of a password for the parameterless overload of 'LogOn' method.
        * @member { string }  NewPassword
        */
        NewPassword: string;
        /**
        * Buffers specifying a login name for the parameterless overload of 'LogOn' method.
        * @member { string }  NewUserName
        */
        NewUserName: string;
        /**
        * List of all the right names for the current user.
        * @member { string }  RightNames
        */
        RightNames: string[];
        /**
        * Returns the time (in seconds) after which the user currently logged on in the system is automatically logged off
        * if no further operation is made in the application.
        * @member { number }  SecondsToAutoLogOff
        */
        SecondsToAutoLogOff: number;
        /**
        * Determines the names of the user groups for the current user.
        * @member { string }  UserGroupNames
        */
        UserGroupNames: string[];
        /**
        * List of login name for the current user.
        * @member { string }  UserNames
        */
        UserNames: string[];
        /**
        * Occurs when a user has logged on.
        * @event UserLoggedOn
        * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUser>}
        */
        UserLoggedOn: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUser>;
        /**
        * Occurs when a user has logged off.
        * @event UserLoggedOff
        * @type {VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUser>}
        */
        UserLoggedOff: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUser>;
        static getService(): UserManagementService;
        /**
         * Adds a new right to the user administration.
         */
        AddRightAsync(right: VisiWin.System.UserManagement.IRightDefinition): Promise<VisiWin.System.UserManagement.AddRightSuccess>;
        /**
        * Adds new rights to the user administration.
        */
        AddRightsAsync(rights: VisiWin.System.UserManagement.IRightDefinition[]): Promise<VisiWin.System.UserManagement.AddRightSuccess[]>;
        /**
        * Assigns a right to a group.
        */
        AddRightToGroupAsync(userGroupName: string, rightName: string): Promise<VisiWin.System.UserManagement.ChangeGroupSuccess>;
        /**
        * Adds a new user to the user management.
        */
        AddUserAsync(userDefinition: VisiWin.System.UserManagement.IUserDefinition): Promise<VisiWin.System.UserManagement.AddUserSuccess>;
        /**
        * Adds a new user group to the user administration.
        */
        AddUserGroupsAsync(userGroups: VisiWin.System.UserManagement.IUserGroupDefinition[]): Promise<VisiWin.System.UserManagement.AddGroupSuccess[]>;
        /**
        * Adds new user groups to the user administration.
        */
        AddUserGroupAsync(userGroup: VisiWin.System.UserManagement.IUserGroupDefinition): Promise<VisiWin.System.UserManagement.AddGroupSuccess>;
        /**
        * Saves the changes to a right definition object.
        */
        ChangeRightAsync(changedRight: VisiWin.System.UserManagement.IRightDefinition): Promise<VisiWin.System.UserManagement.ChangeRightSuccess>;
        /**
        * Saves the changes to the right definition objects.
        */
        ChangeRightsAsync(changedRight: VisiWin.System.UserManagement.IRightDefinition[]): Promise<VisiWin.System.UserManagement.ChangeRightSuccess[]>;
        /**
        * Changes an existing user.
        */
        ChangeUserAsync(userDefinition: VisiWin.System.UserManagement.IUserDefinition): Promise<VisiWin.System.UserManagement.ChangeUserSuccess>;
        /**
        * Changes the parameters of an already existing user group.
        */
        ChangeUserGroupAsync(userGroup: VisiWin.System.UserManagement.IUserGroupDefinition): Promise<VisiWin.System.UserManagement.ChangeGroupSuccess>;
        /**
        * Changes the parameters of already existing user groups.
        */
        ChangeUserGroupsAsync(userGroups: VisiWin.System.UserManagement.IUserGroupDefinition[]): Promise<VisiWin.System.UserManagement.ChangeGroupSuccess[]>;
        /**
        * Changes the password of a user.
        */
        ChangeUserPasswordAsync(userName: string, oldPassword: string, newPassword: string): Promise<VisiWin.System.UserManagement.ChangePasswordSuccess>;
        /**
        * Copies the specified user definition in the project database
        */
        CopyUserDefinitionAsync(existingUserName: string, newUserName: string, fullName: string, newPassword: string, newComment: string, newMachinecode: string): Promise<VisiWin.System.UserManagement.CopyUserSuccess>;
        /**
        * Copies the specified user definition in the project database
        */
        CopyUserGroupDefinitionAsync(newUserGroupName: string, existingUserGroupName: string): Promise<VisiWin.System.UserManagement.CopyGroupSuccess>;
        /**
        * Returns an Authorization object.
        */
        CreateAuthorization(): VisiWin.System.UserManagement.IAuthorization;
        /**
        * Creates a new RightDefinition object.
        */
        CreateRightDefinition(): VisiWin.System.UserManagement.IRightDefinition;
        /**
        * Creates a new UserDefinition object (for example for the AddUser method).
        */
        CreateUserDefinition(): VisiWin.System.UserManagement.IUserDefinition;
        /**
        * Creates a new UserGroupDefinition object (for example, for the AddUserGroup method)
        */
        CreateUserGroupDefinition(): VisiWin.System.UserManagement.IUserGroupDefinition;
        /**
        * Returns a class for functional linking of a control with the user administration
        */
        GetAuthorization(rightName: string): VisiWin.System.UserManagement.IAuthorization;
        /**
        * Reads rights.
        */
        GetRightsAsync(): Promise<VisiWin.System.UserManagement.IRight[]>;
        /**
        * Reads a right.
        */
        GetRightAsync(rightName: string): Promise<VisiWin.System.UserManagement.IRight>;
        /**
        * Returns the RightDefinition object associated with the right name.
        */
        GetRightDefinitionAsync(rightName: string): Promise<VisiWin.System.UserManagement.IRightDefinition>;
        /**
        * Returns the user object associated with the given login name.
        */
        GetUserAsync(userName: string): Promise<VisiWin.System.UserManagement.IUser>;
        /**
        * Returns all user objects
        */
        GetUsersAsync(): Promise<VisiWin.System.UserManagement.IUser[]>;
        /**
        * Returns the user-defined UserDefinition object
        */
        GetUserDefinitionAsync(userName: string): Promise<VisiWin.System.UserManagement.IUserDefinition>;
        /**
        * Returns the UserGroup object associated with the user group name.
        */
        GetUserGroupAsync(userGroupName: string): Promise<VisiWin.System.UserManagement.IUserGroup>;
        /**
        * Returns all UserGroup objects.
        */
        GetUserGroupsAsync(): Promise<VisiWin.System.UserManagement.IUserGroup[]>;
        /**
        * Returns the definition object associated with the specified user group name
        */
        GetUserGroupDefinitionAsync(userGroupName: string): Promise<VisiWin.System.UserManagement.IUserGroupDefinition>;
        /**
        *  Logs a user off!
        */
        LogOff(closeConnection?: boolean): void;
        /**
        *  Logs a user on.
        *  @param {string} name the login name
        *  @param {string} password the login password
        */
        LogOnAsync(name: string, password: string): Promise<VisiWin.System.UserManagement.LogOnSuccess>;
        LogOnAsync(name: string, password: string, code: string): Promise<VisiWin.System.UserManagement.LogOnSuccess>;
        /**
        * Moves the specified user to the specified user group.
        */
        MoveUserToGroupAsync(userName: string, groupName: string): Promise<VisiWin.System.UserManagement.ChangeUserSuccess>;
        /**
        * Removes a right from the user administration.
        */
        RemoveRightAsync(rightName: string): Promise<VisiWin.System.UserManagement.RemoveRightSuccess>;
        /**
        * Removes a right from a group.
        */
        RemoveRightFromGroupAsync(userGroupName: string, rightName: string): Promise<VisiWin.System.UserManagement.ChangeGroupSuccess>;
        /**
        * Removes the user specified by the login name from the user management
        */
        RemoveUserAsync(userName: string): Promise<VisiWin.System.UserManagement.RemoveUserSuccess>;
        /**
        * Removes the users specified by the login names from the user management
        */
        RemoveUsersAsync(userNames: string[]): Promise<VisiWin.System.UserManagement.RemoveUserSuccess[]>;
        /**
        * Removes a user group from the user administration.
        */
        RemoveUserGroupAsync(groupName: string): Promise<VisiWin.System.UserManagement.RemoveGroupSuccess>;
        /**
        * Removes a user groups from the user administration.
        */
        RemoveUserGroupsAsync(groupNames: string[]): Promise<VisiWin.System.UserManagement.RemoveGroupSuccess[]>;
        /**
        * Allows verification of credentials (login name and password) without logging in.
        */
        VerifyUserAsync(userName: string, password: string): Promise<VisiWin.System.UserManagement.LogOnSuccess>;
        /**
        * Is triggered when rights where changed.
        * @event  VisiWin.System.UserManagement.UserManagementService.RightsModified
        * @type { VisiWin.System.UserManagement.IRightsModifiedEventArgs }
        *
        * @version available with WebGatewayProtocolVersion == 16 (2020.2)
        */
        RightsModified: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IRightsModifiedEventArgs>;
        /**
        * Is triggered when groups where changed.
        * @event  VisiWin.System.UserManagement.UserManagementService.GroupsModified
        * @type { VisiWin.System.UserManagement.IGroupsModifiedEventArgs }
        *
        * @version available with WebGatewayProtocolVersion == 16 (2020.2)
        */
        GroupsModified: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IGroupsModifiedEventArgs>;
        /**
        * Is triggered when users where changed.
        * @event  VisiWin.System.UserManagement.UserManagementService.UsersModified
        * @type { VisiWin.System.UserManagement.IUsersModifiedEventArgs }
        *
        * @version available with WebGatewayProtocolVersion == 16 (2020.2)
        */
        UsersModified: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.UserManagement.IUsersModifiedEventArgs>;
        GetUsersAndGroupsAsync(): Promise<VisiWin.System.UserManagement.IUserAndGroups>;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
     * public enum AuthorizationSystemType
     * Enumerates the available user administration systems
     * @enum AuthorizationSystemType
     */
    enum AuthorizationSystemType {
        /**
        * Level-orientated user administration
        */
        Level = 0,
        /**
        * Rights-orientated user administration
        */
        Rights = 1
    }
    /**
     * public enum AddGroupSuccess
     * Enumeration containing the possible return values of the 'Add' method of a 'UserGroup' object.
     * @enum AddGroupSuccess
     */
    enum AddGroupSuccess {
        /**
        * The user group was successfully added to the project.
        */
        Succeeded = 0,
        /**
        * The group already exists. Comparison with existing user groups is done by name.
        */
        GroupAlreadyDefined = 1,
        /**
        * The method could not be carried out. (The server is currently not accessible.).
        */
        MethodCallFailed = 2,
        /**
        * In the passed object, a property is not initialized that is necessary to add the user group. This error message usually refers to the uninitialized property 'Name' of the passed object.
        */
        WrongParam = 3,
        /**
        * One of the specified rights could not be found in the project databank.
        */
        UnknownRight = 4,
        /**
        * The information of the new group could not be stored.
        */
        UnableToSaveGroup = 5
    }
    /**
     * public enum AddRightSuccess
     * Enumeration containing the possible return values of the 'Add' method of a 'Rights' object
     * @enum AddRightSuccess
     */
    enum AddRightSuccess {
        /**
        * The right was successfully added to the project.
        */
        Succeeded = 0,
        /**
        * The right already exists. Comparison with existing rights is via the name.
        */
        RightAlreadyDefined = 1,
        /**
        * The method could not be carried out. (The server is currently not accessible.)
        */
        MethodCallFailed = 2,
        /**
        * A property in the passed object required for adding the right is not initialized.
        * This error message mostly refers to the non-initialized 'Name' property of the passed 'Right' object.
        */
        WrongParam = 3,
        /**
        * The method could not be carried out. This value points to the following error:
        * Rights have no function in the level-orientated user administration. They are not used. Therefore adding new rights is denied by the system.
        */
        NotValidForAuthorizationSystem = 4,
        /**
        * The information of the new right could not be stored.
        */
        UnableToSaveRight = 5
    }
    /**
     * public enum AddUserSuccess
     * Describes the result of adding a user
     * @enum AddUserSuccess
     */
    enum AddUserSuccess {
        /**
        * Adding the user was successfull.
        */
        Succeeded = 0,
        /**
        * The specified password does not reach the number of characters specified by the system.
        */
        InvalidPasswordLength = 1,
        /**
        * The password is empty.
        */
        InvalidPassword = 2,
        /**
        * The indicated Logon name already exists in the user administration ("Name", "Logon name" and "MachineCode" must be system-wide unequivocal for the user)
        */
        UserExists = 3,
        /**
        * The server function could not store the information.
        */
        UnableToSaveUser = 4,
        /**
        * The server could not be accessed.
        */
        MethodCallFailed = 5,
        /**
        * The specified password contains no letters. But this is prescribed by the system.
        */
        NoCharactersInPassword = 6,
        /**
        * The specified password contains no numbers. But this is prescribed by the system.
        */
        NoNumbersInPassword = 7,
        /**
        * The specified password contains no special characters. But this is prescribed by the system.
        */
        PasswordMustContainSpecialCharacters = 8,
        /**
        * The specified password is explicitly prohibited (indicated as "locked password") and must not be used.
        */
        ForbiddenPassword = 9,
        /**
        * The indicated name already exists in the user administration ("Name", "Logon name" and "MachineCode" must be system-wide unequivocal for the user).
        */
        FullUserExists = 10,
        /**
        * The indicated machine code  already exists in the user administration ("Name", "Logon name" and "MachineCode" must be system-wide unequivocal for the user).
        */
        MachineCodeExists = 11,
        /**
        * The specified password cannot be used as it violates the rules of the user administration configuration.
        * This refers to the setting of "Password can be re-used after ... days/password changes".
        */
        LockedPassword = 12,
        /**
        * The specified user group was not found in the project
        */
        UnknownGroup = 13
    }
    /**
     * public enum ChangeGroupSuccess
     * Enumeration containing the possible return values of the 'Change'/'Remove' methods of a 'UserGroup' object.
     * @enum ChangeGroupSuccess
     */
    enum ChangeGroupSuccess {
        /**
        * The parameter change of the indicated user group was effected.
        */
        Succeeded = 0,
        /**
        * The specified user group is not known to the server. A user group with this name does not exist.
        */
        UnknownGroup = 1,
        /**
        * The method could not be carried out. (The server is currently not accessible.)
        */
        MethodCallFailed = 2,
        /**
        * One of the specified rights could not be found in the project databank.
        */
        UnknownRight = 3,
        /**
        * The information of the group could not be stored.
        */
        UnableToSaveGroup = 4,
        /**
        * The user group can not be deleted because the parameter "Users of this group may be deleted" is not active, so that the users can not be deleted, the group also becomes indelible.
        */
        DeleteNotPermitted = 5,
        /**
        * The user group whose parameters were to be changed could not be found in the project databank.
        */
        InvalidGroup = 6
    }
    /**
     * public enum ChangePasswordSuccess
     * Describes the result with a user password change.
     * @enum ChangePasswordSuccess
     */
    enum ChangePasswordSuccess {
        /**
        * The password was successfully changed.
        */
        Succeeded = 0,
        /**
        * The indicated user was not found in the user administration.
        */
        UnknownUser = 1,
        /**
        * Entering the old password was incorrect.
        */
        OldPasswordInvalid = 2,
        /**
        * The server function could not store the information.
        */
        UnableToSavePassword = 3,
        /**
        * The specified password does not reach the number of characters specified by the system.
        */
        NewPasswordInvalidLength = 4,
        /**
        * The password is empty
        */
        NewPasswordInvalid = 5,
        /**
        * The server could not be accessed.
        */
        MethodCallFailed = 6,
        /**
        * The specified password contains no letters. But this is prescribed by the system.
        */
        NoCharactersInPassword = 7,
        /**
        * The specified password contains no numbers. But this is prescribed by the system.
        */
        NoNumbersInPassword = 8,
        /**
        * The specified password contains no special characters. But this is prescribed by the system.
        */
        PasswordMustContainSpecialCharacters = 9,
        /**
        * The specified password is explicitly prohibited and must not be used.
        */
        ForbiddenPassword = 10,
        /**
        * The specified domain could not be found or the domain could not be accessed.
        * This return value is only to be expected if the "Use domain user administration" option was activated via the user administration configuration.
        */
        CantAccessDomainInfo = 11,
        /**
        * The specified password cannot be used as it violates the rules of the user administration configuration.
        * This refers to the setting of "Password can be re-used after ... days/password changes".
        */
        LockedPassword = 12
    }
    /**
     * public enum ChangeRightSuccess
     * Contains the possible return values of the 'Change' method of a 'Rights' object.
     * @enum ChangeRightSuccess
     */
    enum ChangeRightSuccess {
        /**
        * The parameter change of the indicated right was effected.
        */
        Succeeded = 0,
        /**
        * The indicated right is not known to the system. A right with this name does not exist.
        */
        UnknownRight = 1,
        /**
        * The server function could not store the information.
        */
        UnableToSaveRight = 2,
        /**
        * The method could not be carried out. (The server is currently not accessible.)
        */
        MethodCallFailed = 3,
        /**
        * One of the linked user groups could not be found.
        */
        UnknownGroup = 4
    }
    /**
     * public enum ChangeUserSuccess
     * Describes the results with a user properties change.
     * @enum ChangeUserSuccess
     */
    enum ChangeUserSuccess {
        /**
        * The user properties were successfully changed.
        */
        Succeeded = 0,
        /**
        * The indicated user was not found in the user administration.
        */
        UnknownUser = 1,
        /**
        * The specified user group was not found in the user administration
        */
        UnknownUserClass = 2,
        /**
        * The server function could not store the information.
        */
        UnableToSaveUser = 3,
        /**
        * The specified password does not reach the number of characters specified by the system.
        */
        InvalidPasswordLength = 4,
        /**
        * The password is empty
        */
        InvalidPassword = 5,
        /**
        * The server could not be accessed.
        */
        MethodCallFailed = 6,
        /**
        * The specified password contains no letters. But this is prescribed by the system.
        */
        NoCharactersInPassword = 7,
        /**
        * The specified password contains no numbers. But this is prescribed by the system.
        */
        NoNumbersInPassword = 8,
        /**
        * The specified password contains no special characters. But this is prescribed by the system.
        */
        PasswordMustContainSpecialCharacters = 9,
        /**
        * The specified password is explicitly prohibited and must not be used.
        */
        ForbiddenPassword = 10,
        /**
        * The indicated name already exists in the user administration ("Name", "Logon name" and "MachineCode" must be system-wide unequivocal for the user).
        */
        FullUserExists = 11,
        /**
        * The indicated machine code  already exists in the user administration ("Name", "Logon name" and "MachineCode" must be system-wide unequivocal for the user).
        */
        MachineCodeExists = 12,
        /**
        * The specified password cannot be used as it violates the rules of the user administration configuration. This refers to the setting of "Password can be re-used after ... days/password changes".
        */
        LockedPassword = 13,
        /**
        * The change to another user group is not possible because the "Users of this group may be deleted" option is NOT activated in the current croup.
        */
        InvalidUserClass = 14
    }
    /**
     * public enum CopyGroupSuccess
     * Describes the results for a group copy.
     * @enum CopyGroupSuccess
     */
    enum CopyGroupSuccess {
        /**
        * The user group has been successfully added to the project.
        */
        Succeeded = 0,
        /**
        * The group already exists. The comparison with existing user groups runs over the name.
        */
        GroupAlreadyDefined = 1,
        /**
        * The method could not be executed (the server is not available at the moment)
        */
        MethodCallFailed = 2,
        /**
        * In the passed object, a property is not initialized that is necessary to add the user group. This error message usually refers to the uninitialized property 'Name' of the passed object.
        */
        WrongParam = 3,
        /**
        * One of the specified rights could not be found in the project database.
        */
        UnknownRight = 4,
        /**
        * The information of the new group could not be saved.
        */
        UnableToSaveGroup = 5,
        /**
        * The specified user group is unknown to the system. A user group with this name is not available.
        */
        UnknownGroup = 6
    }
    /**
     * public enum CopyUserSuccess
     * Describes the results for a user copy.
     * @enum CopyUserSuccess
     */
    enum CopyUserSuccess {
        /**
        * The creation of the user was successful.
        */
        Succeeded = 0,
        /**
        * The specified password does not reach the number of characters specified by the system.
        */
        InvalidPasswordLength = 1,
        /**
        * The password is empty
        */
        InvalidPassword = 2,
        /**
        * The specified login name already exists in the user administration (for the user "name", "login name" and "machine code" must be unique throughout the system).
        */
        UserExists = 3,
        /**
        * The function in the server could not save the information.
        */
        UnableToSaveUser = 4,
        /**
        * The server could not be reached.
        */
        MethodCallFailed = 5,
        /**
        * The specified password contains no letters. But this is prescribed by the system.
        */
        NoCharactersInPassword = 6,
        /**
        * The specified password contains no numbers. But this is prescribed by the system.
        */
        NoNumbersInPassword = 7,
        /**
        * The specified password contains no special characters. But this is prescribed by the system.
        */
        PasswordMustContainSpecialCharacters = 8,
        /**
        * The specified password is explicitly prohibited (indicated as "locked password") and must not be used.
        */
        ForbiddenPassword = 9,
        /**
        * The specified name already exists in the user administration (for the user "name", "login name" and "machine code" must be unique throughout the system).
        */
        FullUserExists = 10,
        /**
        * The specified machine code already exists in the user administration (for the user, "name", "login name" and "machine code" must be unique throughout the system).
        */
        MachineCodeExists = 11,
        /**
        * The specified password can not be used to violate the user management configuration rules. This refers to the settings "Password reusable after ... days / password changes".
        */
        LockedPassword = 12,
        /**
        * The specified user group was not found in the project.
        */
        UnknownGroup = 13,
        /**
        * The specified user was not found in the project.
        */
        UnknownUser = 14
    }
    /**
     * public enum LogOnSuccess
     * Describes the result of the user log-on.
     * @enum LogOnSuccess
     */
    enum LogOnSuccess {
        /**
        * The indicated user could not be logged on. The user is unknown.
        */
        UnknownUser = 0,
        /**
        * The specified user could not be logged on. The specified password is wrong.
        */
        InvalidPassword = 1,
        /**
        * The indicated user was successfully logged on.
        */
        Succeeded = 2,
        /**
        * The indicated user could not be logged on. The user is deactivated.
        */
        UserDeactivated = 3,
        /**
        * The specified user could not be logged on.
        * The specified password has expired due to the "Password renewal interval" parameter.
        */
        PasswordExpired = 4,
        /**
        * The indicated user could not be logged on.
        * The user was deactivated by the system due to the set number of faulty logon attempts having been exceeded.
        */
        TooManyFailedLogOns = 5,
        /**
        * The specified user could not be logged on.
        * He must first change the password allocated by the administrator.
        * Then he can log on with the new password. This response is to be expected if the "Status" parameter of a new user is set to "Activated, change password next time".
        */
        RenewPassword = 6,
        /**
        * In the domain user administration the specified user was allocated to a group that could not be found in the project databank.
        */
        NoCorrespondingLocalUserClass = 7,
        /**
        * The specified domain could not be found or the domain could not be accessed.
        * This return value is only to be expected if the "Use domain user administration" option was activated via the user administration configuration.
        */
        CantAccessDomainInfo = 8,
        /**
        * The server could not be accessed.
        */
        MethodCallFailed = 9
    }
    /**
     * public enum RightCombination
     * Settings that describe the combination of rights as a specification for a visualization element
     * @enum RightCombination
     */
    enum RightCombination {
        /**
        *
        */
        NONE = 0,
        /**
        *
        */
        AND = 1,
        /**
        *
        */
        OR = 2
    }
    /**
    * public enum UserState
     * Describes the different states a user can assume.
     * @enum UserState
     */
    enum UserState {
        /**
         * The user was deactivated by the user administration in the application. This makes sense, for example, if a user is not expected to work with the visualization for an extended period of time.
         */
        Deactivated = 0,
        /**
         * The user is active, and can log on to the system.
         */
        Active = 1,
        /**
         * The user was deactivated by the system. A system deactivation occurs if a user logs on incorrectly too often or ignores the interval-controlled request for password change.
         */
        Invalidated = 2,
        /**
        * The entered password has expired.
        */
        PasswordExpired = 3,
        /**
        * The user is not known to the system.
        */
        Unknown = 4
    }
    /**
    * Describes the result of method calls for removing a right.
    */
    enum RemoveRightSuccess {
        /**
        * The method could not be carried out. (The server is currently not accessible.)
        */
        MethodCallFailed = 0,
        /**
        * The right was successfully removed from the project.
        */
        Succeeded = 1,
        /**
        * The specified right is unknown to the system. A right with this name is not available.
        */
        UnknownRight = 2,
        /**
        * The function in the server could not save the information.
        */
        UnableToSaveRight = 3
    }
    /**
    * Describes the result of method calls for removing a user.
    */
    enum RemoveUserSuccess {
        /**
        * The method could not be carried out. (The server is currently not accessible.)
        */
        MethodCallFailed = 0,
        /**
        * The user was successfully removed froom the project.
        */
        Succeeded = 1,
        /**
        * The indicated user was not found in the user administration.
        */
        UnknownUser = 2,
        /**
        * The specified user group is not known to the server. A user group with this name does not exist.
        */
        UnknownGroup = 3,
        /**
        * The function in the server could not save the information.
        */
        UnableToSaveUser = 4,
        /**
        * Delete Permitted
        */
        DeletePermitted = 5
    }
    /**
    * Describes the result of method calls for removing a user group.
    */
    enum RemoveGroupSuccess {
        /**
        * The parameter change of the indicated user group was effected.
        */
        Succeeded = 0,
        /**
        * The specified user group is not known to the server. A user group with this name does not exist.
        */
        UnknownGroup = 1,
        /**
        * The method could not be carried out. (The server is currently not accessible.)
        */
        MethodCallFailed = 2,
        /**
        * One of the specified rights could not be found in the project databank.
        */
        UnknownRight = 3,
        /**
        * The information of the group could not be stored.
        */
        UnableToSaveGroup = 4,
        /**
        * The user group can not be deleted because the parameter "Users of this group may be deleted" is not active, so that the users can not be deleted, the group also becomes indelible.
        */
        DeleteNotPermitted = 5,
        /**
        * The user group whose parameters were to be changed could not be found in the project databank.
        */
        InvalidGroup = 6
    }
    /**
    * Describes the result of method calls for verifying a user password.
    */
    enum VerifyPasswordSuccess {
        /**
        * The method could not be carried out. (The server is currently not accessible.)
        */
        MethodCallFailed = 0,
        /**
        * The users password was successfully verified.
        */
        Succeeded = 1,
        /**
        * The indicated user was not found in the user administration.
        */
        UnknownUser = 2,
        ViolatedPolicies = 3,
        /**
        * Entering the old password was incorrect.
        */
        OldPasswordInvalid = 4,
        /**
        * The specified domain could not be found or the domain could not be accessed.
        * This return value is only to be expected if the "Use domain user administration" option was activated via the user administration configuration.
        */
        CantAccessDomainInfo = 5,
        /**
        * The specified password cannot be used as it violates the rules of the user administration configuration.
        * This refers to the setting of "Password can be re-used after ... days/password changes".
        */
        LockedPassword = 6
    }
    /**
    * General enum, for items modified on server.
    */
    enum ItemModifiedCause {
        /**
        * The item has changed.
        */
        Changed = 0,
        /**
        * The item has added.
        */
        Added = 1,
        /**
        * The item was removed.
        */
        Removed = 2
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @class
    * @name VisiWin.System.UserManagement.Authorization
    * @description Class for functional linking of a control with the user administration.
    * @memberof VisiWin.System.UserManagement
    */
    abstract class Authorization extends VisiWin.Internal.System.BaseClass implements VisiWin.System.UserManagement.IAuthorization {
        /**
        * Is triggered when the authorization changes
        * @event Changed
        * @type {VisiWin.Internal.System.Events.IEventArgs<boolean>}
        */
        Changed: VisiWin.Internal.System.Events.IEventArgs<boolean>;
        /**
        * Indication of authorization by the user administration.
        * @member { boolean }  IsAuthorized
        */
        IsAuthorized: boolean;
        /**
        * Determines the right or the user level.
        * @member { string }  Right
        */
        Right: string;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @deprecated Do not use. Use CreateUserDefinition() from UserManagementService instead.
    */
    class UserDefinition implements VisiWin.System.UserManagement.IUserDefinition {
        /**
        * Determines the value for the "machine code" parameter.
        * @member { string }  Code
        */
        Code: string;
        /**
        * Comment on the user.
        * @member { string }  Comment
        */
        Comment: string;
        /**
        * Specifies the time when the user was locked or deactivated.
        */
        DeactivationTime: Date;
        /**
        * Full name of the user.
        * @member { string }  FullName
        */
        FullName: string;
        /**
        * Determines the name of the user group the user belongs to.
        * @member { string }  GroupName
        */
        GroupName: string;
        /**
        * Logon name of the user.
        * @member { string }  Name
        */
        Name: string;
        /**
        * Returns how many more times the user can try to log on before he is barred.
        * @member { number }  RemainingLogOns
        */
        RemainingLogOns: number;
        /**
        * Indication of validity of current password in days.
        * @member { number }  RenewPassword
        */
        RenewPassword: number;
        /**
        * Returns a list of rights names associated with the user's user group
        */
        RightNames: string[];
        /**
        * @deprecated Do not use. Use UserState instead.
        * @ignore
        */
        /**
        * public enum UserState
        * Describes the different states a user can assume.
        * @enum UserState
        */
        UserState: VisiWin.System.UserManagement.UserState;
        /**
        * Password
        */
        Password: any;
        /**
        * FailedLogOns
        */
        FailedLogOns: number;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    *  Encapsulates the information of a user
    */
    abstract class UserInfo implements VisiWin.System.UserManagement.IUserInfo {
        /**
        * Logon name of the user.
        */
        Name: string;
        /**
        * Full name of the user.
        */
        FullName: string;
        /**
        * Comment on the user.
        */
        Comment: string;
        /**
        * Determines the value for the "machine code" parameter.
        */
        Code: string;
        DeactivationTime: Date;
        /**
        * Determines the name of the user group the user belongs to.
        */
        GroupName: string;
        UserState: VisiWin.System.UserManagement.UserState;
        /**
        * Returns how many more times the user can try to log on before he is barred.
        */
        RemainingLogOns: number;
        /**
        * Indication of validity of current password in days.
        */
        RenewPassword: number;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
     * @deprecated Do not use. Use CreateUserGroupDefinition() from UserManagementService instead.
    */
    class UserGroupDefinition implements VisiWin.System.UserManagement.IUserGroupDefinition {
        /**
        * Determines the value of the "Time until automatic logoff" parameter.
        */
        AutoLogOffTime: number;
        /**
        * Determines the comment on the definition.
        */
        Comment: string;
        /**
        * Sets the value of the Maximum Allowed Login Failure parameter
        */
        InvalidateAfterFailedLogOns: number;
        /**
        * Determines the user level of the user goup
        */
        Level: number;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Determines the value of the "Maximum allowed failed logon attempts" parameter.
        */
        MaxFailedLogOns: number;
        /**
        * Determines the name of the user group.
        */
        Name: string;
        /**
        * Sets the value of the Password Renewal Interval parameter
        */
        RenewPassword: number;
        /**
        * Determines the value of the "Password renewal inverval" parameter.
        */
        RenewPasswordInterval: number;
        /**
        * Specifies the names of the rights linked with the user group.
        */
        RightNames: string[];
        /**
        * Value of the "Runtime name" parameter from the project databank.
        */
        Text: string;
        /**
        * Returns an array of user names belonging to the user group.
        */
        UserNames: string[];
        /**
        * Returns whether users of this group can be deleted
        */
        UsersRemovable: boolean;
    }
}
/**
* @namespace
* @name VisiWin.System.UserManagement
*/
declare namespace VisiWin.System.UserManagement {
    /**
    * @deprecated Do not use. Use CreateRightDefinition () from UserManagementService instead.
    */
    class RightDefinition implements VisiWin.System.UserManagement.IRightDefinition {
        /**
        * Determines whether the right is active.
        */
        Active: boolean;
        /**
        * Determines the comment on the right.
        */
        Comment: string;
        /**
        * Returns the internally used unequivocal identification of the localizable text.
        * @member { string } LocalizableText
        */
        LocalizableText: string;
        /**
        * Determines the name of the right.
        */
        Name: string;
    }
}
/**
* @namespace
* @name VisiWin.System.Service
*/
declare namespace VisiWin.System.Service {
    interface IBlinkService {
        CurrentState: boolean;
        MainBlinkCycle: number;
        MainBlinkEnable: boolean;
        CreateBlinkTimer(): void;
        GetBlinkTimer(blinkCycle: number, enable: boolean): void;
        DoBlink: VisiWin.Internal.System.Events.IEventArgs<boolean>;
    }
    class BlinkService implements VisiWin.System.Service.IBlinkService {
        private static blinky;
        private blinkState;
        private _timer;
        CurrentState: boolean;
        DoBlink: VisiWin.Internal.System.Events.IEventArgs<boolean>;
        private constructor();
        static getService(): VisiWin.System.Service.BlinkService;
        private _mainBlinkCycle;
        get MainBlinkCycle(): number;
        set MainBlinkCycle(value: number);
        private _blinkEnabled;
        get MainBlinkEnable(): boolean;
        set MainBlinkEnable(value: boolean);
        CreateBlinkTimer(): BlinkTimer;
        GetBlinkTimer(blinkCycle?: number, enabled?: boolean): BlinkTimer;
        private StartBlinkSystem;
        private StopBlinkSystem;
    }
}
/**
* @namespace
* @name VisiWin.System.Service
*/
declare namespace VisiWin.System.Service {
    interface IBlinkTimer {
        BlinkCycle: number;
        CurrentState: boolean;
        Enable: boolean;
        OnBlink: VisiWin.Internal.System.Events.IEventArgs<boolean>;
    }
    class BlinkTimer implements VisiWin.System.Service.IBlinkTimer {
        CurrentState: boolean;
        OnBlink: VisiWin.Internal.System.Events.IEventArgs<boolean>;
        private _blinkService;
        private _blinkCounter;
        private onBlinkHandler;
        private fireBlinkEvent;
        constructor();
        private _blinkCycle;
        get BlinkCycle(): number;
        set BlinkCycle(value: number);
        private _blinkEnabled;
        get Enable(): boolean;
        set Enable(value: boolean);
        dispose(): void;
    }
}
declare namespace VisiWin.System.Client {
    class ClientService extends VisiWin.Internal.System.BaseClass implements VisiWin.System.Client.IClientService {
        ClientState: VisiWin.System.Client.ClientState;
        ClientStateChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Client.ClientState>;
        CommunicationState: VisiWin.System.Client.CommunicationState;
        CommunicationStateChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Client.CommunicationState>;
        static getService(): VisiWin.System.Client.IClientService;
    }
}
declare namespace VisiWin.System.Client {
    /**
    * IClientService Interface
    *
    * </br>
    * <a href="../tutorials/Client/IClientService.html">
    * ClientService example
    * </a>
    */
    interface IClientService extends VisiWin.Internal.System.IBaseClass {
        /**
        * The current client state
        */
        ClientState: VisiWin.System.Client.ClientState;
        /**
        * triggerd if client state changed
        */
        ClientStateChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Client.ClientState>;
        /**
        * The current communication state
        */
        CommunicationState: VisiWin.System.Client.CommunicationState;
        /**
       * triggerd if communication state changed
       */
        CommunicationStateChanged: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Client.CommunicationState>;
    }
    /**
    * Contains the available states for the WebSocket.readyState.
    * public enum CommunicationState
    * @enum CommunicationState
    */
    enum CommunicationState {
        /**
        * The socket has been created. The connection is not yet open.
        */
        Connecting = 0,
        /**
        * The connection is open and ready to communicate.
        */
        Open = 1,
        /**
        * The connection is in the process of closing.
        */
        Closing = 2,
        /**
        * The connection is closed or couldn't be opened.
        */
        Closed = 3
    }
    /**
    * Enumeration for the current ClientState.
    * public enum ClientState
    * @enum ClientState
    */
    enum ClientState {
        /**
        * The default state before start is called
        */
        Unloaded = 0,
        /**
        * Client is on starting
        */
        Starting = 1,
        /**
        * Client is running
        */
        Running = 2,
        /**
        * Client is stoped, all systems are disposed. Restart required.
        */
        Stopped = 3,
        /**
        * Communication is unauthorized there is no user logged in
        */
        Paused = 4,
        /**
        * The client is shuting down and will dispose all systems
        */
        OnExit = 5,
        /**
        * Error during start up
        */
        Error = 6,
        /**
        * Socket communication not available.
        */
        SocketNotAvailable = 7,
        /**
        * Client state undetermined. Possible PingPong timeout between gateway and client. Communication may be unstable.
        */
        CommunicationUnclear = 8,
        /**
        *   Client finished start up, but with errors.
        */
        Uncertain = 9,
        /**
        * The server was restarted, so the client must be restarted.
        */
        RestartRequired = 10
    }
}
declare namespace VisiWin.Internal.Application.Settings.Strings {
    function errorStringsWithParams(LCID: number, commonErrorString: commonErrorString, param1?: string, param2?: string): string;
    enum commonErrorString {
        SocketError = "SocketError",
        LicenseError = "LicenseError",
        StartupError = "StartupError",
        SocketTimeout = "SocketTimeout",
        DemoMode = "DemoMode"
    }
}
/**
* @namespace
* @name VisiWin.System.Core
*/
declare namespace VisiWin.System.Core {
    /**
    * @method
    * @name VisiWin.System.Core.StartCore
    * @description  Start up method, if no VisiWin UI is desired
    * @param settings: VisiWin.Application.IAppSettings
    * @memberof VisiWin.System.Core
    *
    * </br>
    * <a href="../tutorials/Project/ProjectStart.html">
    * Project start example
    * </a>
    */
    function StartCore(settings?: VisiWin.Application.IAppSettings): void;
    function StartCoreAwaitLogOn(settings?: VisiWin.Application.IAppSettings, useCallbackFn?: boolean): Promise<any>;
    /**
    * @event
    * @name VisiWin.System.Core.CoreReady
    * @description  Triggered if VisiWin is ready to use
    * @memberof VisiWin.System.Core
    */
    const CoreReady: VisiWin.Internal.System.Events.IEventArgs<VisiWin.Application.Start.IStartUpInfo>;
    /**
    * @event
    * @name VisiWin.System.Core.CoreError
    * @description  Triggered if VisiWin detect errors on system start.
    * @memberof VisiWin.System.Core
    */
    const CoreError: VisiWin.Internal.System.Events.IEventArgs<VisiWin.Application.Start.IStartUpInfo>;
}
declare namespace VisiWin.Internal.Application.Settings {
    interface ISystemSettings {
        [index: string]: any;
        /** @ignore */
        AppDomainsToLog: number[];
        /** @ignore */
        AppDomainCategoriesToLog: number[];
        /** @ignore */
        SystemLoader: string[];
        /** @ignore */
        LogStackSize: number;
        /** @ignore */
        EnableVisiWinPerformanceMarks: boolean;
        EneableVisiWinPerformanceMarks: boolean;
        /** @ignore */
        WebSocketReconnects: number;
        /** @ignore */
        WebSocketReconnectInterval: number;
        /** @ignore */
        EnableWebSocketReconnects: boolean;
        /** @ignore */
        ObserveWebSocketConnectionTimeout: boolean;
        /** @ignore */
        WebSocketConnectionTimeout: number;
        /** @ignore */
        ProtokollVersion: number;
        /** @ignore */
        MaxTrendSamples: number;
        /** @ignore */
        DeprecatedWarningEneabled: boolean;
        DeprecatedWarningEnabled: boolean;
        /** @ignore */
        WebClientProtocolVersion: number;
        /** @ignore */
        WebGatewayProtocolVersion: number;
        /**
         * @description Displays additional debug information.
         * @member Debug=false
         * @type {boolean}
         */
        Debug: boolean;
        /**
         * @description Determines whether and what type of output is generated while debugging.
         * @description Options Off:5,  All: 1, Info: 2, Warn: 3, Error: 4
         * @member DebugLogLevel=3
         * @type {number}
         */
        DebugLogLevel: number;
        /**
         * @description The version of the current VisiWinJS.js file
         * @member VisiWinVersion
         * @type {number}
         */
        VisiWinVersion: number;
        /**
        * @description Watchdog for monitoring the project start.
        * @member ProjectStartTimeout = 120000 ms
        * @type {number}
        */
        ProjectStartTimeout: number;
        /**
        * @description Defines the command collector delay.
        * @description Value in milliseconds.
        * @description If the value is too short, the number of commands increases and loads the server more heavily.
        * @description If the value is too high, there will be noticeable delay.
        * @member AttachDelay=50
        * @type {number}
        */
        AttachDelay: number;
        /**
        * @description Determines whether the ping pong commands should be observed
        * @description If the serve send no ping, a warning log is created.
        * @member ObservePingPongTimeout = true
        * @type {boolean}
        */
        ObservePingPongTimeout: boolean;
        /**
        * @description  Watchdog for monitoring the ping pong frames.
        * @description If the serve send no ping, a warning log is created after this timeout.
        * @member PingPongTimeout = 60000
        * @type {number}
        */
        PingPongTimeout: number;
        /** @ignore */
        DeactivateEventQueue: boolean;
    }
    class SystemSettings implements VisiWin.Internal.Application.Settings.ISystemSettings {
        /** @ignore */
        AppDomainsToLog: number[];
        /** @ignore */
        AppDomainCategoriesToLog: number[];
        /** @ignore */
        SystemLoader: string[];
        /** @ignore */
        LogStackSize: number;
        /** @ignore */
        EnableVisiWinPerformanceMarks: boolean;
        /** @ignore */
        private _EneableVisiWinPerformanceMarks;
        /** @ignore */
        get EneableVisiWinPerformanceMarks(): boolean;
        /** @ignore */
        set EneableVisiWinPerformanceMarks(value: boolean);
        /** @ignore */
        WebSocketReconnects: number;
        /** @ignore */
        WebSocketReconnectInterval: number;
        /** @ignore */
        EnableWebSocketReconnencts: boolean;
        /** @ignore */
        EnableWebSocketReconnects: boolean;
        /** @ignore */
        ObserveWebSocketConnectionTimeout: boolean;
        /** @ignore */
        WebSocketConnectionTimeout: number;
        /** @ignore */
        ProtokollVersion: number;
        /** @ignore */
        MaxTrendSamples: number;
        /** @ignore */
        DeprecatedWarningEnabled: boolean;
        private _DeprecatedWarningEneabled;
        get DeprecatedWarningEneabled(): boolean;
        set DeprecatedWarningEneabled(value: boolean);
        /** @ignore */
        WebClientProtocolVersion: number;
        /** @ignore */
        WebGatewayProtocolVersion: number;
        /** @ignore */
        private _Debug;
        /**
         * @description Displays additional debug information.
         * @member Debug=false
         * @type {boolean}
         */
        get Debug(): boolean;
        set Debug(value: boolean);
        /** @ignore */
        private _DebugLogLevel;
        /**
         * @description Determines whether and what type of output is generated while debugging.
         * @description Options Off:5,  All: 1, Info: 2, Warn: 3, Error: 4
         * @member DebugLogLevel=3
         * @type {number}
         */
        get DebugLogLevel(): number;
        set DebugLogLevel(value: number);
        /** @ignore */
        private _VisiWinVersion;
        /**
         * @description The version of the current VisiWinJS.js file
         * @member VisiWinVersion
         * @type {number}
         */
        get VisiWinVersion(): number;
        set VisiWinVersion(value: number);
        /** @ignore */
        private _ProjectStartTimeout;
        /**
        * @description Watchdog for monitoring the project start.
        * @member ProjectStartTimeout = 120000 ms
        * @type {number}
        */
        get ProjectStartTimeout(): number;
        set ProjectStartTimeout(value: number);
        /** @ignore */
        private _AttachDelay;
        /**
        * @description Defines the command collector delay.
        * @description Value in milliseconds.
        * @description If the value is too short, the number of commands increases and loads the server more heavily.
        * @description If the value is too high, there will be noticeable delay.
        * @member AttachDelay=50
        * @type {number}
        */
        get AttachDelay(): number;
        set AttachDelay(value: number);
        /** @ignore */
        private _ObservePingPongTimeout;
        /**
        * @description Determines whether the ping pong commands should be observed
        * @description If the serve send no ping, a warning log is created.
        * @member ObservePingPongTimeout = true
        * @type {boolean}
        */
        get ObservePingPongTimeout(): boolean;
        set ObservePingPongTimeout(value: boolean);
        /** @ignore */
        private _PingPongTimeout;
        /**
        * @description  Watchdog for monitoring the ping pong frames.
        * @description If the serve send no ping, a warning log is created after this timeout.
        * @member PingPongTimeout = 60000
        * @type {number}
        */
        get PingPongTimeout(): number;
        set PingPongTimeout(value: number);
        /** @ignore */
        DeactivateEventQueue: boolean;
    }
}
declare namespace VisiWin.Internal.Application.Settings {
    interface IClientSettings {
        [index: string]: any;
        /** @ignore */
        IsSingleSession: boolean;
        /** @ignore */
        IsDefaultSession: boolean;
        /** @ignore */
        AutoCompleteStartupAfterLogon: boolean;
        /** @ignore */
        TelegramVersion: number;
        /**
         * @description Determines whether the user is automatically logged in.
         * @description Requires DefaultUser and DefaultPassword.
         * @member AutoLogin=false
         * @type {boolean}
         */
        AutoLogin: boolean;
        /**
         * @description The default user for the automatic log in.
         * @member DefaultUser=""
         * @type {string}
         */
        DefaultUser: string;
        /**
         * @description The default password for the automatic log in.
         * @member DefaultPassword=""
         * @type {string}
         */
        DefaultPassword: string;
        /**
         * @description Determines the client's LCID for the initial language.
         * @member ClientLCID=1031
         * @type {number}
         */
        ClientLCID: number;
        /**
         * @description The clients utc offset. For date calculation.
         * @member ClientUTCOffset=(new Date().getTimezoneOffset() / 60) * -1;
         * @type {number}
         */
        ClientUTCOffset: number;
        /**
         * @description Determines how a string inside a LocalizedText is replaced
         * @description if the LocalizedText contains a line break, e. g. "\n"
         * @description The search string can be replaced by the LineBreakReplaceString to display it correctly in the HTML element.
         * @description The default search value is "\\n".
         * @member LineBreakSearchString
         * @type {string}
         * @deprecated use EscapeStringReplacement
         */
        LineBreakSearchString: string;
        /**
         * @description Determines the string that replaces the line break from Settings.Client.LineBreakString.
         * @description Default replace value "\r\n".
         * @description Requires one of the following CSS properties: "white-space: pre / pre-wrap / pre-line / break-spaces;".
         * @description If no replacement is desired, the properties LineBreakString and LineBreakReplaceString must contain an empty string.
         * @member LineBreakReplaceString
         * @type {string}
         * @deprecated use EscapeStringReplacement
         */
        LineBreakReplaceString: string;
        /**
         * @description Determines how a string inside a LocalizedText are replaced
         * @description The search string will be replaced by the replace string.
         * @description The default search value is  [{ search: "\\n", replace: "\r\n" }, { search: "\\t", replace: "\t" }].
         * @description Array of objects, { search: string, replace: string }.
         * @member EscapeStringReplacement
         * @type { { search: string, replace: string }[] }
         */
        EscapeStringReplacement: {
            search: string;
            replace: string;
        }[];
    }
    class ClientSettings implements VisiWin.Internal.Application.Settings.IClientSettings {
        /** @ignore */
        IsSingleSession: boolean;
        /** @ignore */
        IsDefaultSession: boolean;
        /** @ignore */
        AutoCompleteStartupAfterLogon: boolean;
        /** @ignore */
        TelegramVersion: number;
        /** @ignore */
        private _AutoLogin;
        /**
         * @description Determines whether the user is automatically logged in.
         * @description Requires DefaultUser and DefaultPassword.
         * @member AutoLogin=false
         * @type {boolean}
         */
        get AutoLogin(): boolean;
        set AutoLogin(value: boolean);
        /** @ignore */
        private _DefaultUser;
        /**
         * @description The default user for the automatic log in.
         * @member DefaultUser=""
         * @type {string}
         */
        get DefaultUser(): string;
        set DefaultUser(value: string);
        /** @ignore */
        private _DefaultPassword;
        /**
         * @description The default password for the automatic log in.
         * @member DefaultPassword=""
         * @type {string}
         */
        get DefaultPassword(): string;
        set DefaultPassword(value: string);
        /** @ignore */
        private _ClientLCID;
        /**
         * @description Determines the client's LCID for the initial language.
         * @member ClientLCID=1031
         * @type {number}
         */
        get ClientLCID(): number;
        set ClientLCID(value: number);
        /** @ignore */
        private _ClientUTCOffset;
        /**
         * @description The clients utc offset. For date calculation.
         * @member ClientUTCOffset=(new Date().getTimezoneOffset() / 60) * -1;
         * @type {number}
         */
        get ClientUTCOffset(): number;
        set ClientUTCOffset(value: number);
        /** @ignore */
        private _LineBreakSearchString;
        /**
         * @description Determines how a string inside a LocalizedText is replaced
         * @description if the LocalizedText contains a line break, e. g. "\n"
         * @description The search string can be replaced by the LineBreakReplaceString to display it correctly in the HTML element.
         * @description The default search value is "\\n".
         * @member LineBreakSearchString
         * @type {string}
         */
        get LineBreakSearchString(): string;
        set LineBreakSearchString(value: string);
        /** @ignore */
        private _LineBreakReplaceString;
        /**
         * @description Determines the string that replaces the line break from Settings.Client.LineBreakString.
         * @description Default replace value "\r\n"
         * @description Requires one of the following CSS properties: "white-space: pre / pre-wrap / pre-line / break-spaces;".
         * @description If no replacement is desired, the properties LineBreakString and LineBreakReplaceString must contain an empty string.
         * @member LineBreakReplaceString
         * @type {string}
         */
        get LineBreakReplaceString(): string;
        set LineBreakReplaceString(value: string);
        private _escapeStringReplacement;
        /**
         * @description Determines how a string inside a LocalizedText are replaced
         * @description The key as search string can be replaced by the ReplaceEscapeStrings.
         * @description The default search value is { "\\n": "\n", "\\t": "\t"  }.
         * @member EscapeStringReplacement
         * @type { { [key: string]: string } }
         */
        get EscapeStringReplacement(): {
            search: string;
            replace: string;
        }[];
        set EscapeStringReplacement(value: {
            search: string;
            replace: string;
        }[]);
    }
}
declare namespace VisiWin.Internal.Application.Settings {
    interface IServerSettings {
        [index: string]: any;
        /** @ignore */
        ConnectionTimeout: number;
        /**
         * @description Web socket protokoll prefix
         * @member WebSocketPrefix="ws://"
         * @type {string}
         */
        WebSocketPrefix: string;
        /**
         * @description Web socket host name
         * @member WebSocketHost=window.location.hostname
         * @type {string}
         */
        WebSocketHost: string;
        /**
         * @description Web socket port number
         * @member WebSocketPort=2016
         * @type {number}
         * @summary If you change the default WebSocket Port in VisiWin 7 ServerManager UI,
         * you must change this port also.
         */
        WebSocketPort: number;
        /**
         * @description Web socket uri parameter(optional)
         * @member WebSocketUriParameter="/path/param?=123"
         * @type {string}
         */
        WebSocketUriParameter?: string;
        /**
         * @description Web socket Uri
         * @member SocketUri="ws://localhost:2016"
         * @type {string}
         */
        SocketUri: string;
        /**
         * @description Name of the project to start through
         * @member ServerProjectName=""
         * @type {string}
         */
        ServerProjectName: string;
        /**
         * @description The server project version
         * @member RuntimeVersion
         * @type {number}
         */
        RuntimeVersion: number;
        /**
         * @description Either use a secure socket(wss)
         * @member UseSecureServer=false
         * @type {boolean}
         * @summary If UseSecureServer=true, "wss://location.hostname:location.port/some/params";
         * If UseSecureServer=false, "ws://location.hostname:2016/some/params";
         */
        UseSecureServer: boolean;
        /**
         * @description Specifies the timeout(seconds) reserved for monitoring the start of a server project, within the web gateway.
         * The parameter is optional. The default value is 300 seconds.
         * @member ServerProjectStartTimeout
         * @type {number}
         */
        ServerProjectStartTimeout: number;
    }
    class ServerSettings implements VisiWin.Internal.Application.Settings.IServerSettings {
        /** @ignore */
        ConnectionTimeout: number;
        /** @ignore */
        private validateSocketUri;
        /** @ignore */
        private _webSocketPrefix;
        /**
        * @description Web socket protokoll prefix
        * @member WebSocketPrefix="ws://"
        * @type {string}
        */
        get WebSocketPrefix(): string;
        set WebSocketPrefix(value: string);
        /** @ignore */
        private _webSocketHost;
        /**
         * @description Web socket host name
         * @member WebSocketHost=window.location.hostname
         * @type {string}
         */
        get WebSocketHost(): string;
        set WebSocketHost(value: string);
        /** @ignore */
        private _webSocketPort;
        /**
        * @description Web socket port number
        * @member WebSocketPort=2016
        * @type {number}
        */
        get WebSocketPort(): number;
        set WebSocketPort(value: number);
        /** @ignore */
        private _webSocketUriParameter;
        /**
        * @description Web socket uri parameter(optional)
        * @member WebSocketUriParameter="/path/param?=123"
        * @type {string}
        */
        get WebSocketUriParameter(): string;
        set WebSocketUriParameter(value: string);
        /** @ignore */
        private _socketUri;
        /**
         * @description Web socket Uri
         * @description If set, all WebSocket parameters are ignored
         * @member SocketUri="ws://localhost:2016"
         * @type {string}
         */
        get SocketUri(): string;
        set SocketUri(value: string);
        /** @ignore */
        private _ServerProjectName;
        /**
         * @description Name of the project to start through
         * @member ServerProjectName=""
         * @type {string}
         */
        get ServerProjectName(): string;
        set ServerProjectName(value: string);
        /** @ignore */
        private _RuntimeVersion;
        /**
         * @description The server project version
         * @member RuntimeVersion
         * @type {number}
         */
        get RuntimeVersion(): number;
        set RuntimeVersion(value: number);
        /** @ignore */
        private _UseSecureServer;
        /**
        * @description Determines whether to use a secure socket(wss).
        * @member UseSecureServer=false
        * @type {boolean}
        * @summary If UseSecureServer=true, "wss://location.hostname:location.port/some/params";
        * If UseSecureServer=false, "ws://location.hostname:2016/some/params";
        */
        get UseSecureServer(): boolean;
        set UseSecureServer(value: boolean);
        private _ServerProjectStartTimeout;
        /**
         * @description Specifies the timeout(seconds) reserved for monitoring the start of a server project, within the web gateway.
         * The parameter is optional. The default value is 300 seconds.
         * @member ServerProjectStartTimeout
         * @type {number}
         */
        get ServerProjectStartTimeout(): number;
        set ServerProjectStartTimeout(value: number);
    }
}
declare namespace VisiWin.Internal.Application.Settings {
    interface ISecureServerSettings {
        [index: string]: any;
        /**
         * @description Web socket protokoll prefix
         * @member WebSocketPrefix="wss://"
         * @type {string}
         */
        WebSocketPrefix: string;
        /**
         * @description Web socket host name
         * @member WebSocketHost=window.location.hostname
         * @type {string}
         */
        WebSocketHost: string;
        /**
         * @description Web socket port number
         * @member WebSocketPort=window.location.port
         * @type {number}
         */
        WebSocketPort: number;
        /**
         * @description Web socket uri parameter(optional)
         * @member WebSocketUriParameter="/path/param?=123"
         * @type {string}
         */
        WebSocketUriParameter?: string;
    }
    class SecureServerSettings implements VisiWin.Internal.Application.Settings.ISecureServerSettings {
        /** @ignore */
        private _webSocketPrefix;
        /**
        * @description Web socket protokoll prefix
        * @member WebSocketPrefix="ws://"
        * @type {string}
        */
        get WebSocketPrefix(): string;
        set WebSocketPrefix(value: string);
        /** @ignore */
        private _webSocketHost;
        /**
         * @description Web socket host name
         * @member WebSocketHost=window.location.hostname
         * @type {string}
         */
        get WebSocketHost(): string;
        set WebSocketHost(value: string);
        /** @ignore */
        private _webSocketPort;
        /**
        * @description Web socket port number
        * @member WebSocketPort=2016
        * @type {number}
        */
        get WebSocketPort(): number;
        set WebSocketPort(value: number);
        /** @ignore */
        private _webSocketUriParameter;
        /**
        * @description Web socket uri parameter(optional)
        * @member WebSocketUriParameter="/path/param?=123"
        * @type {string}
        */
        get WebSocketUriParameter(): string;
        set WebSocketUriParameter(value: string);
    }
}
declare namespace VisiWin.Application {
    /** @ignore */
    const VersionString = "7.3";
    /** @ignore */
    const VersionNumber = 7.3;
    /** @ignore */
    const VersionNumberMdb = 7.2;
    /** @ignore */
    const VersionNumberIoT = 7.3;
    interface IAppSettings {
        [backwardCompatibility: string]: any;
        System: VisiWin.Internal.Application.Settings.ISystemSettings;
        Server: VisiWin.Internal.Application.Settings.IServerSettings;
        SecureServer: VisiWin.Internal.Application.Settings.ISecureServerSettings;
        Client: VisiWin.Internal.Application.Settings.IClientSettings;
        UI: any;
        AppServices: any;
    }
    class AppSettings implements VisiWin.Application.IAppSettings {
        System: VisiWin.Internal.Application.Settings.ISystemSettings;
        Server: VisiWin.Internal.Application.Settings.IServerSettings;
        SecureServer: VisiWin.Internal.Application.Settings.ISecureServerSettings;
        Client: VisiWin.Internal.Application.Settings.IClientSettings;
        UI: any;
        AppServices: any;
        constructor();
    }
    function _writeSetterError(property: string, value: any, orgValue: any, source: string): void;
    let Settings: VisiWin.Application.IAppSettings;
}
declare namespace VisiWin.Application.Start {
    const onInitReady: VisiWin.Internal.System.Events.IEventArgs<VisiWin.Application.Start.IStartUpInfo>;
    const onInitError: VisiWin.Internal.System.Events.IEventArgs<VisiWin.Application.Start.IStartUpInfo>;
    const startUpProgress: VisiWin.Internal.System.Events.IEventArgs<VisiWin.Application.Start.IStartUpInfo>;
    interface ISocketInfo {
        State: number;
        IsOnline: boolean;
        Url: string;
    }
    interface IResult {
        Succeeded: boolean;
        Result: string;
    }
    interface IConnection extends IResult {
        Socket: ISocketInfo | null;
    }
    interface IProject extends IResult {
        ProjectName: string;
    }
    interface IUser extends IResult {
        LogOnSuccess: VisiWin.System.UserManagement.LogOnSuccess | null;
    }
    interface ILanguage extends IResult {
        CurrentLanguage: number | null;
        ProjectLanguage: string | null;
    }
    interface IAlarm extends IResult {
        ClassNames: string[] | null;
        GroupNames: string[] | null;
        AlarmClasses: VisiWin.System.Alarm.IAlarmClass[] | null;
        AlarmGroups: VisiWin.System.Alarm.IAlarmGroup[] | null;
    }
    interface ITrend extends IResult {
        ArchiveNames: string[] | null;
    }
    interface IRecipe extends IResult {
        RecipeClassNames: string[] | null;
    }
    interface ILogging extends IResult {
        CategoryNames: string[] | null;
        Categories: VisiWin.System.Logging.ILoggingCategory[] | null;
    }
    interface IStartUpInfo {
        [key: string]: any;
        Connection: IConnection;
        Project: IProject;
        User: IUser;
        Language: ILanguage;
        Alarm: IAlarm;
        Trend: ITrend;
        Logging: ILogging;
        Recipe: IRecipe;
        StartUp: string[];
        LastSystem: string;
        HasError: boolean;
    }
    let StartUpInfo: IStartUpInfo;
}
declare namespace VisiWin.UI.CSSProperties {
    /**
    * @description  <br><br>
    * The background-color CSS property sets the background color of an element.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-color|background-color(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } backgroundColor
    */
    type backgroundColor = string;
    /**
    * @description  <br><br>
    * The color CSS property sets the foreground color value of an element's text.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color|color(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } foregroundColor
    */
    type foregroundColor = string;
    /**
    * @description  <br><br>
    * The border-color shorthand CSS property sets the color of an element's border.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color|border-color(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } borderColor
    */
    type borderColor = string;
    /**
    * @description  <br><br>
    * The margin CSS shorthand property sets the margin area on all four sides of an element.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin|margin(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } margin
    */
    type margin = string;
    /**
    * @description  <br><br>
    * The padding CSS shorthand property sets the padding area on all four sides of an element at once.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding|padding(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } padding
    */
    type padding = string;
    /**
    * @description  <br><br>
    * The height CSS property specifies the height of an element.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/height|height(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } height
    */
    type height = string;
    /**
    * @description  <br><br>
    * The width CSS property sets an element's width.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/width|width(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } width
    */
    type width = string;
    /**
    * @description  <br><br>
    * The min-width CSS property sets the minimum width of an element. <br>
    * It prevents the used value of the width property from becoming smaller than the value specified for min-width.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/min-width|minWidth(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } minWidth
    */
    type minWidth = string;
    /**
    * @description  <br><br>
    * The max-width CSS property sets the maximum width of an element. <br>
    * It prevents the used value of the width property from becoming larger than the value specified by max-width.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/max-width|maxWidth(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } maxWidth
    */
    type maxWidth = string;
    /**
    * @description  <br><br>
    * The min-height CSS property sets the minimum height of an element.<br>
    * It prevents the used value of the height property from becoming smaller than the value specified for min-height.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/min-height|minHeight(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } minHeight
    */
    type minHeight = string;
    /**
    * @description  <br><br>
    * The max-height CSS property sets the maximum height of an element.<br>
    * It prevents the used value of the height property from becoming larger than the value specified for max-height.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/max-height|maxHeight(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } maxHeight
    */
    type maxHeight = string;
    /**
    * @description  <br><br>
    * The top CSS property participates in specifying the vertical position of a positioned element. It has no effect on non-positioned elements.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/top|top(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } top
    */
    type top = string;
    /**
    * @description  <br><br>
    * The bottom CSS property participates in setting the vertical position of a positioned element. It has no effect on non-positioned elements.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/bottom|bottom(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } bottom
    */
    type bottom = string;
    /**
    * @description  <br><br>
    * The left CSS property participates in specifying the horizontal position of a positioned element. It has no effect on non-positioned elements.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/left|left(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } left
    */
    type left = string;
    /**
    * @description  <br><br>
    * The right CSS property participates in specifying the horizontal position of a positioned element. It has no effect on non-positioned elements.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/right|right(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } right
    */
    type right = string;
    /**
    * @description  <br><br>
    * The background shorthand CSS property sets all background style properties at once, such as color, image, origin and size, or repeat method.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background|background(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } background
    */
    type background = string;
    /**
    * @description  <br><br>
    * The border shorthand CSS property sets an element's border. It sets the values of border-width, border-style, and border-color.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border|border(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } border
    */
    type border = string;
    /**
    * @description  <br><br>
    * The border-width shorthand CSS property sets the width of an element's border.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width|borderWidth(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } borderWidth
    */
    type borderWidth = string;
    /**
    * @description  <br><br>
    * The border-radius CSS property rounds the corners of an element's outer border edge.<br>
    * You can set a single radius to make circular corners, or two radii to make elliptical corners.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius|borderRadius(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } borderRadius
    */
    type borderRadius = string;
    /**
    * @description  <br><br>
    * The border-style shorthand CSS property sets the line style for all four sides of an element's border..<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style|borderStyle(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } borderStyle
    */
    type borderStyle = string;
    /**
    * @description  <br><br>
    * The box-shadow CSS property adds shadow effects around an element's frame.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow|boxShadow(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } boxShadow
    */
    type boxShadow = string;
    /**
    * @description  <br><br>
    * The opacity CSS property sets the opacity of an element. <br>
    * Opacity is the degree to which content behind an element is hidden, and is the opposite of transparency.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/opacity|opacity(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } opacity
    */
    type opacity = string;
    /**
    * @description  <br><br>
    * The overflow CSS shorthand property sets the desired behavior for an element's overflow.<br>
    * @see  {@linkhttps://developer.mozilla.org/en-US/docs/Web/CSS/overflow|overflow(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } overflow
    */
    type overflow = string;
    /**
    * @description  <br><br>
    * The flex CSS shorthand property sets how a flex item will grow or shrink to fit the space available in its flex container.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex|flex(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } flex
    */
    type flex = string;
    /**
    * @description  <br><br>
    * The flex-shrink CSS property sets the flex shrink factor of a flex item.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-shrink|flexShrink(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } flexShrink
    */
    type flexShrink = string;
    /**
    * @description  <br><br>
    * The flex-grow CSS property sets the flex grow factor of a flex item's main size.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-grow|flexGrow(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } flexGrow
    */
    type flexGrow = string;
    /**
    * @description  <br><br>
    * The flex-basis CSS property sets the initial main size of a flex item.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis|flexBasis(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } flexBasis
    */
    type flexBasis = string;
    /**
    * @description  <br><br>
    * The text-align CSS property sets the horizontal alignment of the content inside a block element or table-cell box.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-align|textAlign(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textAlign
    */
    type textAlign = string;
    /**
    * @description  <br><br>
    * The text-overflow CSS property sets how hidden overflow content is signaled to users.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-overflow|textOverflow(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textOverflow
    */
    type textOverflow = string;
    /**
    * @description  <br><br>
    * The word-break CSS property sets whether line breaks appear wherever the text would otherwise overflow its content box.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/word-break|wordBreak(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } wordBreak
    */
    type wordBreak = string;
    /**
    * @description  <br><br>
    * he white-space CSS property sets how white space inside an element is handled.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/white-space|whiteSpace(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } whiteSpace
    */
    type whiteSpace = string;
    /**
    * @description  <br><br>
    * The disableBackgroundColor CSS property sets the background-color of a disabled element.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-color|background-color(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } disableBackgroundColor
    */
    type disableBackgroundColor = string;
    /**
    * @description  <br><br>
    * The disableForegroundColor CSS property sets the foreground color value of a disabled element's text.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color|color(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } disableForegroundColor
    */
    type disableForegroundColor = string;
    /**
    * @description  <br><br>
    * The disableBorderColor CSS property sets the border-color of a disabled element's border.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color|border-color(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } disableBorderColor
    */
    type disableBorderColor = string;
    /**
    * @description  <br><br>
    * It sets the CSS class hover when the control has focus.
    * The :hover CSS pseudo-class matches when the user interacts with an element with a pointing device, but does not necessarily activate it.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/:hover|hover(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } hover
    */
    type hover = string;
    /**
    * @description  <br><br>
    * It sets the CSS class 'focused' when the control has focus.
    * The :focus CSS pseudo-class represents an element (such as a form input) that has received focus.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/:focus|focus(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } focus
    */
    type focus = string;
    /**
    * @description  <br><br>
    * It sets the CSS class 'disabled' when the control is disabled.
    * The :disabled CSS pseudo-class represents any disabled element.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/:disabled|disabled(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } disabled
    */
    type disabled = string;
    /**
    * @description  <br><br>
    * The scale CSS property allows you to specify scale transforms individually and independently of the transform property.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/scale|scale(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } scale
    */
    type scale = string;
    /**
    * @description  <br><br>
    * The CSS align-items property sets the align-self value on all direct children as a group<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-items|alignItems(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } alignItems
    */
    type alignItems = string;
    /**
    * @description  <br><br>
    * The visibility CSS property shows or hides an element without changing the layout of a document.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility|visibility(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } visibility
    */
    type visibility = string;
    /**
    * @description  <br><br>
    * TThe CSS justify-content property defines how the browser distributes space between content items.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content|justifyContent(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } justifyContent
    */
    type justifyContent = string;
}
declare namespace VisiWin.UI.CSSTypes {
    /**
    * The color CSS data type represents a color.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value|color(MDN)}.
    **/
    type color = string;
    /**
    * The transparent keyword represents a fully transparent color.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#transparent_keyword|transparent(MDN}.
    **/
    type transparent = string;
    /**
    * The inherit CSS keyword causes the element for which it is specified to take the computed value of the property from its parent element.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/inherit|inherit(MDN)}
    **/
    type inherit = string;
    /**
    * The inherit CSS keyword causes the element for which it is specified to take the computed value of the property from its parent element.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/initial|initial(MDN)}
    **/
    type initial = string;
}
declare namespace VisiWin.UI.JSObjects {
    /**
    * JavaScript Date objects represent a single moment in time in a platform-independent format.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date|Date(MDN)}.
    **/
    type Date = any;
    /**
    * The JavaScript Array class is a global object that is used in the construction of arrays; which are high-level, list-like objects.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array|Array(MDN)}.
    **/
    type Array = any;
    /**
    * The Intl object is the namespace for the ECMAScript Internationalization API,
    * which provides language sensitive string comparison, number formatting, and date and time formatting. .
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl|Intl(MDN)}.
    **/
    type Intl = any;
}
declare namespace VisiWin.UI.JSPrimitives {
    /**
    * The String object is used to represent and manipulate a sequence of characters.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#string_type|String(MDN)}.
    **/
    type String = string;
    /**
    * Boolean represents a logical entity and can have two values: true and false.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#boolean_type|Boolean(MDN)}.
    **/
    type Boolean = boolean;
    /**
    * The Number type is the reference type for numeric values.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#number_type|Number(MDN)}.
    **/
    type Number = number;
    /**
    * The Null type has exactly one value: null.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#null_type|Null(MDN)}.
    **/
    type Null = null;
    /**
    * A variable that has not been assigned a value has the value undefined.
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#undefined_type|Undefined(MDN)}.
    **/
    type Undefined = undefined;
}
declare namespace VisiWin.UI.ElementProperties {
    /**
    * @description  <br><br>
    * The className property of the Element interface gets and sets the value of the class attribute of the specified element.<br>
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/className|className(MDN)} <br>
    * @member { {@link VisiWin.UI.JSPrimitives.String|string} } className
    */
    type className = string;
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Subset of the css align-items property.
    * @enum AlignItems
    * @see {@link VisiWin.UI.CSSProperties.alignItems|alignItems(Enum)} <br>
    */
    enum AlignItems {
        /**
         *  The cross-start margin edges of the flex items are flushed with the cross-start edge of the line.
         */
        "FlexStart" = "flex-start",
        /**
         *  The cross-end margin edges of the flex items are flushed with the cross-end edge of the line.
         */
        "FlexEnd" = "flex-end",
        /**
         *  The flex items' margin boxes are centered within the line on the cross-axis.
         */
        "Center" = "center",
        /**
         *  All flex items are aligned such that their flex container baselines align.
         */
        "Baseline" = "baseline",
        /**
         *  Flex items are stretched such that the cross-size of the item's margin box is the same as the line while respecting width and height constraints.
         */
        "Stretch" = "stretch"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Subset of the css justify-content property.
    * @enum JustifyContent
    * @see {@link VisiWin.UI.CSSProperties.justifyContent|justifyContent(Enum)} <br>
    */
    enum JustifyContent {
        /**
         *  The items are packed flush to each other toward the edge of the alignment container depending on the flex container's main-start side.
         */
        "FlexStart" = "flex-start",
        /**
         *  The items are packed flush to each other toward the edge of the alignment container depending on the flex container's main-end side.
         */
        "FlexEnd" = "flex-end",
        /**
         *  The items are packed flush to each other toward the center of the alignment container along the main axis.
         */
        "Center" = "center",
        /**
         *  The items are evenly distributed within the alignment container along the main axis
         */
        "SpaceBetween" = "space-between",
        /**
         * The items are evenly distributed within the alignment container along the main axis.
         */
        "SpaceAround" = "space-around",
        /**
         *  The items are evenly distributed within the alignment container along the main axis.
         */
        "SpaceEvenly" = "space-evenly"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Describes the element behavior depending on authorization.
    * @enum AuthorizationMode
    */
    enum AuthorizationMode {
        /**
         * The element box is visible.
         * @see  {@link ttps://developer.mozilla.org/en-US/docs/Web/CSS/visibility|visible(MDN)} <br>
         * style.visibility = "visible"
         */
        "Visible" = "Visible",
        /**
         * If an element is disabled it can't be activated (selected, clicked on, typed into, etc.) or accept focus.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled|disabled(MDN)} <br>
         */
        "Disabled" = "Disabled",
        /**
         * The element box is invisible (not drawn), but still affects layout as normal.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility|hidden(MDN)} <br>
         * style.visibility = "hidden"
         */
        "Hidden" = "Hidden",
        /**
         * Turns off the display of an element so that it has no effect on layout (the document is rendered as though the element did not exist).
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display|none(MDN)} <br>
         * style.display = "none"
         */
        "Collapse" = "Collapse"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Subset of the css visibility property.
    * @see {@link VisiWin.UI.CSSProperties.visibility|visibility(Enum)} <br>
    * @enum Visibility {
    */
    enum Visibility {
        /**
         * The element box is visible.
         */
        "Visible" = "visible",
        "visible" = "visible",
        /**
         * The element box is invisible (not drawn), but still affects layout as normal.
         */
        "Hidden" = "hidden",
        "hidden" = "hidden",
        /**
         * collapse is set to style.display = "none"
         */
        "Collapse" = "collapse",
        "collapse" = "collapse"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Subset of the css border-style property.
    * @enum BorderStyle
    * @see {@link VisiWin.UI.CSSProperties.borderStyle|borderStyle(Enum)} <br>
    */
    enum BorderStyle {
        /**
        * Like the hidden keyword, displays no border.
        */
        "None" = "none",
        /**
        * Displays a series of rounded dots.
        */
        "Dotted" = "dotted",
        /**
        * Displays a series of short square-ended dashes or line segments.
        */
        "Dashed" = "dashed",
        /**
        * Displays a single, straight, solid line.
        */
        "Solid" = "solid",
        /**
        * Displays two straight lines that add up to the pixel size defined by border-width.
        */
        "Double" = "double",
        /**
        * Displays a border with a carved appearance. It is the opposite of ridge.
        */
        "Groove" = "groove",
        /**
        * Displays a border with an extruded appearance. It is the opposite of groove.
        */
        "Ridge" = "ridge",
        /**
        * Displays a border that makes the element appear embedded.
        */
        "Inset" = "inset",
        /**
        * Displays a border that makes the element appear embossed.
        */
        "Outset" = "outset"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Subset of the css flex-direction property.
    * @enum Orientation
    * @see {@link VisiWin.UI.Enums.Orientation|orientation(Enum)} <br>
    */
    enum Orientation {
        /**
         *
         */
        "Horizontal" = "Horizontal",
        /**
         *
         */
        "Vertical" = "Vertical"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
     * @description Subset of the wpf viewbox stretch property.
     * @enum StretchDirection
     */
    enum StretchDirection {
        /**
         *
         */
        "Both" = "Both",
        /**
         *
         */
        "DownOnly" = "DownOnly",
        /**
         *
         */
        "UpOnly" = "UpOnly"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Subset of the wpf viewbox stretch property.
    * @enum StretchMode
    */
    enum StretchMode {
        /**
         *
         */
        "None" = "None",
        /**
         *
         */
        "Uniform" = "Uniform",
        /**
         *
         */
        "UniformToFill" = "UniformToFill",
        /**
         *
         */
        "Fill" = "Fill"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Listing of the various control types
    * @enum DesignerType
    */
    const DesignerType: {
        /**
         *
         */
        Child: string;
        TemplateChild: string;
        RegionControl: string;
        Control: string;
        CustomControl: string;
        UserControl: string;
        ContentControl: string;
        DesignerContainer: string;
        Collection: string;
        DisabledControl: string;
        TemplateContainer: string;
        UserControlChild: string;
        child: string;
    };
}
declare namespace VisiWin.UI {
    /**
    * @description  List of Condition Opperators,
    *               use in Action Conditions and
    *               stateCollecios
    */
    const Conditions: {
        /**
          * no Operator.
          */
        readonly OPERATOR_NONE: 0;
        /**
         * Operator greater.
         */
        readonly OPERATOR_GREATER: 1;
        /**
         * Operator grater.
        */
        readonly OPERATOR_GRATEREQUAL: 2;
        /**
         * Operator grater.
        */
        readonly OPERATOR_LESS: 3;
        /**
         * Operator grater.
        */
        readonly OPERATOR_LESSEQUAL: 4;
        /**
        * Operator grater.
        */
        readonly OPERATOR_EQUAL: 5;
        /**
            * Operator grater.
        */
        readonly OPERATOR_UNEQUAL: 6;
        /**
            * Operator grater.
        */
        readonly OPERATOR_INRANGE: 7;
        /**
            * Operator grater.
        */
        readonly OPERATOR_OUTRANGE: 8;
        /**
            * Operator grater.
        */
        readonly OPERATOR_NUMERATION: 9;
    };
}
declare namespace VisiWin.UI {
    /**
    * @description  VW Parser States.
    * @enum PropertyParserStates PPS
    */
    const PropertyParserState: {
        /**
         * Start condition, read constant string
         */
        readonly PPS_CONST: 0;
        /**
         * Read first @ Sign
         */
        readonly PPS_AT: 1;
        /**
         * Read "(" Sign
         */
        readonly PPS_PARA: 2;
        /**
          * Read ")" Sign
          */
        readonly PPS_END: 3;
    };
    /**
     * @description  Operatoren for action conditin and featureString.
     * @enum ConditionOperators
     */
    const ConditionOperators: {
        /**
          * OPERATOR_GRATER
          */
        readonly OPERATOR_GRATER: ">";
        /**
         * OPERATOR_GRATEREQUAL
         */
        readonly OPERATOR_GRATEREQUAL: ">=";
        /**
         * OPERATOR_LESS
         */
        readonly OPERATOR_LESS: "<";
        /**
         * OPERATOR_LESSEQUAL
         */
        readonly OPERATOR_LESSEQUAL: "<=";
        /**
         * OPERATOR_EQUAL
         */
        readonly OPERATOR_EQUAL: "==";
        /**
         *OPERATOR_UNEQUAL
         */
        readonly OPERATOR_UNEQUAL: "!=";
        /**
         * OPERATOR_INRANGE
         */
        readonly OPERATOR_INRANGE: "<>";
        /**
         * OPERATOR_OUTRANGE
         */
        readonly OPERATOR_OUTRANGE: "!<>";
        /**
         * OPERATOR_NUMERATION
         */
        readonly OPERATOR_NUMERATION: ",";
    };
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Enum to define the layout type of the TouchKeyboard
    * @enum TouchKeyboardType
    * @see {@link VisiWin.UI.Enums.TouchKeyboardType|TouchKeyboardType(Enum)} <br>
    */
    enum TouchKeyboardType {
        /**
         *
         */
        "Numeric" = "Numeric",
        /**
         *
         */
        "Alphanumeric" = "Alphanumeric"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Describes the element behavior depending on SelectionMode.
    * @enum SelectionMode
    */
    enum SelectionMode {
        /**
         *
         */
        "None" = "None",
        /**
         *
         */
        "Single" = "Single"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description Describes the element behavior depending on RenderMode.
    * @enum RenderMode
    */
    enum RenderMode {
        /**
         *
         */
        "Synchronous" = "Synchronous",
        /**
         *
         */
        "Asynchronous" = "Asynchronous"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description  The sortType property indicates the sort mode for the VisiWin.UI.TableControl
    * @enum SortType
    */
    enum SortType {
        "Auto" = "Auto",
        "Alphabetical" = "Alphabetical",
        "Numeric" = "Numeric",
        "Date" = "Date",
        "Boolean" = "Boolean"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description  The SortMode property sets the sort mode for the VisiWin.UI.TableControl, which indicates, if the table itself handles the sorting or a event is dispatched
    * @enum SortMode
    */
    enum SortMode {
        "Internal" = "Internal",
        "External" = "External"
    }
}
declare namespace VisiWin.UI.Enums {
    /**
    * @description  The SortDirection property indicates the sort direction for the VisiWin.UI.TableControl
    * @enum SortDirection
    */
    enum SortDirection {
        "None" = "None",
        "Ascending" = "Ascending",
        "Descending" = "Descending"
    }
}
declare namespace VisiWin.UI {
    /**
    * @description  The pointerType read-only property of the PointerEvent interface indicates the device type (mouse, pen, or touch) that caused a given pointer event.
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType|pointerType(MDN)} <br>
    * @enum PointerType
    */
    enum PointerType {
        /**
         * The event was generated by a mouse device.
         */
        "mouse" = "mouse",
        /**
         * The event was generated by a pen or stylus device.
         */
        "pen" = "pen",
        /**
         * The event was generated by a touch, such as a finger.
         */
        "touch" = "touch"
    }
}
declare namespace VisiWin.UI {
    /**
    * @description  Control events used from VisiWin.Triggers.ControlEventTrigger.
    */
    const ControlEvent: {
        /**
         * An element receives a click event when a pointing device button (such as a mouse's primary mouse button) is both pressed and released while the pointer is located inside the element.
         *
         * Combination of pointerup and pointerdown event
         * @see {@link VisiWin.UI.PointerEventType.pointerdown|pointerdown} <br>
         * @see {@link VisiWin.UI.PointerEventType.pointerup|pointerup} <br>
         */
        readonly onClick: "click";
        /**
         * The pointerdown event is fired when a pointer becomes active.
         *
         * @see {@link VisiWin.UI.PointerEventType.pointerdown|pointerdown} <br>
         */
        readonly onDown: "down";
        /**
         * The pointerup event is fired when a pointer is no longer active.
         *
         * @see {@link VisiWin.UI.PointerEventType.pointerup|pointerup} <br>
         */
        readonly onUp: "up";
        /**
         * The pointerdown event is fired when a pointer becomes active.
         *
         * @see {@link VisiWin.UI.PointerEventType.pointerdown|pointerdown} <br>
         */
        readonly onButtonDown: "buttondown";
        /**
         * The pointerup event is fired when a pointer is no longer active.
         *
         * @see {@link VisiWin.UI.PointerEventType.pointerup|pointerup} <br>
         */
        readonly onButtonUp: "buttonup";
        /**
         * An element receives a click event when a pointing device button (such as a mouse's primary mouse button) is both pressed and released while the pointer is located inside the element.
         *
         * Combination of pointerup and pointerdown event
         * @see {@link VisiWin.UI.PointerEventType.pointerdown|pointerdown} <br>
         * @see {@link VisiWin.UI.PointerEventType.pointerup|pointerup} <br>
         */
        readonly onButtonClick: "buttonclick";
        /**
         * An element receives a click event when a pointing device button (such as a mouse's primary mouse button) is both pressed and released while the pointer is located inside the element.
         *
         * The element checked property is true.
         *
         * Combination of pointerup and pointerdown event
         * @see {@link VisiWin.UI.PointerEventType.pointerdown|pointerdown} <br>
         * @see {@link VisiWin.UI.PointerEventType.pointerup|pointerup} <br>
         */
        readonly onButtonClickTrue: "buttonclicktrue";
        /**
         * An element receives a click event when a pointing device button (such as a mouse's primary mouse button) is both pressed and released while the pointer is located inside the element.
         *
         * The element checked property is false
         *
         * Combination of pointerup and pointerdown event
         * @see {@link VisiWin.UI.PointerEventType.pointerdown|pointerdown} <br>
         * @see {@link VisiWin.UI.PointerEventType.pointerup|pointerup} <br>
         */
        readonly onButtonClickFalse: "buttonclickfalse";
    };
    /**
    * @description  The PointerEvent interface represents the state of a DOM event produced by a pointer.
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent#pointer_event_types|pointer_event_types(MDN)} <br>
    * @enum PointerEventType
    */
    const PointerEventType: {
        /**
         * The pointerdown event is fired when a pointer becomes active.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/pointerdown_event|pointerdown_event(MDN)} <br>
         */
        readonly pointerdown: "pointerdown";
        /**
         * The pointermove event is fired when a pointer changes coordinates.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/pointermove_event|pointermove_event(MDN)} <br>
         */
        readonly pointermove: "pointermove";
        /**
         * The pointerup event is fired when a pointer is no longer active.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/pointerup_event|pointerup_event(MDN)} <br>
         */
        readonly pointerup: "pointerup";
        /**
         * The pointercancel event is fired when the browser determines that there are unlikely to be any more pointer events.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/pointercancel_event|pointercancel_event(MDN)} <br>
         */
        readonly pointercancel: "pointercancel";
        /**
         * The pointerenter event fires when a pointing device is moved into the hit test boundaries of an element
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/pointerenter_event|pointerenter_event(MDN)} <br>
         */
        readonly pointerenter: "pointerenter";
        /**
         * The pointerleave event is fired when a pointing device is moved out of the hit test boundaries of an element.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/pointerleave_event|pointerleave_event(MDN)} <br>
         */
        readonly pointerleave: "pointerleave";
    };
}
declare namespace VisiWin.UI {
    /**
    * @description  The FocusEvent interface represents focus-related events, including focus, blur, focusin, and focusout.
    * @see  { @link https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent|FocusEvent(MDN)} <br>
    * @enum FocusEventType
    */
    const FocusEventType: {
        /**
         * The focus event fires when an element has received focus.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/focus_event|focus_event(MDN)} <br>
         */
        readonly focus: "focus";
        /**
         * The focusin event fires when an element is about to receive focus.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/focusin_event|focusin_event(MDN)} <br>
         */
        readonly focusin: "focusin";
        /**
         * The focusout event fires when an element is about to lose focus.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/focusout_event|focusout_event(MDN)} <br>
         */
        readonly focusout: "focusout";
        /**
         * The blur event fires when an element has lost focus.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event|blur_event(MDN)} <br>
         */
        readonly blur: "blur";
    };
}
declare namespace VisiWin.UI {
    /**
    * @description  KeyboardEvent objects describe a user interaction with the keyboard.
    * @see  { @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent|KeyboardEvent(MDN)} <br>
    * @enum KeyboardEventType
    */
    const KeyboardEventType: {
        /**
         * The keyup event is fired when a key is released.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/keyup_event|keyup_event(MDN)} <br>
         */
        readonly keyup: "keyup";
        /**
         * The keydown event is fired when a key is pressed.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event|keydown_event(MDN)} <br>
         */
        readonly keydown: "keydown";
        /**
         * The keypress event is fired when a key that produces a character value is pressed down.
         * @see  {@linkhttps://developer.mozilla.org/en-US/docs/Web/API/Document/keypress_event|keypress_event(MDN)} <br>
         */
        readonly keypress: "keypress";
    };
}
declare namespace VisiWin.UI {
    /**
    * @description  The MouseEvent interface represents events that occur due to the user interacting with a pointing device (such as a mouse).
    * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent|MouseEvent(MDN)} <br>
    * @enum MouseEventType
    */
    const MouseEventType: {
        /**
         * An element receives a click event when a pointing device button (such as a mouse's primary mouse button)
         * is both pressed and released while the pointer is located inside the element.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event|click_event(MDN)} <br>
         */
        readonly click: "click";
        /**
         * The dblclick event fires when a pointing device button (such as a mouse's primary button) is double-clicked.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/dblclick_event|dblclick_event(MDN)} <br>
         */
        readonly dblclick: "dblclick";
        /**
         * The mouseup event is fired at an Element when a button on a pointing device (such as a mouse or trackpad) is released while the pointer is located inside it.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseup_event|mouseup_event(MDN)} <br>
         */
        readonly mouseup: "mouseup";
        /**
         * The mousedown event is fired at an Element when a pointing device button is pressed while the pointer is inside the element.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousedown_event|mousedown_event(MDN)} <br>
         */
        readonly mousedown: "mousedown";
        /**
         * The mouseover event is fired at an Element when a pointing device (such as a mouse or trackpad) is used to move the cursor onto the element or one of its child elements.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseover_event|mouseover_event(MDN)} <br>
         */
        readonly mouseover: "mouseover";
        /**
         * The mouseenter event is fired at an Element when a pointing device (usually a mouse) is initially moved so that its hotspot is within the element at which the event was fired.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event|mouseenter_event(MDN)} <br>
         */
        readonly mouseenter: "mouseenter";
        /**
         * The mouseout event is fired at an Element when a pointing device (usually a mouse) is used to move the cursor so that it is no longer contained within the element or one of its children.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseout_event|mouseout_event(MDN)} <br>
         */
        readonly mouseout: "mouseout";
        /**
         * The mouseleave event is fired at an Element when the cursor of a pointing device (usually a mouse) is moved out of it.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event|mouseleave_event(MDN)} <br>
         */
        readonly mouseleave: "mouseleave";
        /**
         * The mousemove event is fired at an element when a pointing device (usually a mouse) is moved while the cursor's hotspot is inside it.
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event|mousemove_event(MDN)} <br>
         */
        readonly mousemove: "mousemove";
        /**
         * The contextmenu event fires when the user attempts to open a context menu. This event is typically triggered by clicking the right mouse button, or by pressing the context menu ke
         * @see  {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/contextmenu_event|contextmenu_event(MDN)} <br>
         */
        readonly contextmenu: "contextmenu";
    };
}
declare module VisiWin.UI {
    let eventHandler: typeof WinJS.UI.eventHandler;
    let process: typeof WinJS.UI.process;
    let processAll: typeof WinJS.UI.processAll;
    let setControl: typeof WinJS.UI.setControl;
    let setOptions: typeof WinJS.UI.setOptions;
}
declare module VisiWin.Utilities {
    let setInnerHTML: typeof WinJS.Utilities.setInnerHTML;
    let setInnerHTMLUnsafe: typeof WinJS.Utilities.setInnerHTMLUnsafe;
    let setOuterHTML: typeof WinJS.Utilities.setOuterHTML;
    let setOuterHTMLUnsafe: typeof WinJS.Utilities.setOuterHTMLUnsafe;
    let insertAdjacentHTML: typeof WinJS.Utilities.insertAdjacentHTML;
    let insertAdjacentHTMLUnsafe: typeof WinJS.Utilities.insertAdjacentHTMLUnsafe;
    let query: typeof WinJS.Utilities.query;
    let getMember: typeof WinJS.Utilities.getMember;
    let Scheduler: typeof WinJS.Utilities.Scheduler;
    let markSupportedForProcessing: typeof WinJS.Utilities.markSupportedForProcessing;
    let Key: typeof WinJS.Utilities.Key;
    const addEventListener: (element: VWElement, name: string, handler: any, capture?: boolean) => void;
    const addGlobalEventListener: (name: string, handler: any, capture?: boolean) => void;
    const removeEventListener: (element: VWElement, name: string, handler: any, capture?: boolean) => void;
    const removeGlobalEventListener: (name: string, handler: any, capture?: boolean) => void;
    function schedule(f: any, arg: any, priority: any): void;
}
declare module VisiWin.Utilities {
    type extendedPointerArgs = {
        sender: any;
        tag: any;
        detail: PointerEvent;
    };
    function extendPointerEventArgs(element: any, originalArgs: PointerEvent): extendedPointerArgs;
    function isDomEvents(eventName: string): boolean;
    /**
     *  mix AppSettings (project settings in default settings)
     *   Parameter:
     *      defaultObj: any     default settings data from ApplicationBase
     *      newObj: any         insert new object data in default data
     *   Return:
     *       mix Object         return mix data
    */
    function mixAppSettings(defaultObj: any, newObj: any): any;
    function getObjectFromName(name: string, base?: any): any;
    function getAppSettings(key: string): any;
    function getPathString(key: string): any;
    function getPathSetting(key: string): string;
    function checkNumberInString(str: string): boolean;
    /**
    *  Convert comma seperated list to array
    *   Parameter:
    *       value: any
    *   Return:
    *       if value a string, with comma seperated list, it will be convert into a array
    *       if value a array it will return the array
    *       if value null, or undefined or "" or [] or {} it will return a empty array
    *       if value a other type, it will be return a array with one element of value
    */
    function csvToArray(value: any): string[];
    function markControlStart(): any;
    function markControlEnd(start: any, name: string): any;
    function isChrome(): boolean;
    function isExplorer(): boolean;
    function isFirefox(): boolean;
    function isCamino(): boolean;
    function isSafari(): boolean;
    function isOpera(): boolean;
    function isAndroidOS(): boolean;
    function isWindowsOS(): boolean;
    function isMacOS(): boolean;
    function isLinuxOS(): boolean;
    function isX11OS(): boolean;
    function isMobile(): boolean;
    function isTouchDisplay(): boolean;
    function hasWhiteSpace(s: string): boolean;
    function getFirstStackEntry(stack: string): string;
    function getLocPointServer(): string;
    function getLocPointUser(): string;
    function locLanguage(): string;
    function getBrowserLoc(): void;
    function valueToJS(val: any): string;
    function valueToServer(val: any): string;
    function valueToUser(val: any): string;
    function addClass(element: any, className: string): void;
    function removeClass(element: any, className: string): void;
    function hasClass(element: any, className: string): any;
    function reparentChildren(originalParent: any, destinationParent: any): void;
    function isInDesignMode(): boolean;
    function isInInteractiveRunMode(): boolean;
    function isInDefaultPage(): boolean;
    function getUniqId(prefix?: string): string;
    /**
     * createObjectFromName
     *      create a hirachical Object at global space or instance space
     *
     * @param name {sting} Object path name with dots as separator
     *                     if nameSting begin with "this." it will be a instance member
     *                     else it is a global oject
     * @return             return create object
     */
    function createObjectFromName(name: string, prop: string): any;
    function elementShow(element: HTMLElement, val: any): void;
    function frmString(format: string, pnum: any): any;
    const detachSubTree: (element: any, rootElementFlag?: boolean) => void;
    const attachSubTree: (element: any, rootElementFlag?: boolean) => void;
    const initializeSubTree: (element: VWElement, rootElementFlag?: boolean) => void;
    const readySubTree: (element: VWElement, rootElementFlag?: boolean) => void;
    const disposeSubTree: (element: VWElement, rootElementFlag?: boolean) => void;
    /**
        * Class for dimension change detection.
        *
        * @param {Element|Element[]|Elements|jQuery} element
        * @param {Function} callback
        *
        * @constructor
        */
    const resizeNotifier: (element: HTMLElement, callback: any) => void;
    function xhr(options: any): any;
    function loadScript(scriptname: any): Promise<unknown>;
    function checkHtmlProperty1Q(p: any): any;
    function checkHtmlProperty2Q(p: any): any;
    function checkHtmlProperty4Q(p: any): any;
    function clamp(element: HTMLElement, options: any): any;
    function processElements(elements: VWElement[]): any;
    function lang2lcid(lang: string): any;
    function lcid2locale(lcid: number): string;
    function setRenderedFontClass(): void;
    /**
    * @ignore
    * @description Deprecated do not use this!
    */
    function shortId(): VisiWin.IGuid;
    function passAuthorizationToChilds(contentElement: any, authorizationRight: string, authorizationMode: VisiWin.UI.Enums.AuthorizationMode): void;
    function togglePointerEvents(contentElement: HTMLElement, disable: boolean): void;
    function removeHashFromId(id: string): string;
    /**
     * Finds the parent element of the given HTML element with the specified class name.
     *
     * @param element The HTML element whose parent is to be searched.
     * @param className The class name to look for in the parent elements.
     * @returns The first parent element with the specified class name, or null if not found.
     */
    function findParentElementByClassName(element: HTMLElement, className: string): HTMLElement | null;
    /**
     * Converts font weight values from CSS shorthand notation to numerical values or keywords.
     *
     * @param value The font weight value to convert.
     * @returns The corresponding CSS font weight value as a string.
     */
    function getFontWeight(value: any): string;
}
/** @ignore */
interface String {
    format(args: string): string;
}
declare namespace VisiWin.UI {
    enum DateTimeFormatNames {
        LongDate = "LongDate",
        ShortDate = "ShortDate",
        NamedLongDate = "NamedLongDate",
        NamedShortDate = "NamedShortDate",
        LongTime = "LongTime",
        ShortTime = "ShortTime",
        UserDefinedDate = "UserDefinedDate",
        UserDefinedTime = "UserDefinedTime",
        ISO = "ISO"
    }
    enum DateTimeModeNames {
        /**
        * Only the time is indicated.
        */
        TimeOnly = "TimeOnly",
        /**
        * Only the date is indicated.
        */
        DateOnly = "DateOnly",
        /**
        * The time is indicated followed by the date.
        */
        TimeDate = "TimeDate",
        /**
        * The date is indicated followed by the time.
        */
        DateTime = "DateTime",
        /**
        * The time is indicated followed by the date. Time and date are displayed separated by a word wrap.
        */
        TimeCRDate = "TimeCRDate",
        /**
        * The date is indicated followed by the time. Date and time are displayed separated by a word wrap.
        */
        DateCRTime = "DateCRTime"
    }
    function formatDate(locale: string, formatType: string, date: Date | number): string;
}
declare module VisiWin.Namespace {
    const define: typeof WinJS.Namespace.define;
}
declare module VisiWin.UI.Pages {
    let define: (uri: string, member: any) => void;
    const readySubTree: (element: any) => void;
}
declare module VisiWin.Class {
    function initializeProperties(target: any, members: any, prefix?: string): void;
    function classMix(base: any, mixinArr: any[], overwrite?: boolean): any;
    function mix(constr: Function, mixins: any): any;
    function define(constr: Function, instanceMember: any, staticMember: any): any;
    function derive(baseClass: any, constr: Function, instanceMembers: any, staticMembers: any): any;
    function watch(context: any, target: any, pathProp: string, handler: any): any;
    function initObserve(context: any, target: any, observeList: any): void;
    function initNotityPropertyChangeHandler(context: any, target: any, observeList: any): void;
    function removeObserve(context: any, target: any): void;
    function createEventProperty(name: any): {
        get: () => any;
        set: (handler: any) => void;
        enumerable: boolean;
    };
    function _createProperty(list: any, defClass: any, name: string, propertyType: string, access: string, resourceValue: string[], para: string, element: string, event: string, type: string, overwrite: boolean, triggerName: string, actionName: string): boolean;
    function createProperties(control: any, list: any): void;
    function createStyles(control: any, styleString: any): boolean;
}
/** @ignore */
declare module VisiWin.SvgUtilities {
    /** @ignore */
    function drawPath(centerX: number, centerY: number, startAngle: number, endAngle: number, degreesSegment: number, innerRadius: number, outerRadius: number, color: string): any;
    /** @ignore */
    function drawLine(x1: any, y1: any, x2: any, y2: any, width: any, color: string, cssClass: string): SVGLineElement;
    /** @ignore */
    function drawTetragon(width: number, height: number, startWidth: number, endWidth: number, min: number, max: number, position: string, placement: string, reverse: boolean, offset: number, color: string): any;
    /** @ignore */
    function getDegreesSegment(startAngle: number, endAngle: number): number;
    /** @ignore */
    function getPixelValue(requiredValue: any, totalValue: any, totalWidth?: any): number;
    /** @ignore */
    function correctAngle(angle: number): number;
}
declare module VisiWin.Utilities {
    type ExecuteValue = string | boolean | number | any;
    type ConvertedVariableType = string | number | boolean | any;
    /**
     * convertToType
     * @description Converts a value by the given type.
     * @param {VisiWin.Actions.ExecuteValue} value value to be converted
     * @param {string} targetType Type to which the value is converted: number, string, boolean
     */
    function convertToType(value: ExecuteValue, targetType: string): ConvertedVariableType;
    /**
     * parseCommand
     * @description check Command in special String
     * @param {VisiWin.Actions.ExecuteValue} value value to be converted
     * @param {string} targetType Type to which the value is converted: number, string, boolean
     */
    function parseCommand(command: string, parameter: string, triggerDataPrefixName?: string): Promise<string>;
    /**
     * parseParameter
     * @description scan parameter from featrure String and replace special entrys.
     * @param {string} parameter value to be parse
     * @return {string} targetType Type to which the value is converted: number, string, boolean
     */
    function parseParameter(parameter: string, triggerDataPrefixName?: string): Promise<string>;
    function parseProperty(value: any, triggerDataPrefixName?: string): Promise<string>;
    /**
     * stateCollectionValue    method
     * over a extern JSON Datastructur will be convert a value
     * in a universal type dataset.
     * @param stateCollectionName name of the translate table.
     * @param value this value will be convert
     * @return the new value
    **/
    function stateCollectionValue(stateCollectionName: string, value: number): any;
}
declare namespace VisiWin.Internal.Application.Settings {
    let Splash: boolean;
    let DisableTouchRipple: boolean;
    let SplashDelay: number;
    interface IAnimation {
        EnterPage: string;
    }
    interface IDirectoryNames {
        LocResources: string;
        Resources: string;
        Themes: string;
        StateLists: string;
        StateCollections: string;
        TouchKeyboard: string;
        SVGBindingLists: string;
        SampleData: string;
        Actions: string;
        Controls: string;
        Provider: string;
        Classes: string;
        Services: string;
        Colors: string;
        Animations: string;
        Shadows: string;
    }
    interface IFileName {
        LocStrings: string;
        LocCultureInfo: string;
    }
    interface IImportFiles {
        type: string;
        path: string;
        require?: string[];
    }
    interface ImportListRunMode {
        polyJS: IImportFiles;
        depJS: IImportFiles;
        vwJS: IImportFiles;
        defaultJS: IImportFiles;
        mdiconCss: IImportFiles;
        wjiconCss: IImportFiles;
        vwuiCss: IImportFiles;
        stylesCss: IImportFiles;
        typoCss: IImportFiles;
    }
    interface ImportListDesignMode {
        vwDesignJS: IImportFiles;
        depJS: IImportFiles;
        polyJS: IImportFiles;
        vwJS: IImportFiles;
        defaultJS: IImportFiles;
        mdiconCss: IImportFiles;
        wjiconCss: IImportFiles;
        vwuiCss: IImportFiles;
        stylesCss: IImportFiles;
        typoCss: IImportFiles;
    }
    interface ImportListDebugMode {
        polyJS: IImportFiles;
        depJS: IImportFiles;
        winjsBase: IImportFiles;
        winjsUI: IImportFiles;
        simplekeyboard: IImportFiles;
        system: IImportFiles;
        core: IImportFiles;
        abJS: IImportFiles;
        asJS: IImportFiles;
        acJS: IImportFiles;
        apJS: IImportFiles;
        bcJS: IImportFiles;
        ccJS: IImportFiles;
        lcJS: IImportFiles;
        alJS: IImportFiles;
        mcJS: IImportFiles;
        ucJS: IImportFiles;
        defaultJS: IImportFiles;
        mdiconCss: IImportFiles;
        wjiconCss: IImportFiles;
        vwuiCss: IImportFiles;
        stylesCss: IImportFiles;
        typoCss: IImportFiles;
    }
}
declare namespace VisiWin.Internal.Application.Settings {
    /**
     * UI settings config
     */
    interface IUiSettings {
        ImportList_RunMode: VisiWin.Internal.Application.Settings.ImportListRunMode;
        AppServices_RunMode: any[] | null;
        AutoRestartOnError: boolean;
        AutoRestartDelay: number;
        ForceDesignMode: boolean;
        ForceDebugMode: boolean;
        PageMode: string;
        DisableClearHTML: boolean;
        DisableDesignModeCodeBehind: boolean;
        ImportList_DesignMode: VisiWin.Internal.Application.Settings.ImportListDesignMode;
        ImportList_DebugMode: VisiWin.Internal.Application.Settings.ImportListDebugMode;
        AppServices_DesignMode: any[];
        WebSocketDisable: boolean;
        LoginView: string;
        ErrorView: string;
        AppShell: string;
        EmptyPage: string;
        StyleColors: boolean;
        TimingLog: boolean;
        DevelopmentMode: boolean;
        InteractivRunMode: boolean;
        DisableTouchRipple?: boolean;
        SymbolPath: string;
        DefaultIconFont: string;
        StyleFamily: string;
        Device: any;
        Animation: VisiWin.Internal.Application.Settings.IAnimation;
        DirectoryNames: VisiWin.Internal.Application.Settings.IDirectoryNames;
        FileName: VisiWin.Internal.Application.Settings.IFileName;
        Styles: string[];
        StateLists: string[];
        TouchKeyboard: string[];
        StateInfos: string[];
        StateCollections: string[];
        Services: string[];
        Providers: string[];
        Controls: string[];
        Actions: string[];
        Classes: string[];
        Languages: string[];
        DesignTimeLanguage: string;
        RunTimeLanguage: string;
        Themes: string[];
        DesignTimeTheme: string;
        RunTimeTheme: string;
        AppServices: any;
        DateTimeFormats: any;
        PointerTypes: string[];
        Preloading: object[];
        LoadingPageName: string;
        LoadingViewName: string;
        ShowLoadingPageForUncachedPages: boolean;
        IncludePartiallyLoadedPages: boolean;
        AutomaticUpdateUserManagement: boolean;
    }
    class UiSettings implements VisiWin.Internal.Application.Settings.IUiSettings {
        ImportList_RunMode: any;
        AppServices_RunMode: any;
        AutoRestartOnError: any;
        AutoRestartDelay: any;
        SuspendCommunicationDelay: any;
        SuspendCommunicationEnabled: any;
        RestartAfterSuspension: any;
        ForceDesignMode: any;
        ForceDebugMode: any;
        StartDelay: any;
        DisableClearHTML: any;
        DisableDesignModeCodeBehind: any;
        PageMode: any;
        SymbolPath: any;
        ImportList_DesignMode: any;
        ImportList_DebugMode: any;
        AppServices_DesignMode: any[];
        WebSocketDisable: any;
        LoginView: any;
        ErrorView: any;
        AppShell: any;
        EmptyPage: any;
        StyleColors: any;
        TimingLog: any;
        DevelopmentMode: any;
        InteractivRunMode: any;
        PreloadImages: any;
        ImageList: any;
        DefaultIconFont: any;
        StyleFamily: any;
        Device: any;
        Animation: any;
        DirectoryNames: any;
        FileName: any;
        StateLists: any;
        TouchKeyboard: any;
        StateInfos: any;
        StateCollections: any;
        Colors: any;
        Animations: any;
        Shadows: any;
        ProjectStyles: any;
        Providers: any;
        PointerTypes: any;
        Controls: any;
        Services: any;
        Actions: any;
        Classes: any;
        Css: any;
        Js: any;
        UserControls: any;
        CustomControls: any;
        DataTemplates: any;
        PreloadDataTemplates: any;
        Converters: any;
        Styles: any;
        DefaultStyleFamily: any;
        DefaultDevice: any;
        Languages: any;
        DesignTimeLanguage: any;
        RunTimeLanguage: any;
        Themes: any;
        DesignTimeTheme: any;
        RunTimeTheme: any;
        DateTimeFormats: any;
        PageHistorySize: any;
        ViewHistorySize: any;
        LoadingPageName: any;
        LoadingViewName: any;
        Preloading: any;
        AutomaticUpdateUserManagement: any;
        ShowLoadingPageForUncachedPages: any;
        IncludePartiallyLoadedPages: any;
        AppServicesDefault: {
            VariableService: {};
            LanguageService: {};
            ThemeService: {};
            DataService: {
                MappedData: string[];
            };
            TouchKeyboard: {
                NumericTouchpadDialog: string;
                AlphanumericTouchpadDialog: string;
                ForceNumericTouchpadDialogOnMobileDevice: boolean;
                ForceAlphanumericTouchpadDialogOnMobileDevice: boolean;
            };
            UserManagementService: {
                TextKeys: {
                    DialogsUserManagementRemoveUserDeletePermitted: string[];
                    DialogsUserManagementRemoveUserMethodCallFailed: string[];
                    DialogsUserManagementRemoveUserUnableToSaveUser: string[];
                    DialogsUserManagementRemoveUserRemoveUserUnknownGroup: string[];
                    DialogsUserManagementRemoveUserUnknownUser: string[];
                    DialogsUserManagementRemoveUserMethodCallFaild: string[];
                    DialogsUserManagementAddUserSuccessUINoUser: string[];
                    DialogsUserManagementAddUserSuccessUINoRepeatPassword: string[];
                    DialogsUserManagementAddUserSuccessForbiddenPassword: string[];
                    DialogsUserManagementAddUserSuccessInvalidPassword: string[];
                    DialogsUserManagementAddUserSuccessInvalidPasswordLength: string[];
                    DialogsUserManagementAddUserSuccessMethodCallFailed: string[];
                    DialogsUserManagementAddUserSuccessNoCharactersInPassword: string[];
                    DialogsUserManagementAddUserSuccessNoNumbersInPassword: string[];
                    DialogsUserManagementAddUserSuccessPasswordMustContainSpecialCharacters: string[];
                    DialogsUserManagementAddUserSuccessUnableToSaveUser: string[];
                    DialogsUserManagementAddUserSuccessUserExists: string[];
                    DialogsUserManagementAddUserSuccessNoName: string[];
                    DialogsUserManagementAddUserSuccessNoUserGroup: string[];
                    DialogsUserManagementAddUserSuccessPasswordsNotEqual: string[];
                    DialogsUserManagementAddUserSuccessFullUserExists: string[];
                    DialogsUserManagementAddUserSuccessMachineCodeExists: string[];
                    DialogsUserManagementAddUserSuccessNoFullName: string[];
                    DialogsUserManagementAddUserSuccessLockedPassword: string[];
                    DialogsUserManagementAddUserSuccessUINoNewPassword: string[];
                    DialogsUserManagementAddUserSuccessNewPasswordsNotEqual: string[];
                    DialogsUserManagementAddUserSuccessMethodCallFaild: string[];
                    DialogsUserManagementAddUserChooseState: string[];
                    DialogsUserManagementChangePasswordSuccesUINoUser: string[];
                    DialogsUserManagementChangePasswordSuccessCantAccessDomainInfo: string[];
                    DialogsUserManagementChangePasswordSuccessForbiddenPassword: string[];
                    DialogsUserManagementChangePasswordSuccessMethodCallFailed: string[];
                    DialogsUserManagementChangePasswordSuccessNewPasswordInvalid: string[];
                    DialogsUserManagementChangePasswordSuccessNewPasswordInvalidLength: string[];
                    DialogsUserManagementChangePasswordSuccessNoCharactersInPassword: string[];
                    DialogsUserManagementChangePasswordSuccessNoNumbersInPassword: string[];
                    DialogsUserManagementChangePasswordSuccessOldPasswordInvalid: string[];
                    DialogsUserManagementChangePasswordSuccessMustContainSpecialCharacters: string[];
                    DialogsUserManagementChangePasswordSuccessUnableToSavePassword: string[];
                    DialogsUserManagementChangePasswordSuccessUnknownUser: string[];
                    DialogsUserManagementChangePasswordSuccessNewPasswordsNotEqual: string[];
                    DialogsUserManagementChangePasswordSuccessNoCurrentUser: string[];
                    DialogsUserManagementChangePasswordSuccessLockedPassword: string[];
                    DialogsUserManagementChangePasswordSuccessMethodCallFaild: string[];
                    DialogsUserManagementChangeUserSuccessUINoUserNoRepeatPassword: string[];
                    DialogsUserManagementChangeUserSuccessInvalidUserClass: string[];
                    DialogsUserManagementChangeUserSuccessUINoRepeatPassword: string[];
                    DialogsUserManagementChangeUserSuccessMethodCallFaild: string[];
                    DialogsUserManagementChangeUserSuccessNewPasswordsNotEqual: string[];
                    DialogsUserManagementChangeUserSuccessForbiddenPassword: string[];
                    DialogsUserManagementChangeUserSuccessFullUserExists: string[];
                    DialogsUserManagementChangeUserSuccessInvalidPassword: string[];
                    DialogsUserManagementChangeUserSuccessInvalidPasswordLength: string[];
                    DialogsUserManagementChangeUserSuccessLockedPassword: string[];
                    DialogsUserManagementChangeUserSuccessMachineCodeExists: string[];
                    DialogsUserManagementChangeUserSuccessNoCharactersInPassword: string[];
                    DialogsUserManagementChangeUserSuccessNoNumbersInPassword: string[];
                    DialogsUserManagementChangeUserSuccessMustContainSpecialCharacters: string[];
                    DialogsUserManagementChangeUserSuccessUnableToSaveUser: string[];
                    DialogsUserManagementChangeUserSuccessUnknownUser: string[];
                    DialogsUserManagementChangeUserSuccessUINoNewUser: string[];
                    DialogsUserManagementhangeUserSuccessUINoUserNoPassword: string[];
                    DialogsUserManagementChangeUserSuccessUINoNewPassword: string[];
                    DialogsUserManagementLogOnUINoPassword: string[];
                    DialogsUserManagementLogOnUINoNewPassword: string[];
                    DialogsUserManagementLogOnUINoOldPassword: string[];
                    DialogsUserManagementLogOnSuccessCantAccessDomainInfo: string[];
                    DialogsUserManagementLogOnSuccessInvalidPassword: string[];
                    DialogsUserManagementLogOnSuccessPasswordExpiered: string[];
                    DialogsUserManagementLogOnSuccessRenewPassword: string[];
                    DialogsUserManagementLogOnSuccessTooManyFaildLogOns: string[];
                    DialogsUserManagementLogOnSuccessUnknownUser: string[];
                    DialogsUserManagementLogOnSuccessUserDeactivated: string[];
                    DialogsUserManagementLogOnSuccessMethodCallFaild: string[];
                    DialogsUserManagementLogOnSuccessNoCorrespondingLocalUserClass: string[];
                    DialogsUserManagementLogOnSuccessUINoUserNoPassword: string[];
                    DialogsUserManagementLogOnSuccessNewPasswordsNotEqual: string[];
                };
            };
        };
        AppServices: any;
    }
}
interface ResizeObserver {
    prototype: any;
    new (callback: any): any;
}
interface VWElement extends HTMLElement {
    selectionStart: number | string;
    selectionEnd: number | string;
    value: any;
    __VWELEMENT__: string;
    winControl: any;
    select(): void;
    focus(): void;
    setSelectionRange(selectionStart: number, selectionEnd: number, selectionDirection?: string): void;
}
declare module VisiWin.Application {
    var client: any;
    var commandLine: any;
    var aktTheme: any;
    var storageName: string;
}
interface IStyles {
    controls: any;
    controlsSource: any;
    stateinfo: any;
    stateinfoSource: any;
}
declare module VisiWin.Resources {
    var namespace: string;
    var jsonUrlList: any;
    var aktTheme: string;
    var aktLang: string;
    var styles: IStyles;
    var colors: any;
    var backgrounds: any;
    var strings: any;
    var themes: any;
    var media: any;
    var states: any;
    var svgBindings: any;
    var stateCollections: any;
    var samples: any;
    var media: any;
    var cultureInfo: any;
    var animations: any;
    var shadows: any;
    var touchkeyboard: any;
}
declare module VisiWin.AppServices {
}
/** @ignore */
declare module VisiWin.AppServices.Impl {
    var namespace: string;
    interface IService {
        init(): void;
        ready(): void;
        suspend(): void;
        resume(): void;
        unload(): void;
        dispose(): any;
    }
}
/** @ignore */
declare module VisiWin.AppServicesImpl {
    /** @ignore */
    interface IService {
        init(): void;
        ready(): void;
        suspend(): void;
        resume(): void;
        unload(): void;
        dispose(): any;
    }
}
declare module VisiWin.AppServices {
    var ServiceManager: any;
    var ActionService: any;
    var AppService: any;
    var VariableService: any;
    var RecipeService: any;
    var CurrentAlarmService: any;
    var HistoricalAlarmService: any;
    var UserManagementService: any;
    var NavigationService: any;
    var LanguageService: any;
    var DataService: any;
    var DataTemplateService: any;
}
declare module Windows {
}
declare module VisiWin.Application {
    function addClientStateChangedHandler(): void;
    var restartRunning: boolean;
}
declare module VisiWin.Application {
    function addServerProjectStateChangHandler(): void;
}
declare module VisiWin.Application {
    function addSocketStateChangedHandler(): void;
}
declare module VisiWin.Application {
    var DOMContentReady: boolean;
    let ErrorLog: VisiWin.Internal.System.Diagnostics.Logging.ILogger;
    let WarnLog: VisiWin.Internal.System.Diagnostics.Logging.ILogger;
    let InfoLog: VisiWin.Internal.System.Diagnostics.Logging.ILogger;
    let VerboseLog: VisiWin.Internal.System.Diagnostics.Logging.ILogger;
    let currentLogList: any;
    let ApplicationLog: (msg: string, level: number, stack?: string) => void;
    function start(): void;
    function stop(): void;
}
declare module VisiWin.Internal {
    var InitializeSystem: any;
}
declare module VisiWin.Application {
    var imageList: any;
    var mainLayout: any;
    var loginMsgHandler: any;
}
declare module VisiWin.Application.SystemInit {
    function startLog(msg: string, level: number, overwrite: boolean): void;
    function startUp(protokoll?: string, host?: string, port?: number): void;
    function startServices(protokoll?: string, host?: string, port?: number): void;
    function InitalizeConnection(protokoll?: string, host?: string, port?: number): Promise<Start.IStartUpInfo>;
    function _InitUserOld(userName?: string, userPassword?: string): any;
    function _login(): void;
    function _InitUser(userName?: string, userPassword?: string): Promise<unknown>;
    function _InitProject(): Promise<Start.IStartUpInfo>;
    function _InitLanguage(): Promise<Start.IStartUpInfo>;
    function _InitDataAccess(): Promise<Start.IStartUpInfo>;
    function _InitAlarm(): Promise<Start.IStartUpInfo>;
    function _InitTrend(): Promise<Start.IStartUpInfo>;
    function _InitLogging(): Promise<Start.IStartUpInfo>;
    function _InitRecipe(): Promise<Start.IStartUpInfo>;
    function _InitCache(): {};
}
declare module VisiWin.Application {
    class Show {
        private _splashElement;
        private _errorElement;
        private _loginElement;
        private _contentElement;
        private _loadingPageElement;
        private _loadingPageInNavigator;
        private _loadingViewElement;
        private _loadingViewInPageInNavigator;
        private _contentsplashFlag;
        private _show;
        get show(): string;
        set show(screen: string);
        constructor();
        private ready2;
        init(): void;
        _handleLoadingPage(): void;
        _handleLoadingView(): void;
    }
}
declare module VisiWin.Internal {
    var Domain: any;
}
declare module VisiWin.Application {
    var show: any;
    var onInitReady: VisiWin.Internal.System.Events.IMessageEvent;
    var onStartUp: VisiWin.Internal.System.Events.IMessageEvent;
    var onPageLoad: VisiWin.Internal.System.Events.IMessageEvent;
    var onWebSocketOpen: VisiWin.Internal.System.Events.IEventArgs<Event>;
    var onWebSocketMessage: VisiWin.Internal.System.Events.IEventArgs<any>;
    var onWebSocketClose: VisiWin.Internal.System.Events.IEventArgs<CloseEvent>;
    var onWebSocketError: VisiWin.Internal.System.Events.IEventArgs<ErrorEvent>;
    var onWebSocketSend: VisiWin.Internal.System.Events.IEventArgs<string>;
    var _eventListeners: any;
    function _notifyWinJSEvent(eventName: string, eventData: any): void;
    function addEventListener(eventName: string, listener: any): void;
    function removeEventListener(eventName: string, listener: any): void;
}
declare module VisiWin.Application.Internal {
    function _webSocketOpenMessage(msg: any): void;
    function _webSocketCloseMessage(msg: any): void;
    function _webSocketErrorMessage(msg: any): void;
    function _webSocketSendMessage(msg: any): void;
    function _webSocketMessage(msg: any): void;
    function _onAuthorizedException(msg: any): void;
    function _onResultException(msg: any): void;
    function onPageReady(): void;
}
declare module VisiWin.Internal {
    var AppDomain: any;
}
declare module VisiWin.Application {
    class AppService {
        private static _curService;
        StartPromise: any;
        ReadyPromise: any;
        ProcessAllPromise: any;
        LoginPromise: any;
        WebSocketConnection: any;
        NavigationService: any;
        IsOnline: boolean;
        ConnectionState: number;
        LastQuery: string;
        LastResponse: string;
        CurrentUser: string;
        CurrentLanguage: VisiWin.System.Language.IProjectLanguage;
        constructor();
        Start(): void;
        static getService(): AppService;
    }
}
declare module VisiWin.UI.BindingExtension {
    let disabledClassName: string;
    let getEventParams: (destProps: any) => any;
    let getObjectFromProps: (object: any, props: any, setMode?: any) => any;
    let getIsTwoWay: (props: any) => boolean;
    let removeBindingInfo: (destProps: any) => any;
}
declare module VisiWin.Binding.Mode {
    let debug: Function;
    let oneWay: Function;
    let twoWay: Function;
    let twoWayx: Function;
    let eventToProperty: Function;
    let invokeOnEvent: Function;
    let arrayBind: Function;
    let command: Function;
}
declare namespace VisiWin.Binding {
    export interface Ias {
        as<U>(data: U): U;
    }
    export let as: typeof WinJS.Binding.as;
    export let processAll: typeof WinJS.Binding.processAll;
    export let initializer: typeof WinJS.Binding.initializer;
    export let oneTime: typeof WinJS.Binding.oneTime;
    export let Template: typeof WinJS.Binding.Template;
    interface IKeyDataPair<T> {
        key: string;
        data: T;
    }
    export interface IList<T> {
        getItem(index: number): IKeyDataPair<T>;
        getItemFromKey(key: string): IKeyDataPair<T>;
        indexOfKey(key: string): number;
        move(index: number, newIndex: number): void;
        notifyMutated(index: number): void;
        reverse(): void;
        setAt(index: number, newValue: T): void;
        sort(sortFunction: (left: T, right: T) => number): void;
        splice(start: number, howMany?: number, ...item: T[]): T[];
        length: number;
        addEventListener(type: string, listener: Function, useCapture?: boolean): void;
        bind(name: string, action: Function): any;
        concat(...item: T[]): T[];
        createFiltered(predicate: (x: T) => boolean): any;
        createGrouped(groupKey: (x: T) => string, groupData: (x: T) => any, groupSorter: (left: string, right: string) => number): any;
        createSorted(sorter: (left: T, right: T) => number): any;
        dispatchEvent(type: string, eventProperties: any): boolean;
        every(callback: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;
        filter(callback: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];
        forEach(callback: (value: T, index: number, array: T[]) => void, thisArg?: any): void;
        getAt(index: number): T;
        indexOf(searchElement: T, fromIndex?: number): number;
        join(separator: string): string;
        lastIndexOf(searchElement: T, fromIndex: number): number;
        map<G>(callback: (value: T, index: number, array: T[]) => G, thisArg?: any): G[];
        notify(name: string, newValue: any, oldValue: any): Promise<any>;
        notifyReload(): void;
        reduce(callback: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => T, initiallValue?: T): T;
        reduceRight(callback: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => T, initialValue?: T): T;
        removeEventListener(type: string, listener: Function, useCapture?: boolean): void;
        slice(begin: number, end: number): T[];
        some(callback: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;
        unbind(name: string, action: Function): any;
        dataSource: WinJS.UI.IListDataSource<T>;
    }
    export let List: typeof WinJS.Binding.List;
    export let converter: typeof WinJS.Binding.converter;
    export let defaultBind: typeof WinJS.Binding.defaultBind;
    export let getValue: any;
    export let setAttribute: typeof WinJS.Binding.setAttribute;
    export let setAttributeOneTime: typeof WinJS.Binding.setAttributeOneTime;
    export let addClassOneTime: typeof WinJS.Binding.addClassOneTime;
    export {};
}
declare module VisiWin.AppServices.Impl {
    interface IServiceManger {
    }
    class ServiceManager implements IServiceManger {
        services: any;
        _service: any;
        private selectedHomeSection;
        private initReady;
        private readyReady;
        private suspendReady;
        servicePromises: any[];
        constructor();
        private initServiceHandler;
        private readyServiceHandler;
        private unloadServiceHandler;
        addService(name: string, serv: any): boolean;
        static getService<T>(name: string): T | null;
    }
}
declare module VisiWin.AppServices.Impl {
    class ServiceBase implements VisiWin.AppServices.Impl.IService {
        private _eventListeners;
        constructor();
        createEvent(eventName: string): void;
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        removeEvent(eventName: string): void;
        dispatchEvent<T = void>(eventName: string, eventData: T): void;
        init(): void;
        ready(): void;
        ready2(): void;
        suspend(): void;
        resume(): void;
        unload(): void;
        dispose(): void;
    }
}
declare module VisiWin.AppServices.Impl {
    class AppService extends VisiWin.AppServices.Impl.ServiceBase {
        static namespace: string;
        static serviceName: string;
        static requireServices: string[];
        mappingData: any;
        aktMedia: string;
        aktTheme: string;
        private svgBindingFileList;
        private svgStateFileList;
        private setting_DirThemesDefault;
        private setting_ThemeOptionsDefault;
        private setting_DirThemes;
        private _oldMediaClassName;
        private actions;
        userAgent: string;
        browser: string;
        browserVersion: string;
        browserOs: string;
        constructor();
        ready(): void;
        initService(): void;
        private _loadThemes;
        private mixProperties;
        /**
         *  mix AppSettings (project settings in default settings)
         *   Parameter:
         *      defaultObj: any     default settings data from ApplicationBase
         *      newObj: any         insert new object data in default data
         *   Return:
         *       mix Object         return mix data
        */
        mixAppSettings(defaultObj: any, newObj: any): any;
        getAppSettings(key: string): any;
        getPathSetting(key: string): string;
        private _runtimeVersion;
        getPathString(key: string): any;
        getMediaOptions(id: string, mname: string): string;
        getDefaultOptions(id: any, secondId: any): string;
        getThemeOptions(id: string): any;
        getSVGBinding(id: string): any;
        getState(id: string): any;
        getTouchkeyboard(id: string): any;
        getTheme(id: string): any;
        changeTheme(themeUrl: any): any;
        removeWidthAction(action: string, width: any, event: any): boolean;
        addWidthAction(action: string, width: any, event: any): boolean;
        _checkActions(trgFlag: boolean): void;
        private _setBrowserDepend;
        private _checkBrowser;
        private _isInDesignMode;
        get isInDesignMode(): boolean;
        set isInDesignMode(value: boolean);
    }
}
declare module VisiWin.AppServices {
    var ServiceManager: any;
    var DataService: any;
    var LanguageService: any;
    var AppService: any;
    var VariableService: any;
    var CurrentAlarmService: any;
    var HistoricalAlarmService: any;
    var RecipeService: any;
    var UserManagementService: any;
    var NavigationService: any;
    var DataTemplateService: any;
    var ViewModelService: any;
}
declare module VisiWin.AppServices.Impl {
    let registerAppService: (srv: string) => void;
    let initAppServices: () => Promise<any> | null;
}
declare namespace VisiWin.AppServices {
    interface IDataService {
        registerDesignTimeObservable?(name: string, description: any, observabledescription: any): void;
        setTriggerData?(name: string, value: any, triggerDataLocal: any): void;
        getData?(name: string, triggerDataLocal: any, defaultValue?: any): Promise<any>;
        dataServiceStore: VisiWin.AppServices.Impl.IDataServiceStore;
    }
}
declare namespace VisiWin {
    interface IConverterDescription {
        name: string;
        displayName: string;
        info: string;
        inputType: string;
        inputSubType: string;
        outputType: string;
        outputSubType: string;
    }
    interface IBindingDescription {
        name: string;
        displayName: string;
        access: string;
        type: string;
    }
}
declare namespace VisiWin {
    interface IDataSources {
        [idx: string]: any;
    }
    let DataSources: IDataSources;
    interface IObservable {
        [idx: string]: any;
    }
    let Observables: IObservable;
}
declare module VisiWin.AppServices.Impl {
    class DataService extends VisiWin.AppServices.Impl.ServiceBase implements VisiWin.AppServices.IDataService {
        static namespace: string;
        static serviceName: string;
        static requireServices: any[];
        private observable;
        private dataSources;
        private converters;
        private bindings;
        dataServiceStore: VisiWin.AppServices.Impl.IDataServiceStore;
        constructor();
        getBinding(name: string): any;
        getDataSource(name: string): any;
        registerDesignTimeObservable(name: string, description: any, observabledescription: any): void;
        registerDesignTimeDataSource(name: string, description: any, observabledescription: any): void;
        init(): void;
        ready(): void;
        unload(): void;
        dispose(): void;
        private getObservables;
        private getObservablesDescription;
        private getObservableDescriptionByName;
        private getDataSources;
        private getDataSourcesDescription;
        private getDataSourceDescriptionByName;
        private getConverters;
        private registerDesignTimeConverter;
        private getConverterByName;
        private Observables;
        private DataSources;
        setData(name: string, value: any): void;
        clearTriggerData(): void;
        clearTriggerDataStartsWidth(prefix: string): void;
        setTriggerData(name: string, value: any): void;
        getTriggerData(name: string): any;
        getData(name: string, defaultValue?: any, prefixData?: string): Promise<any>;
        private AlertDialog;
        private AlertDialogDescription;
        private AlertDialogObservableDescription;
        private _initObservables;
        private Timer;
        private TimerDescription;
        private TimerObservableDescription;
        private getBindings;
        private registerBinding;
        private getBindingsByName;
        private getDescription;
        private _getVariable;
        private __getVariable;
        private _getThemeData;
        private _getMappingData;
        private insertSampleData;
    }
}
declare module VisiWin.Utilities {
    function preServiceImport(): void;
    function postServiceImport(): void;
    function copyPropertyArray(target: any, targetIndex: number, source: any, sourceIndex: number): void;
    function copyPropertyObj(target: any, source: any, prop: string): void;
    function translateTheme(source: any, dest: any, infoString: string): void;
    function translateLoc(source: any, dest: any, infoString: string): void;
    function loadJsonResource(url: string, globalResource: string, infoString: string): any;
    function loadJsResource(url: string, globalResource: string, infoString: string): any;
    function loadJSCssTag(url: string): any;
    function loadCssTag(url: string): any;
    function loadJsTag(url: string): HTMLScriptElement;
    function jsXhr(options: any): any;
}
declare module VisiWin.AppServices.Impl {
    class ActionService extends VisiWin.AppServices.Impl.ServiceBase {
        static namespace: string;
        static serviceName: string;
        static requireServices: any[];
        private triggerResultList;
        private triggerData;
        private mappingData;
        constructor();
        private setData;
        clearTriggerData(): void;
        clearTriggerDataStartsWidth(prefix: string): void;
        setTriggerData(name: string, value: any): void;
        getTriggerData(name: string): any;
        private _getMappingData;
        getData(name: string, defaultValue?: any, prefixData?: string): Promise<any>;
        executeAction(name: string, value: any, targetElements: any, triggerData: any): Promise<any>;
        init(): void;
        ready(): void;
        unload(): void;
        dispose(): void;
    }
}
declare module VisiWin.AppServices.Impl {
    class CurrentAlarmViewModel {
        currentAlarm: any;
        currentAlarmList: any;
        currentAlarmLine: any;
        constructor();
    }
    class CurrentAlarmService extends VisiWin.AppServices.Impl.ServiceBase {
        static namespace: string;
        static serviceName: string;
        static requireServices: string[];
        vm: any;
        private static _instanceCounter;
        private _alarmService;
        private _currentAlarms;
        private _appService;
        private _langService;
        private _currentAlarm;
        constructor();
        static createRequestId(): string;
        private alarmCounterUpdate;
        private _currentAlarmsChange;
        init(): void;
        private _changeColorService;
        private _changeLocService;
        ready(): void;
        private _insertSampleData;
        /**
        * Property: sampleData.
        * Setting the sampleData will loading a file with some sample alarm data.
        * This is use at design time.
        * When finished loading the sample data, event will dispatch: "sampleDataLoaded"
       **/
        private _sampleData;
        set sampleData(val: string);
        get sampleData(): string;
        unload(): void;
        dispose(): void;
        /**@function
        * Acknowledges an alarm. The system time is used as acknowlegdement time stamp.
        */
        acknowledgeAlarm(strGroupAndName: string | number): void;
        /**@function
        * Object for filtering alarms.
        */
        createAlarmFilter(): VisiWin.System.Alarm.IAlarmFilter;
        /**@function
        * Returns a CurrentAlarms object that contains all pending alarms.
        */
        getCurrentAlarms(filter: VisiWin.System.Alarm.IAlarmFilter): VisiWin.System.Alarm.ICurrentAlarms;
        /**@function
        * Acknowledges all pending alarms from an alarm class.
        * @param name of the alarm class
        */
        acknowledgeAlarmClass(className: string): void;
        /**@function
        * Acknowledges all pending alarms of an alarm group.
        * @param name of the alarm group
        */
        acknowledgeAlarmGroup(groupName: string): void;
        /**@function
        * Acknowledges all alarms currently pending in the system.
        */
        acknowledgeAllAlarms(): void;
    }
}
declare module VisiWin.AppServices.Impl {
    class HistoricalAlarmViewModel {
        historicalAlarm: any;
        historicalAlarmList: any;
        constructor();
    }
    class HistoricalAlarmService extends VisiWin.AppServices.Impl.ServiceBase {
        static namespace: string;
        static serviceName: string;
        static requireServices: string[];
        maxPriority: any;
        minPriority: any;
        private static _instanceCounter;
        private _alarmService;
        private _historicalAlarms;
        private _appService;
        vm: any;
        private _historicalAlarm;
        /**
          * Property: desiredClasses
          * A Filer for the alarmlist.
          * Alarm will be add to alarm list when class of alarm item is the array from desiredClasses.
          * Setting the filter will new initialize the alarmsystem.
         **/
        private _desiredClasses;
        private _desiredClassesArray;
        set desiredClasses(val: any);
        get desiredClasses(): any;
        /**
         * Property: desiredGroups
         * A Filer for the alarmlist.
         * Alarm item will be add to alarm list when historical group of alarm item is the array from desiredGroups.
         * Setting the filter will new initialize the alarmsystem.
        **/
        private _desiredGroups;
        private _desiredGroupsArray;
        set desiredGroups(val: any);
        get desiredGroups(): any;
        /**
         * Property: desiredStates
         * A Filer for the alarmlist.
         * Alarm will be add to alarm list when historical state of alarm item is the array from desiredStates.
         * Setting the filter will new initialize the alarmsystem.
        **/
        private _desiredStates;
        private _desiredStatesArray;
        set desiredStates(val: any);
        get desiredStates(): any;
        dateAdd(date: any, interval: any, units: any): Date;
        dateSub(date: any, interval: any, units: any): Date;
        private _minDate;
        set minDate(val: any);
        get minDate(): any;
        private _maxDate;
        set maxDate(val: any);
        get maxDate(): any;
        private _period;
        set period(val: string);
        get period(): string;
        updateAlarmList(): void;
        constructor();
        static createRequestId(): string;
        private alarmCounterUpdate;
        private _historicalAlarmsChange;
        init(): void;
        private _changeColorService;
        private _changeLocService;
        ready(): void;
        xready(): void;
        unload(): void;
        dispose(): void;
        /**@function
        * Object for filtering historical alarms.
        */
        createHistoricalAlarmFilter(): VisiWin.System.Alarm.IHistoricalAlarmFilter;
        /**@function
        * Creates an object to query historical alarm data.
        * @param VisiWin.System.Alarm.IHistoricalAlarmFilter
        */
        createHistoricalAlarmRequest(filter: VisiWin.System.Alarm.IHistoricalAlarmFilter): VisiWin.System.Alarm.IHistoricalAlarms;
    }
}
declare namespace Converters {
    let booleanInverter: Function;
}
declare namespace Converters {
    function initialized(): void;
}
declare namespace Converters {
    let boolToVisibilityHidden: Function;
    let boolToVisibilityCollapse: Function;
}
declare module VisiWin.AppServices.Impl.Variable {
    interface VariableType {
        variableType: string;
        name: string;
        source: string;
        nameSpace: string;
        variableName: string;
        propertyNames: string[];
        vwName: string;
        type: string;
        access: string;
        oneTime: boolean;
        mapping: boolean;
        handler: any;
        value: any;
        defaultValue: any;
    }
    interface flags {
        dynamic: boolean;
    }
    enum InteractivEvents {
        NoUserNoPassword = 0,
        NoUser = 1,
        NoPassword = 2,
        NoNewPassword = 3,
        NoOldPassword = 4,
        NewPasswordsNotEqual = 5
    }
}
declare module VisiWin.AppServices.Impl {
    class VariableService extends VisiWin.AppServices.Impl.ServiceBase {
        static namespace: string;
        static serviceName: string;
        static requireServices: string[];
        mappingData: {};
        variabeNamespace: string;
        vm: any;
        private _appService;
        private _variableService;
        touchkeyboardInfo: any;
        touchkeyboardInfoDescription: any;
        touchkeyboardInfoObservableDescription: any;
        /**
        * Property: sampleData.
        * Setting the sampleData will loading a file with some sample alarm data.
        * This is use at design time.
        * When finished loading the sample data, event will dispatch: "sampleDataLoaded"
        **/
        private _sampleData;
        set sampleData(val: string);
        get sampleData(): string;
        /**
         * constructor: Creates a new RecipeProvider.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor();
        init(): void;
        ready(): void;
        private _initObservables;
        unload(): void;
        data: any;
        private boundProccessChangeHandler;
        proccessChangeHandler(args: any): void;
        addVariable(name: string, varObject: VisiWin.AppServices.Impl.Variable.VariableType): void;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call aber dispose
        **/
        dispose(): void;
        /**@function getVariable
        * @description An empty IVariable object by variable name.
        * @param {string} variableName The alias of the variable.
        * @returns {VisiWin.System.DataAccess.IVariable}
        */
        getVariable(variableName: string): VisiWin.System.DataAccess.IVariable;
        /**
        * @function getValueAsync
        * @description Reads the value of the variable.
        * @param {string} variableName The alias of the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.IGetValueResult>} the extended result of the operation
        */
        getValueAsync(variableName: string, resultDetails: boolean): Promise<VisiWin.System.DataAccess.IGetValueResult>;
        /**@function SetValueAsync
        * @description Writes the value passed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {any} newValue The value for the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetValueResult>} The extended result of the operation
        */
        setValueAsync(variableName: string, newValue: any, resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetValueResult>;
        /**@function setRawValueAsync
        * @description Writes the valuespassed in the given process variable.
        * @param {string} variableName The alias of the variable.
        * @param {any} newValue The raw value for the variable.
        * @param {boolean} resultDetails The result of the operation returns additional informations.
        * @returns {Promise<VisiWin.System.DataAccess.ISetValueResult>} The extended result of the operation
        */
        setRawValueAsync(variableName: string, newValue: any, resultDetails: boolean): Promise<VisiWin.System.DataAccess.ISetValueResult>;
    }
}
declare namespace VisiWin.AppServices {
    type localizedTextOverLoad = VisiWin.System.Language.TextType | string;
    interface ILanguageService extends VisiWin.AppServices.Impl.ServiceBase {
        /**
        * Shows information of all available languages in this application.
        */
        availableProjectLanguages: VisiWin.AppServices.ILanguageDefinition[];
        /**
        * Shows the language lcid currently set in the application.
        */
        currentLcid: number;
        /**
        * Shows the language locale currently set in the application.
        */
        currentLanguage: string;
        /**@function
        * @description Change the project language
        * @name  changeLanguageAsync
        * @returns  Promise<string>
        */
        changeLanguageAsync(locale: string): Promise<string>;
        /** @ignore */
        getTextFallback(ids: string[]): Promise<VisiWin.AppServices.IGetFallBackText>;
        /**@function
        * @description Returns a 'LocalizedText' for the specified language switchable text
        * @name  getLocalizedTextAsync
        * @returns Promise<VisiWin.System.Language.ILocalizedText>
        */
        getLocalizedTextAsync(param1?: localizedTextOverLoad, param2?: localizedTextOverLoad, param3?: localizedTextOverLoad): Promise<VisiWin.System.Language.ILocalizedText>;
        /** @ignore */
        addLocalizedTextAsync(id: string, handlerFunction: VisiWin.AppServices.IChangeHandler): Promise<System.Language.ILocalizedText>;
        /** @ignore */
        removeLocalizedText(id: string, handlerFunction: VisiWin.AppServices.IChangeHandler, locTextInstance: VisiWin.System.Language.ILocalizedText): any;
        /** @ignore */
        removeLocalizedTextHandler(id: string, handlerFunction: VisiWin.AppServices.IChangeHandler, locTextInstance: VisiWin.System.Language.ILocalizedText): any;
        /** @ignore */
        addLocalizedTextHandler(id: string, handlerFunction: VisiWin.AppServices.IChangeHandler, locTextInstance: VisiWin.System.Language.ILocalizedText): any;
        /**
        * @ignore
        * @deprecated
        * @description Deprecated do not use this!
        */
        aktLang: string;
        /**
        * @ignore
        * @deprecated
        * @description Deprecated do not use this!
        */
        getOptions(id: string): string;
        /** @ignore */
        ProjectLanguages: VisiWin.AppServices.ILanguageDefinition[];
        /** @ignore */
        CurrentLanguage: VisiWin.AppServices.ILanguageDefinition;
    }
    /** @ignore */
    interface ILanguageDefinition {
        englishName: string;
        locale: string;
        lcid: number;
        nativeName: string;
        NativeName?: string;
        LCID?: number;
        EnglishName?: string;
        Name?: string;
    }
    /** @ignore */
    interface IGetFallBackText {
        text: string;
        textIds: string[];
        index: number;
    }
    /** @ignore */
    interface IChangeHandler {
        (param: VisiWin.System.Language.ILocalizedTextChangedEventArgs): void;
    }
}
declare namespace VisiWin.AppServices.Impl {
    /** @ignore */
    class ProjectLanguage implements VisiWin.AppServices.ILanguageDefinition {
        /**
        * Indication of the 'LCID' property value
        * @member { number }
        */
        lcid: number;
        /**
        * Indication of the 'locale' property value eg: "en-US" "language-Country"
        */
        locale: string;
        /**
        * Gets english language name from Intl.DisplayNames(["en-US"], { type: "language" }).of(this.ShortLocale);
        */
        englishName: string;
        /**
        * Gets native language name from Intl.DisplayNames([this.Locale], { type: "language" }).of(this.ShortLocale);
        */
        nativeName: string;
    }
    /** @ignore */
    class LocalizedText {
        DisplayText: string;
        TextGroup: string;
        TextName: string;
        TextType: VisiWin.System.Language.TextType;
        FullQualifiedText: string;
        Changed: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Language.ILocalizedTextChangedEventArgs>;
    }
    class LanguageService extends VisiWin.AppServices.Impl.ServiceBase implements VisiWin.AppServices.ILanguageService {
        /** @ignore */
        static namespace: string;
        /** @ignore */
        static serviceName: string;
        /** @ignore */
        static requireServices: string[];
        private _FALLBACKLANGUAGE;
        private _CLIENTSYSTEMPREFIX;
        private _SERVERSYSTEMPREFIX;
        private _APPSERVICESLANGUAGESERVICE;
        private _DESIGNTIMELANGUAGE;
        private _RUNTIMELANGUAGE;
        private _DESIGNTIMELANGUAGE_OLD;
        private _RUNTIMELANGUAGE_OLD;
        private _LANGUAGECHANGED;
        private _appService;
        private _languageService;
        private _session;
        private _clientStrings;
        private _runtimeLanguage;
        private _desingerLanguage;
        private _currentLanguage;
        private languageListDescription;
        private languageListDataSourceDescription;
        private actualLanguageDescription;
        private actualLanguageDataSourceDescription;
        private _oldUiLanguages;
        private _oldDesignTimeLanguage;
        private _oldRunTimeLanguage;
        /**
        * @ignore
        * @description Deprecated do not use this!
        */
        aktLang: string;
        availableProjectLanguages: VisiWin.AppServices.ILanguageDefinition[];
        CurrentLanguage: VisiWin.AppServices.ILanguageDefinition;
        currentLcid: number;
        ProjectLanguages: VisiWin.AppServices.ILanguageDefinition[];
        constructor();
        get currentLanguage(): string;
        set currentLanguage(value: string);
        changeLanguageAsync(locale: string): Promise<string>;
        getTextFallback(ids: string[]): Promise<IGetFallBackText>;
        addLocalizedTextAsync(id: string, f: IChangeHandler): Promise<System.Language.ILocalizedText>;
        addLocalizedTextHandler(id: string, f: IChangeHandler, locTextInstance: VisiWin.System.Language.ILocalizedText): Promise<void>;
        removeLocalizedText(id: string, f: IChangeHandler, locTextInstance: VisiWin.System.Language.ILocalizedText): void;
        removeLocalizedTextHandler(id: string, f: IChangeHandler, locTextInstance: VisiWin.System.Language.ILocalizedText): void;
        getOptions(id: string): string;
        init(): void;
        private _initDataSources;
        private _initObservables;
        private _mixProperties;
        private _getText;
        private _updateClientTexts;
        private _fillAvailableProjectLanguages;
        private _getProjectLanguage;
        private _getProjectLanguageFromLcid;
        private _getLocalStorageLanguageTag;
        private _setLocalStorageLanguageTag;
        private _getLocalStorageName;
        /**@function
        * @description Returns a 'LocalizedText' for the specified language switchable text
        * @returns Promise<VisiWin.System.Language.ILocalizedText>
        */
        getLocalizedTextAsync(param1?: VisiWin.AppServices.localizedTextOverLoad, param2?: VisiWin.AppServices.localizedTextOverLoad, param3?: VisiWin.AppServices.localizedTextOverLoad): Promise<VisiWin.System.Language.ILocalizedText>;
        changeLanguageLcidAsync(lcid: number): Promise<number>;
    }
}
declare namespace VisiWin.AppServices.Impl.Navigation {
    /**
    * Internal do not use
    * @internal
    * */
    interface IProposed {
        location: string;
        state: {};
    }
    /**
    * Internal do not use
    * @internal
    * */
    interface ICurrent extends IProposed {
        initialPlaceholder?: boolean;
    }
    export interface INavigationInfo extends ICurrent {
        value?: any;
        setPromise?(promise: Promise<any>): any;
        error?: any;
        isPage?: boolean;
        isView?: boolean;
        regionID?: string;
        pageLocation?: string;
        viewLocation?: string;
        ctrl?: any;
        showLoadingSymbol?: boolean;
    }
    export interface IPreloadObject {
        preloadingEnable: boolean;
        preloadingFileCount: number;
        preloadingCounter: number;
        preloadingFilename: string;
        preloadingPercent: number;
        preloadingReady: boolean;
    }
    export interface INavigationResultDetails {
        detail: INavigationInfo;
    }
    export interface INavigationResultPreload {
        detail: IPreloadObject;
    }
    /**
    * Internal do not use
    * @internal
    * */
    export interface IHistory {
        backStack: INavigationInfo[];
        current: INavigationInfo;
        forwardStack: INavigationInfo[];
    }
    /**
    * Internal do not use
    * @internal
    * */
    interface INavigationServiceProperties {
        canGoBack: boolean;
        canGoForward: boolean;
        history: any;
        location: string;
        state: {};
    }
    /**
    * Internal do not use
    * @internal
    * */
    interface INavigationServiceFunctions extends INavigationServiceProperties {
        back(distance?: number): Promise<boolean>;
        forward(distance?: number): Promise<boolean>;
        navigate(location: string, initialState?: {}): Promise<any>;
    }
    /**
    * Internal do not use
    * @internal
    * */
    export interface INavigationService extends INavigationServiceFunctions {
        navigateToPage(pageName: string, options: any): Promise<INavigationResultDetails>;
        navigateToView(pageName: string, viewName: string, regionName: string, options: any): Promise<INavigationResultDetails>;
        /**
        * Internal do not use
        * @internal
        * */
        beforenavigate?: CustomEvent;
        /**
        * Internal do not use
        * @internal
        * */
        navigated?: CustomEvent;
        /**
        * Internal do not use
        * @internal
        * */
        navigating?: CustomEvent;
    }
    export interface IPageTitle {
        menuTitle: string | null;
        localizableMenuTitle: string | null;
        pageTitle: string | null;
        localizebalePageTitle: string | null;
    }
    export {};
}
declare namespace VisiWin.AppServices.Impl {
    class NavigationService extends VisiWin.AppServices.Impl.ServiceBase implements VisiWin.AppServices.Impl.Navigation.INavigationService {
        static namespace: string;
        static serviceName: string;
        static requireServices: string[];
        private _currentPage;
        pageInfo: VisiWin.UI.PageInfo[];
        appNavMenuItems: any[];
        isNavigationCurrentlyRunning: boolean;
        preloadingObject: VisiWin.AppServices.Impl.Navigation.IPreloadObject;
        preloadingObjectDescription: any;
        preloadingObjectObservableDescription: any;
        private _skippedPages;
        private _includePartiallyLoadedPages;
        private _requestedPage;
        private _navigatedEventName;
        private _navigatedInternalEventName;
        private _navigatingEventName;
        private _beforenavigateEventName;
        private _onPageTitleChanged;
        private _onViewTitleChanged;
        private _onPageChangedEventname;
        private _onViewChangedEventname;
        private _onloadingPageName;
        private _preloadingReady;
        private _storageName;
        private _storageExtension;
        preloadCount: number;
        preloadCounter: number;
        private _preloadReadyName;
        private _preloadChangeName;
        appShellReady: boolean;
        startPageInit: boolean;
        private _startPage;
        set startPage(url: string);
        get startPage(): string;
        set preloadingReady(ready: boolean);
        get preloadReadyFlag(): boolean;
        private _history;
        private _pageHistorySize;
        private _pageHistory;
        private _viewHistorySize;
        private _viewHistory;
        private _showLoadingPageForUncachedPages;
        private _loadingPage;
        private _loadingView;
        private _requieredPage;
        /**
        * Internal do not use
        * @internal
        * */
        private _getTitleFromNavMenu;
        /**
        * Internal do not use
        * @internal
        * */
        registerMenuItems(args: any): void;
        incrementPreloadCounter(fileName: string, ready?: boolean): void;
        /**
        * Internal do not use
        * @internal
        * */
        _updateFromRegionNavigation(details: VisiWin.AppServices.Impl.Navigation.INavigationInfo): void;
        /**
        * Internal do not use
        * @internal
        * */
        _beforeNavigate(args: VisiWin.AppServices.Impl.Navigation.INavigationResultDetails): Promise<void>;
        private _resolvePageChange;
        private _rejectPageChange;
        private _handlePageChangeEvent;
        private _resolveViewChange;
        private _handleViewChangeEvent;
        private _resolveLoadingViewChange;
        private _handleLoadingViewChangeEvent;
        constructor();
        private _initObservables;
        currentPageName: string;
        currentPage: any;
        private _navigateToLoadingPage;
        navigateToPage(pageName: string, pageOptions: any, showLoadingSymbol?: boolean): Promise<VisiWin.AppServices.Impl.Navigation.INavigationResultDetails>;
        getPageHistory(): VisiWin.AppServices.Impl.Navigation.INavigationInfo[];
        currentViewName: string;
        currentView: any;
        navigateToView(pageName: string, viewName: string, regionName: string, pageOptions: any, showLoadingSymbol?: boolean): Promise<VisiWin.AppServices.Impl.Navigation.INavigationResultDetails>;
        navigateToViews(pageName: string, viewNames: string[], regionNames: string[], pageOptions: any, showLoadingSymbol?: boolean): Promise<VisiWin.AppServices.Impl.Navigation.INavigationResultDetails[]>;
        getViewHistory(regionName?: string): VisiWin.AppServices.Impl.Navigation.INavigationInfo[];
        private _handleMissingPages;
        raiseBeforeNavigate(proposed: {
            location: string;
            state: any;
            showLoadingSymbol?: boolean;
        }): Promise<any>;
        raiseNavigating(delta: number): Promise<any>;
        raiseNavigated(value: any, err: any): Promise<any>;
        navigate(location: string, initialState: object, showLoadingSymbol?: boolean): Promise<any>;
        get canGoForward(): boolean;
        get canGoBack(): boolean;
        get location(): string;
        get state(): object;
        set state(value: object);
        get history(): VisiWin.AppServices.Impl.Navigation.IHistory;
        set history(value: VisiWin.AppServices.Impl.Navigation.IHistory);
        go(distance: number, fromStack: VisiWin.AppServices.Impl.Navigation.INavigationInfo[], toStack: VisiWin.AppServices.Impl.Navigation.INavigationInfo[], delta: number): Promise<any>;
        forward(distance: number): Promise<boolean>;
        back(distance: number): Promise<boolean>;
        getCurrentPage(): string;
        getPageInfo(pageName: string): VisiWin.UI.PageInfo;
        setPageState(pageName: string, state: VisiWin.UI.PageState): void;
        /**
         * public method: dispose destroy the service
        **/
        dispose(): void;
        init(): void;
        ready(): void;
        unload(): void;
    }
}
declare namespace VisiWin.UI {
    /**
    * public enum PageState
    * @enum PageState
    */
    enum PageState {
        /**
         * Initial Value after navigate has call
         * pre navigating the object will not exits
         */
        "PageBeforeNavigate" = "pageBeforeNavigate",
        /**
         * Navigate operation is in process
         */
        "PageNavigating" = "pageNavigating",
        /**
         * Navigate Operation is ready
         */
        "PageNavigated" = "pageNavigated",
        /**
        * Postworking operation on page is ready (after processAll)
        */
        "PageReady" = "pageReady",
        /**
        * Navigate Operation is ready
        */
        "PageInitialize" = "pageInitialize",
        /**
        * Attach operation ready
        */
        "PageAttach" = "pageAttach",
        /**
         * Attach operation ready
         */
        "PageDetach" = "pageDetach",
        /**
         * Dispose operation, control inactiv
         */
        "PageDispose" = "pageDispose"
    }
    interface PageInfo {
        state: VisiWin.UI.PageState;
        isReady: boolean;
        isInit: boolean;
        isAttach: boolean;
        isDetach: boolean;
    }
}
declare module VisiWin.AppServices.Impl {
    class RecipeService extends VisiWin.AppServices.Impl.ServiceBase {
        static namespace: string;
        static serviceName: string;
        private _recipeService;
        private _session;
        private _recipeClassNames;
        set recipeClassNames(value: string[]);
        get recipeClassNames(): string[];
        constructor();
        getRecipeClassAsync(recipeClassName: string): Promise<VisiWin.System.Recipe.IGetRecipeClassResult>;
        deleteFileAsync(recipeClassName: string, recipeFileName: string): Promise<VisiWin.System.Recipe.IDeleteFileResult>;
        getRecipeFileAsync(recipeClassName: string, recipeFileName: string): Promise<VisiWin.System.Recipe.IGetRecipeFileResult>;
        getRecipeFileNamesAsync(recipeClassName: string): Promise<VisiWin.System.Recipe.IGetRecipeFileNamesResult>;
        loadRecipeFileValuesAsync(recipeClassName: string, recipeFileName: string, variableNames?: string[] | null): Promise<VisiWin.System.Recipe.IRecipeServiceLoadRecipeFileValuesResult>;
        unlockAllAsync(): Promise<boolean>;
        private _currentActionRecipeClass;
        private _pendingActionRecipeClassRequests;
        private _hasPendingActionRecipeClassRequests;
        _initRecipeClassForAction(recipeClassName: string): Promise<VisiWin.System.Recipe.IRecipeClass>;
        private _setRecipeClass;
        private _registerDesignTimeViewModels;
        init(): Promise<void>;
        ready(): void;
        unload(): void;
        dispose(): void;
    }
}
declare module VisiWin.AppServices.Impl.UserManagement {
    enum InteractivEvents {
        NoUser = 0,
        NoGroupName = 1,
        NoPassword = 2,
        NoUserNoPassword = 3,
        NoNewPassword = 4,
        NoOldPassword = 5,
        NoRepeatPassword = 6,
        NewPasswordsNotEqual = 7,
        NoWorkState = 8
    }
    interface ICurrentUser {
        name: string;
        Name: string;
        fullName: string;
        FullName: string;
    }
    interface ILogon {
        name: string;
        password: string;
        errorText: string;
        isUserNameError: boolean;
        isPasswordError: boolean;
        canExecute: boolean;
        reset: any;
        command: any;
    }
    interface IChangePassword {
        name: string;
        fullName: string;
        password: string;
        newPassword: string;
        repeatPassword: string;
        errorText: string;
        isPasswordError: boolean;
        isNewPasswordError: boolean;
        isRepeatPasswordError: boolean;
        canExecute: boolean;
        reset: any;
        command: any;
    }
    interface IAddUser {
        name: string;
        fullName: string;
        groupName: string;
        userState: string;
        newPassword: string;
        repeatPassword: string;
        errorText: string;
        isUserNameError: boolean;
        isUserFullNameError: boolean;
        isUserGroupError: boolean;
        isNewPasswordError: boolean;
        isRepeatPasswordError: boolean;
        isUserStateError: boolean;
        isUserCodeError: boolean;
        canExecute: boolean;
        reset: any;
        command: any;
    }
    interface IChangeUser {
        name: string;
        fullName: string;
        groupName: string;
        userState: string;
        newPassword: string;
        repeatPassword: string;
        errorText: string;
        changePasswordFlag: boolean;
        noUserSelected: boolean;
        isUserNameError: boolean;
        isUserFullNameError: boolean;
        isUserGroupError: boolean;
        isUserStateError: boolean;
        isPasswordError: boolean;
        isNewPasswordError: boolean;
        isRepeatPasswordError: boolean;
        isCodeError: boolean;
        canExecute: boolean;
        reset: any;
        command: any;
    }
    interface IRemoveUser {
        name: string;
        errorText: string;
        isUserNameError: boolean;
        canExecute: boolean;
        reset: null;
        command: null;
    }
    interface IUserListItem {
        name: string;
        fullName: string;
        groupName: string;
        userState: string;
        locUserState: string;
    }
    interface IUserGroupListItem {
        name: string;
        text: string;
        locText: string;
    }
}
declare module VisiWin.AppServices.Impl {
    class UserManagementService extends VisiWin.AppServices.Impl.ServiceBase {
        static namespace: string;
        static serviceName: string;
        static requiredServices: string[];
        private currentUser;
        private currentUserDescription;
        private currentUserObservableDescription;
        private logon;
        private logonDescription;
        private logonObservableDescription;
        private logonHandler;
        private changePassword;
        private changePasswordDescription;
        private changePasswordObservableDescription;
        private changePasswordHandler;
        private addUser;
        private addUserDescription;
        private addUserObservableDescription;
        private addUserHandler;
        private changeUser;
        private changeUserDescription;
        private changeUserObservableDescription;
        private changeUserHandler;
        private removeUser;
        private removeUserDescription;
        private removeUserPropertyDescription;
        private removeUserHandler;
        private userList;
        private removableUserList;
        private userListDescription;
        private userListDataSourceDescription;
        private userGroupList;
        private userGroupListDescription;
        private userGroupListDataSourceDescription;
        private _appService;
        private _userManagementService;
        private _boundUserLoggedOnHandler;
        private _boundUserLoggedOffHandler;
        private _boundUsersModifiedHandler;
        private _boundGroupsModifiedHandler;
        private _boundRightsModifiedHandler;
        private _dataService;
        userStateList: any[];
        constructor();
        ready(): Promise<void>;
        private _initObservables;
        private _userStateIndexByName;
        private _userStateByIndex;
        private _locUserStateByIndex;
        private _copyReturnToUser;
        forceUserManagementUpdate(): Promise<void>;
        private updateUserList;
        private updateUserGroupList;
        private resultRemoveUser;
        private resultAddUser;
        private resultAddUserExpirse;
        private resultChangeUserExpirse;
        private resultChangeUser;
        private resultLogOnUserExpirse;
        private resultLogOnSuccess;
        private resultChangePasswordSuccess;
        private _userLoggedOnHandler;
        private _userLoggedOffHandler;
        updateUserStateList(): Promise<void>;
        getUserGroupsAsync(): Promise<VisiWin.System.UserManagement.IUserGroup[]>;
        getUsersAsync(): Promise<VisiWin.System.UserManagement.IUser[]>;
        logonUserAsync(user?: string, password?: string, code?: string, initialLogon?: boolean): Promise<any>;
        verifyUserAsync(user: string, password: string, code?: string): Promise<any>;
        changePasswordAsync(user: string, oldPassword: string, newPassword1: string, newPassword2: string): Promise<{
            result: UserManagement.InteractivEvents;
            succeed: boolean;
            reason: any;
            errorText: any;
            isUserNameError: boolean;
            isPasswordError: boolean;
            isNewPasswordError: boolean;
            isRepeatPasswordError: boolean;
        } | {
            result: System.UserManagement.ChangePasswordSuccess;
            succeed: boolean;
            reason: any;
            errorText: any;
            isUserNameError: boolean;
            isPasswordError: boolean;
            isNewPasswordError: boolean;
            isRepeatPasswordError: boolean;
        }>;
        changePasswordCurrentUserAsync(oldPassword: string, newPassword1: string, newPassword2: string, user?: string): Promise<any>;
        changeUserAsync(): Promise<any>;
        addUserAsync(): Promise<any>;
        removeUserAsync(): Promise<any>;
        setSelectedUserIndex(index: number): Promise<void>;
        setRemoveUserIndex(index: number): Promise<void>;
        resetCurrentUser(): void;
        resetLogon(): void;
        resetChangePassword(): void;
        resetAddUser(): void;
        resetChangeUser(): void;
        resetRemoveUser(): Promise<void>;
        resetUserList(): void;
        resetUserGroupList(): void;
        reset(): Promise<void>;
        dispose(): void;
        /**
        *  Logs a user on.
        *  @param {string} name the login name
        *  @param {string} password the login password
        */
        logOnAsync(name?: string, password?: string, code?: string): Promise<VisiWin.System.UserManagement.LogOnSuccess>;
        /**
        * Returns a class for functional linking of a control with the user administration
        */
        getAuthorization(rightName: string): VisiWin.System.UserManagement.IAuthorization;
        getUsersAndGroupsAsync(): Promise<VisiWin.System.UserManagement.IUserAndGroups>;
    }
}
declare module VisiWin.AppServices.Impl {
    class DataTemplateService extends VisiWin.AppServices.Impl.ServiceBase {
        static namespace: string;
        static serviceName: string;
        static requireServices: any[];
        mappingData: any;
        triggerData: any;
        constructor();
        init(): void;
        loadDataTemplate(templateName: string): Promise<boolean>;
        getDataTemplate(context: any, templateName: string, eventName: string): Promise<void>;
        registerDataTemplate(name: string, element: HTMLElement, fragment: string): void;
        ready(): Promise<void>;
        unload(): void;
        dispose(): void;
    }
}
declare namespace VisiWin.AppServices.Impl {
    function registerAlertDialogDesignerObservable(dataService: VisiWin.AppServices.IDataService): void;
}
declare module VisiWin.AppServices.Impl {
    function registerTimerDesignObservable(dataService: VisiWin.AppServices.IDataService): void;
}
declare namespace VisiWin.AppServices.Impl.DataServiceHelper {
    function _getBindings(bindings: any): VisiWin.IBindingDescription[];
}
declare namespace VisiWin.AppServices.Impl.DataServiceHelper {
    function _registerDesignTimeConverter(name: string, description: VisiWin.IConverterDescription, converters: any): void;
    function _getConverters(converters: any): VisiWin.IConverterDescription[];
    function _getConverterByName(name: string, converters: any): VisiWin.IConverterDescription;
    function _loadAppSettingsConverters(): void;
}
declare namespace VisiWin.AppServices.Impl.DataServiceHelper {
    function _getDataSources(designTimeDataSources: any): string[];
    function _getDataSourcesDescription(designTimeDataSources: any): any[];
    function _getDataSourceDescriptionByName(name: string, designTimeDataSources: any): any[];
}
declare namespace VisiWin.AppServices.Impl.DataServiceHelper {
    function _getObservables(designTimeObservable: any): any[];
    function _getObservableDescriptionByName(name: string, designTimeObservable: any): any[];
    function _getObservablesDescription(designTimeObservable: any): any[];
}
declare module VisiWin.AppServices.Impl {
    interface IStringIndexer<T> {
        [index: string]: T;
    }
    export interface IDataStore<T> {
        Add<T>(id: string, obj: T): void;
        Contains(id: string): boolean;
        DeleteAll(): void;
        Delete(id: string): void;
        GetAll<T>(): T[];
        GetFromKey<T>(id: string): T;
        GetFromKeyValue<T>(propertyName: string, propertyValue: unknown): T;
        GetFromObjectKey<T>(propertyName: string, obj: T): T;
    }
    export class DataStore<T> implements IDataStore<T> {
        private dictionary;
        constructor();
        Add<T>(id: string, obj: T): void;
        Contains(id: string): boolean;
        GetFromKey<T>(id: string): T;
        GetFromKeyValue<T>(propertyName: string, propertyValue: unknown): T;
        GetFromObjectKey<T extends IStringIndexer<any>>(propertyName: string, obj: T): T;
        GetAll<T>(): T[];
        Delete(id: string): void;
        DeleteAll(): void;
    }
    export {};
}
declare module VisiWin.AppServices.Impl {
    interface IConverter {
        [idx: string]: any;
    }
    interface ITriggerData {
        [idx: string]: any;
    }
    interface IBindingObservables {
        [idx: string]: typeof VisiWin.Binding.as;
    }
    interface IDataSourcesDataServices {
        [idx: string]: typeof VisiWin.Binding.List;
    }
    interface IDataServiceStore {
        converters: IDataStore<IConverter>;
        triggerData: IDataStore<ITriggerData>;
        observables: IDataStore<IBindingObservables>;
        dataSources: IDataStore<IDataSourcesDataServices>;
        Dispose(): void;
    }
    class DataServiceStore implements IDataServiceStore {
        converters: VisiWin.AppServices.Impl.IDataStore<IConverter>;
        triggerData: VisiWin.AppServices.Impl.IDataStore<ITriggerData>;
        observables: VisiWin.AppServices.Impl.IDataStore<IBindingObservables>;
        dataSources: VisiWin.AppServices.Impl.IDataStore<IDataSourcesDataServices>;
        private _dataService;
        private _session;
        constructor(dataService: VisiWin.AppServices.IDataService);
        Dispose(): void;
    }
}
declare namespace VisiWin.DataServices {
    enum AccessTypes {
        "ro" = "ro",
        "rw" = "rw"
    }
    enum TypeStrings {
        "string" = "string",
        "boolean" = "boolean",
        "number" = "number",
        "enum" = "enum"
    }
    enum PropertyTypes {
        "member" = "member",
        "event" = "event"
    }
    enum BindingType {
        "observable" = "observable",
        "dataSource" = "dataSource",
        "converter" = "converter"
    }
    enum Categories {
        "UserManagement" = "UserManagement",
        "TouchKeyboard" = "TouchKeyboard",
        "Languages" = "Languages",
        "TrendChart" = "TrendChart",
        "Alarms" = "Alarms",
        "Recipes" = "Recipes",
        "Logging" = "Logging",
        "DataAccess" = "DataAccess",
        "Language" = "Language",
        "Dialogs" = "Dialogs",
        "HMI" = "HMI",
        "ViewModels" = "ViewModels"
    }
}
declare namespace VisiWin.DataServices {
    interface IShortDescription {
        name: string;
        displayName: string;
        category: string;
    }
    class BindingHelper<T> implements VisiWin.DataServices.IObservable<T> {
        id: string;
        private bindingDescription;
        shortDescription: VisiWin.DataServices.IShortDescription;
        designTimeDescription: VisiWin.DataServices.IDataSourceDescription<T>;
        private dataServiceStore;
        object: VisiWin.Binding.Ias | VisiWin.Binding.IList<T> | any;
        isInDesignMode: boolean;
        isInTemplateView: boolean;
        targetElement: VWElement;
        observable: T;
        private _addToStore;
        private _designTimeBinding;
        constructor(designTimeDescription: VisiWin.DataServices.IDataSourceDescription<T>, object: T, targetElement: VWElement);
        private _init;
        private _makeId;
        private _setBindingDesc;
        private _setShortDesc;
        private _validateBindingType;
        private _setBindingStore;
        private _createObservableFromBindingType;
        createDesignTimeDescription(): void;
        getDesignTimeBinding(): any;
        updateBinding(obj: T): Promise<any>;
        processAll(targetElement: VWElement): Promise<void>;
        delete(): void;
        addToServiceStore(self: any): void;
        dispose(): void;
    }
}
declare namespace VisiWin.DataServices {
    interface IListBinding {
        dataSource: string;
        dataTemplate?: string;
        selectedItem?: any;
        selectedIndex?: number;
        selectedValue?: any;
        selectedIndexChanged?(): void;
        listInitialized?(): void;
    }
    interface IRepeaterEvents {
        itemsLoaded?(): void;
        itemChanging?(): void;
        itemChanged?(): void;
        itemInserting?(): void;
        itemInserted?(): void;
        itemMoving?(): void;
        itemMoved?(): void;
        itemRemoving?(): void;
        itemRemoved?(): void;
        itemsReloading?(): void;
        itemsReloaded?(): void;
        templateReady?(): void;
    }
    interface IControlBaseEvents {
        notifyPropertyChanged?(): void;
        attached?(): void;
        detached?(): void;
        initialized?(): void;
    }
}
declare namespace VisiWin.DataServices {
    interface IDataContextIdValidatorResult {
        isViewModelObjectName: boolean;
        isFunctionConstructorName: boolean;
        isName: boolean;
    }
    function _validateDataContextId(dataContext: string): VisiWin.DataServices.IDataContextIdValidatorResult;
    function createObservableFromObject(obj: any): typeof VisiWin.Binding.as;
    function createObservableListFromObjectArray<T>(obj: T): WinJS.Binding.List<T>;
    function _validateDataSourceDescription<T>(dataSourceDescription: IDataSourceDescription<T>): IDataSourceDescription<T>;
    function _isInDataTemplateView(element: HTMLElement | null): boolean;
}
declare namespace VisiWin.DataServices {
    interface IBindingDescription {
        name?: string;
        displayName?: string;
        category?: keyof typeof VisiWin.DataServices.Categories | string;
        bindingType?: keyof typeof VisiWin.DataServices.BindingType;
    }
    interface IDataSourceDescriptionMember<T> {
        name?: string;
        propertyType?: keyof typeof VisiWin.DataServices.PropertyTypes;
        type?: keyof typeof VisiWin.DataServices.TypeStrings;
        access?: keyof typeof VisiWin.DataServices.AccessTypes;
        displayName?: string;
        sampleArray?: T[];
        sampleData?: T | any;
        callBack?: string;
    }
    interface IDataSourceDescription<T> extends VisiWin.DataServices.IBindingDescription {
        dataSourceDescription?: {
            [idx: string]: VisiWin.DataServices.IDataSourceDescriptionMember<T>;
        };
    }
    interface IObservable<T> {
        designTimeDescription: VisiWin.DataServices.IDataSourceDescription<T>;
        id: string;
        object: T;
        observable: T;
        getDesignTimeBinding(): any;
        updateBinding(obj: T): Promise<any>;
        processAll(targetElement: VWElement): Promise<void>;
        isInTemplateView?: boolean;
    }
    interface IDataSource<T> {
        designTimeDescription: VisiWin.DataServices.IDataSourceDescription<T>;
        id: string;
        object: T;
        observable: T;
        getDesignTimeBinding(): any;
    }
}
declare namespace VisiWin.ViewModels {
    type IIdentifierKey = string;
    interface IViewModelMediator {
        broadcastViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage, viewModel: VisiWin.ViewModels.IViewModelMediator): void;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): void;
    }
    interface IMediatorBase {
        viewModels: Set<VisiWin.ViewModels.IViewModelMediator>;
        mediatorName: string;
        viewModelMediatorName: VisiWin.ViewModels.IIdentifierKey;
        addViewModel(instance: VisiWin.ViewModels.IViewModelMediator): void;
        broadcastViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage, viewModel: VisiWin.ViewModels.IViewModelMediator): void;
        receivingViewModelMessage?(msg: VisiWin.ViewModels.Message.IMessage): void;
    }
}
declare namespace VisiWin.ViewModels {
    interface IViewModelBase {
        targetElement: VWElement;
        viewModelId: string;
        isTargetElementAttached: boolean;
        attached(arg: unknown): void;
        detached(arg: unknown): void;
        initialized(arg: unknown): void;
        notifyPropertyChanged(arg: unknown): void;
        dispose(): void;
    }
    interface IViewModel {
        mainMediator: VisiWin.ViewModels.IMediatorBase;
        configParameters: unknown;
        bindingHelper: VisiWin.DataServices.BindingHelper<any>;
    }
    interface IViewModelParameters {
        viewModel: string;
        viewModelParameters: any;
        viewModelMediator: string;
    }
}
declare namespace VisiWin.ViewModels {
    class MediatorBase implements VisiWin.ViewModels.IMediatorBase {
        viewModels: Set<VisiWin.ViewModels.IViewModelMediator>;
        mediatorName: string;
        viewModelMediatorName: VisiWin.ViewModels.IIdentifierKey;
        constructor(viewModelMediator: VisiWin.ViewModels.IIdentifierKey);
        addViewModel(instance: VisiWin.ViewModels.IViewModelMediator): void;
        broadcastViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage, originator: VisiWin.ViewModels.IViewModelMediator): void;
    }
}
declare namespace VisiWin.ViewModels {
    function _getOrCreateMediator(viewModelMediator: VisiWin.ViewModels.IIdentifierKey): /*VisiWin.ViewModels.MediatorBase*/ any | null;
    function getOrCreateViewModel(dataContext: string, element: VWElement, jsonParams: Record<string, any>): VisiWin.ViewModels.ViewModelBase | null;
}
declare namespace VisiWin.ViewModels.Message {
    interface IMessage {
        properties: VisiWin.Internal.System.Collections.IDictionary;
    }
    class Message implements VisiWin.ViewModels.Message.IMessage {
        properties: VisiWin.Internal.System.Collections.IDictionary;
        constructor();
    }
}
declare namespace VisiWin.ViewModels {
    class ViewModelBase implements VisiWin.ViewModels.IViewModelBase {
        targetElement: VWElement;
        viewModelId: string;
        isTargetElementAttached: boolean;
        constructor(target: VWElement);
        private _initViewModel;
        attached(arg: unknown): void;
        detached(arg: unknown): void;
        initialized(arg: unknown): void;
        notifyPropertyChanged(arg: unknown): void;
        dispose(): void;
        private _addEventListener;
        private _removeEventListener;
    }
    function dispose(obj: any): void;
}
declare namespace VisiWin.ViewModels {
    class ViewModel<TObject, TMediator extends VisiWin.ViewModels.IMediatorBase> extends VisiWin.ViewModels.ViewModelBase implements VisiWin.ViewModels.IViewModelMediator {
        mainMediatorName: string;
        mainMediator: TMediator;
        configParameters: VisiWin.ViewModels.IViewModelParameters;
        constructor(target: VWElement, jsonParams?: VisiWin.ViewModels.IViewModelParameters, mediatorName?: string);
        initMediators(obj?: TObject, viewModel?: VisiWin.ViewModels.IViewModelMediator): Promise<void>;
        broadcastViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage, viewModel: VisiWin.ViewModels.IViewModelMediator): void;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): void;
    }
}
declare module VisiWin.AppServices.Impl {
    class ViewModelService extends VisiWin.AppServices.Impl.ServiceBase {
        static namespace: string;
        static serviceName: string;
        static requireServices: any[];
        private viewModelStore;
        private mediatorStore;
        constructor();
        tryCreateViewModel(element: VWElement, dataContext: string): any;
        private getViewModelParams;
        addViewModel(id: string, viewModel: any): void;
        getViewModel(id: string): VisiWin.ViewModels.IViewModel | null;
        addMediator(viewModelMediator: VisiWin.ViewModels.IIdentifierKey, mediator: any): void;
        getMediator(viewModelMediator: VisiWin.ViewModels.IIdentifierKey): any | null;
        init(): void;
        ready(): Promise<void>;
        unload(): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IBaseViewModel {
        checkForMessageUpdates(): void;
        classInitialized: boolean;
        ClassName: string;
        currentClass: VisiWin.System.Recipe.IRecipeClass;
        updateCurrentClass(name?: string): void;
        recipeService: VisiWin.AppServices.Impl.RecipeService;
    }
    abstract class BaseClassViewModel<TObject> extends VisiWin.ViewModels.ViewModel<TObject, VisiWin.ViewModels.Recipe.IRecipelMediator> implements IBaseViewModel {
        viewModelId: string;
        classInitialized: boolean;
        recipeService: VisiWin.AppServices.Impl.RecipeService;
        private _isClassUpdating;
        private _ClassName;
        get ClassName(): string;
        set ClassName(value: string);
        protected abstract currentClassNameChanged(name: string): void;
        private _currentClass;
        get currentClass(): VisiWin.System.Recipe.IRecipeClass;
        set currentClass(value: VisiWin.System.Recipe.IRecipeClass);
        protected abstract currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters, mediator?: string);
        private _initBase;
        updateCurrentClass(name?: string): Promise<void>;
        checkForMessageUpdates(): Promise<void>;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IBaseFileViewModel {
        FileName: string;
    }
    abstract class BaseFileViewModel<TObject> extends VisiWin.ViewModels.Recipe.BaseClassViewModel<TObject> implements IBaseFileViewModel {
        viewModelId: string;
        private _FileName;
        get FileName(): string;
        set FileName(value: string);
        protected abstract currentFileNameChanged(name: string): void;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _initFile;
        checkForMessageUpdates(): Promise<void>;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        protected currentClassNameChanged(name: string): void;
        protected currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IRecipelMediator extends VisiWin.ViewModels.IMediatorBase {
        broadcastViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage, viewModel: VisiWin.ViewModels.IViewModelMediator): void;
        checkNewMessage<T extends keyof MessageTypeMap>(key: T): ObjectType<T>;
        createNewMessage<T extends keyof MessageTypeMap>(viewModel: VisiWin.ViewModels.IViewModelMediator, msgName: T, payload: ObjectType<T>): any;
    }
    interface IListBindingDescription {
        dataSource: string;
        dataTemplate?: string;
        selectedIndex?: number;
        selectedValue?: any;
        selectedItemValue?: any;
        selectedIndexChanged?(): void;
        listInitialized?(): void;
    }
    class MainMediator extends VisiWin.ViewModels.MediatorBase implements VisiWin.ViewModels.Recipe.IRecipelMediator {
        private messageStack;
        constructor(viewModelMediator: VisiWin.ViewModels.IIdentifierKey);
        broadcastViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage, originator: VisiWin.ViewModels.IViewModelMediator): void;
        checkNewMessage<T extends keyof MessageTypeMap>(key: T): ObjectType<T>;
        createNewMessage<T extends keyof MessageTypeMap>(viewModel: VisiWin.ViewModels.IViewModelMediator, msgName: T, payload: ObjectType<T>): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    const enum MessageID {
        CurrentRecipeFileName = "CurrentRecipeFileName",
        CurrentRecipeClassName = "CurrentRecipeClassName",
        CurrentRecipeClass = "CurrentRecipeClass",
        NewFileName = "NewFileName",
        FileDeleted = "FileDeleted",
        RecipeFileNames = "RecipeFileNames",
        RecipeClassNames = "RecipeClassNames",
        RecipeFile = "RecipeFile",
        RecipeFilesInfo = "RecipeFilesInfo",
        RecipeClassLoaded = "RecipeClassLoaded",
        RecipeFilesChangedEventArgs = "RecipeFilesChangedEventArgs",
        RecipeBufferChangedEventArgs = "RecipeBufferChangedEventArgs",
        RecipeWrittenToProcessEventArgs = "RecipeWrittenToProcessEventArgs",
        RecipeLockStateChangedEventArgs = "RecipeLockStateChangedEventArgs"
    }
    interface MessageTypeMap {
        [MessageID.CurrentRecipeFileName]: string;
        [MessageID.CurrentRecipeClassName]: string;
        [MessageID.NewFileName]: string;
        [MessageID.FileDeleted]: string;
        [MessageID.CurrentRecipeClass]: VisiWin.System.Recipe.IRecipeClass;
        [MessageID.RecipeFileNames]: VisiWin.ViewModels.Recipe.IRecipeFileName[];
        [MessageID.RecipeClassNames]: VisiWin.ViewModels.Recipe.IRecipeClassNames[];
        [MessageID.RecipeFile]: VisiWin.System.Recipe.IRecipeFile;
        [MessageID.RecipeFilesInfo]: IFileMemberInfo[];
        [MessageID.RecipeClassLoaded]: VisiWin.System.Recipe.IRecipeClass;
        [MessageID.RecipeFilesChangedEventArgs]: VisiWin.System.Recipe.IRecipeFilesChangedEventArgs;
        [MessageID.RecipeBufferChangedEventArgs]: VisiWin.System.Recipe.IRecipeBufferChangedEventArgs;
        [MessageID.RecipeWrittenToProcessEventArgs]: VisiWin.System.Recipe.IRecipeWrittenToProcessEventArgs;
        [MessageID.RecipeLockStateChangedEventArgs]: VisiWin.System.Recipe.IRecipeLockStateChangedEventArgs;
    }
    type ObjectType<T> = T extends MessageID.CurrentRecipeFileName ? string : T extends MessageID.CurrentRecipeClassName ? string : T extends MessageID.NewFileName ? string : T extends MessageID.FileDeleted ? string : T extends MessageID.CurrentRecipeClass ? VisiWin.System.Recipe.IRecipeClass : T extends MessageID.RecipeFileNames ? VisiWin.ViewModels.Recipe.IRecipeFileName[] : T extends MessageID.RecipeClassNames ? VisiWin.ViewModels.Recipe.IRecipeClassNames[] : T extends MessageID.RecipeFile ? VisiWin.System.Recipe.IRecipeFile : T extends MessageID.RecipeFilesInfo ? IFileMemberInfo[] : T extends MessageID.RecipeClassLoaded ? VisiWin.System.Recipe.IRecipeClass : T extends MessageID.RecipeFilesChangedEventArgs ? VisiWin.System.Recipe.IRecipeFilesChangedEventArgs : T extends MessageID.RecipeBufferChangedEventArgs ? VisiWin.System.Recipe.IRecipeBufferChangedEventArgs : T extends MessageID.RecipeWrittenToProcessEventArgs ? VisiWin.System.Recipe.IRecipeWrittenToProcessEventArgs : T extends MessageID.RecipeLockStateChangedEventArgs ? VisiWin.System.Recipe.IRecipeLockStateChangedEventArgs : null;
}
declare namespace VisiWin.ViewModels.Helper {
    function createViewModelMessage(msgName: string, payload: any): VisiWin.ViewModels.Message.IMessage;
    const arraysEqual: (a1: any[], a2: any[]) => boolean;
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IRecipeClassNames {
        ClassName: string;
        LocalizableText: string;
    }
    class ClassNames extends VisiWin.ViewModels.Recipe.BaseClassViewModel<IRecipeClassNames[]> {
        viewModelId: string;
        private objList;
        private objectHelper;
        private listHelper;
        private listBinding;
        private _objListInitialized;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _init;
        private _getClassNames;
        currentClassNameChanged(name: string): void;
        currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        private _registerObservable;
        private _updateBinding;
        private _updateSelectedIndex;
        itemsLoaded: any;
        itemInserted: any;
        indexChanged: any;
        checkForMessageUpdates(): Promise<void>;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IClassBindingDescription {
        dataSource?: string;
        dataTemplate?: string;
        selectedIndex?: number;
        selectedValue?: any;
        selectedItemValue?: any;
        selectedIndexChanged?(): void;
        listInitialized?(): void;
        readProcessToBuffer?(): void;
        setDefaultValuesToBuffer?(): void;
        saveBufferToFileAsync?(): void;
    }
    interface IViewModelRecipeClass {
        displayName?: string;
        category?: VisiWin.DataServices.Categories;
        recipeClass: VisiWin.System.Recipe.IRecipeClass;
        startEdit?: typeof WinJS.UI.eventHandler;
        stopEdit?: typeof WinJS.UI.eventHandler;
        lockRecipe?: typeof WinJS.UI.eventHandler;
        unLockRecipe?: typeof WinJS.UI.eventHandler;
        toggleEdit?: typeof WinJS.UI.eventHandler;
        readProcessToBuffer?: typeof WinJS.UI.eventHandler;
        setDefaultValuesToBuffer?: typeof WinJS.UI.eventHandler;
        saveBufferToFileAsync?: typeof WinJS.UI.eventHandler;
        ClassName?: string;
        FileName?: string;
        isEditing?: boolean;
        isLocked?: boolean;
        hasChangesForProcess?: boolean;
        hasChangesForFile?: boolean;
        canCreate: boolean;
        canDelete: boolean;
        canLoad: boolean;
        canEdit: boolean;
        canRead: boolean;
        canReset: boolean;
        canSave: boolean;
        canWrite: boolean;
        canSend: boolean;
    }
    interface IRecipeDataItem {
        RecipeClass: VisiWin.System.Recipe.IRecipeClass | null;
        OldValue: VisiWin.System.DataAccess.VariantType | null;
        Value: VisiWin.System.DataAccess.VariantType | null;
        Quality: VisiWin.System.DataAccess.IQuality | null;
        Timestamp: Date | null;
    }
    class RecipeClass extends VisiWin.ViewModels.Recipe.BaseFileViewModel<VisiWin.System.Recipe.IRecipeClass> {
        viewModelId: string;
        private object;
        private listHelper;
        private objectHelper;
        private listBinding;
        private _initalized;
        private _varArrayMemberChangedHandler;
        private _varArray;
        private _hasValidFile;
        get hasValidFile(): boolean;
        set hasValidFile(value: boolean);
        private _hasValidClass;
        get hasValidClass(): boolean;
        set hasValidClass(value: boolean);
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _init;
        private _initClass;
        private _createClassShape;
        protected currentClassNameChanged(name: string): void;
        protected currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        protected currentFileNameChanged(name: string): void;
        private _registerObservable;
        private _updateBinding;
        private startRecipeClassEdit;
        private stopRecipeClassEdit;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        checkForMessageUpdates(): Promise<void>;
        initialized(arg: unknown): Promise<void>;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
        private _addVariableHandler;
        private _varArrayMemberChanged;
        private _resetVarArray;
        private _addHandler;
        private _removeHandler;
        private _bufferChanged;
        private _fileChanged;
        private _writtenToProcess;
        private _lockStateChanged;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IRecipeDeleteFile {
        ClassName: string;
        FileName: string;
        Delete?(): void;
    }
    class DeleteFile extends VisiWin.ViewModels.Recipe.BaseFileViewModel<IRecipeDeleteFile> {
        viewModelId: string;
        private object;
        private objectHelper;
        private objectBinding;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _init;
        protected currentClassNameChanged(name: string): void;
        protected currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        protected currentFileNameChanged(name: string): void;
        private deleteClicked;
        private _registerObservable;
        private _updateBinding;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        checkForMessageUpdates(): Promise<void>;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IFileMemberInfo {
        Comment: string;
        DefaultValue: string;
        LocalizableText: string;
        SortIndex: number;
        VariableFullName: string;
        LocalizableVariableText: string;
        Value: any;
        MinValue: any;
        MaxValue: any;
        UnitText: string | undefined;
        ErrorCode: VisiWin.System.Recipe.RecipeMemberErrorCode | undefined;
    }
    interface IListEditDescription {
        dataSource: string;
        dataTemplate?: string;
        selectedIndex?: number;
        selectedValue?: any;
        selectedItemValue?: any;
        selectedIndexChanged?(): void;
        listInitialized?(): void;
        itemInserted?(): void;
    }
    class Variables extends VisiWin.ViewModels.Recipe.BaseFileViewModel<IFileMemberInfo[]> {
        viewModelId: string;
        private objList;
        private objectHelper;
        private listHelper;
        private listBinding;
        private _objListInitialized;
        private _isUpdating;
        private _sortOrder;
        private _varArray;
        private _boudUnitHandler;
        private _unitChanged;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _init;
        protected currentClassNameChanged(name: string): Promise<void>;
        protected currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): Promise<void>;
        protected currentFileNameChanged(name: string): Promise<void>;
        private _registerObservable;
        private _updateBinding;
        listInitialized: any;
        itemInserted: any;
        indexChanged: any;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        checkForMessageUpdates(): Promise<void>;
        private _updateList;
        private _cleanUpVariableArray;
        private _getFileValues;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    class Files extends VisiWin.ViewModels.Recipe.BaseFileViewModel<VisiWin.System.Recipe.IRecipeFile[]> {
        viewModelId: string;
        private objList;
        private objectHelper;
        private listHelper;
        private listBinding;
        private _objListInitialized;
        private stateValid;
        private _isUpdating;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _init;
        private _validateState;
        private _initRecipeFiles;
        private _createFileShape;
        protected currentClassNameChanged(name: string): void;
        protected currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        protected currentFileNameChanged(name: string): void;
        private _registerObservable;
        private _updateBinding;
        private _updateSelectedIndex;
        itemInserted: any;
        indexChanged: any;
        checkForMessageUpdates(): Promise<void>;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IRecipeFileName {
        FileName: string;
    }
    class FileNames extends VisiWin.ViewModels.Recipe.BaseFileViewModel<IRecipeFileName[]> {
        viewModelId: string;
        private objList;
        private objectHelper;
        private listHelper;
        private listBinding;
        private _isUpdating;
        private _objListInitialized;
        private stateValid;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _init;
        private _getFileNames;
        private _validateState;
        protected currentClassNameChanged(name: string): void;
        protected currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        protected currentFileNameChanged(name: string): void;
        private _registerObservable;
        private _updateBinding;
        private _updateSelectedIndex;
        private myItemsLoaded;
        itemsLoaded: any;
        itemInserted: any;
        indexChanged: any;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        checkForMessageUpdates(): Promise<void>;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IRecipeNewFile {
        ClassName: string;
        NewFileName: string;
        Description: string;
        Save?(): void;
        UseDefaultValues: boolean;
        UseProcessValues: boolean;
    }
    class NewFile extends VisiWin.ViewModels.Recipe.BaseFileViewModel<IRecipeNewFile> {
        viewModelId: string;
        private object;
        private objectHelper;
        private objectBinding;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _init;
        protected currentClassNameChanged(name: string): void;
        protected currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        protected currentFileNameChanged(name: string): void;
        private _registerObservable;
        private _updateBinding;
        private saveClicked;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        checkForMessageUpdates(): Promise<void>;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IRecipeSaveAs {
        ClassName: string;
        FileName: string;
        NewFileName: string;
        NewDescription: string;
        Save?(): void;
        CurrentDescription: string;
    }
    class SaveFileAs extends VisiWin.ViewModels.Recipe.BaseFileViewModel<IRecipeSaveAs> {
        viewModelId: string;
        private object;
        private objectHelper;
        private objectBinding;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _initObject;
        protected currentClassNameChanged(name: string): void;
        protected currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        protected currentFileNameChanged(name: string): void;
        private _registerObservable;
        private _updateBinding;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        checkForMessageUpdates(): Promise<void>;
        private saveClicked;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IRecipeWriteFileToBuffer {
        ClassName: string;
        FileName: string;
        WriteBufferToProcess?(): void;
    }
    class WriteBufferToProcess extends VisiWin.ViewModels.Recipe.BaseFileViewModel<IRecipeWriteFileToBuffer> {
        viewModelId: string;
        static mediatorName: string;
        private object;
        private objectHelper;
        private objectBinding;
        private _isSending;
        private dialog;
        private spinner;
        protected currentClassNameChanged(name: string): void;
        protected currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        protected currentFileNameChanged(name: string): void;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _init;
        private writeBufferClicked;
        private getDialogControl;
        private _registerObservable;
        private _updateBinding;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        checkForMessageUpdates(): Promise<void>;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.ViewModels.Recipe {
    interface IRecipeLoadFileToProcess {
        ClassName: string;
        FileName: string;
        LoadFileToProcess?(): void;
    }
    class LoadFileToProcess extends VisiWin.ViewModels.Recipe.BaseFileViewModel<IRecipeLoadFileToProcess> {
        viewModelId: string;
        static mediatorName: string;
        private object;
        private objectHelper;
        private objectBinding;
        private _isSending;
        private dialog;
        private spinner;
        protected currentClassNameChanged(name: string): void;
        protected currentClassChanged(value: VisiWin.System.Recipe.IRecipeClass): void;
        protected currentFileNameChanged(name: string): void;
        constructor(target: VWElement, jsonParams: VisiWin.ViewModels.IViewModelParameters);
        private _init;
        private writeBufferClicked;
        private getDialogControl;
        private _registerObservable;
        private _updateBinding;
        receivingViewModelMessage(msg: VisiWin.ViewModels.Message.IMessage): Promise<void>;
        checkForMessageUpdates(): Promise<void>;
        attached(arg: unknown): Promise<void>;
        detached(arg: unknown): void;
        dispose(): void;
    }
}
declare namespace VisiWin.Triggers.Class {
    /** @ignore */
    function processMetadata(thisClass: any, metadata: VisiWin.Triggers.IPropertyList | VisiWin.Actions.IPropertyList, baseClass?: any): void;
    function processActionMetadata(thisClass: Record<string, any>, metadata: VisiWin.Triggers.PropertyList, baseClass?: typeof VisiWin.Actions.ActionBase): void;
    function processTriggerMetadata(thisClass: Record<string, any>, metadata: VisiWin.Triggers.PropertyList, baseClass?: typeof VisiWin.Triggers.TriggerBase): void;
}
declare namespace VisiWin.Triggers.Util {
    /** @ignore */
    interface IVisiWinRuntimeType {
        variableType: string;
        typeCode: VisiWin.System.DataAccess.TypeCode;
        jsType: string;
        typeMin: number;
        typeMax: number;
        negFlag: boolean;
        floatFlag: boolean;
        eFlag: boolean;
    }
    /** @ignore */
    function parseJson(configBlock: string, instance?: VisiWin.Triggers.TriggerBase): any;
    /** @ignore */
    function getVWType(t: VisiWin.System.DataAccess.TypeCode): IVisiWinRuntimeType;
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    interface IActionBase {
        /**
        * @description The name of the action
        * @member {@link VisiWin.UI.JSPrimitives.String|string} actionName
        * @static
        */
        actionName: string;
        /**
        * @description Gets or sets the target property for AddClassAction.
        * @member {@link VisiWin.UI.JSPrimitives.String|string} targetSelector
        */
        targetSelector?: string;
        /**
        * @description Whether the conditions been successful.
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } conditionResult
        */
        conditionResult?: boolean;
        /**
        * convertToType
         * @param value value to be converted
         * @param targetType Type to which the value is converted: number, string, boolean
         */
        convertToType?(value: VisiWin.Actions.ExecuteValue, targetType: string): string | boolean | number | null;
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<ExecuteResut>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init?(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue?(element: VWElement, triggerData: ITriggerData): ExecuteValue;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /** @ignore */
        dispose(): void;
        /** @ignore */ _executeAllAsync(value: VisiWin.Actions.ExecuteValue, targetElements: VWElement[], triggerData: VisiWin.Actions.ITriggerData): Promise<null>;
        /** @ignore */ _getInitialValueInit(targetElements: VWElement[], triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
        /** @ignore */
        _disposeActionBase(): void;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
      * @class ActionBase
      * @description Base Class for all VisiWin actions.
      * @memberof VisiWin.Actions
      */
    class ActionBase implements IActionBase {
        /**
        * @description The name of the action
        * @member {{@link VisiWin.UI.JSPrimitives.String|string}} actionName
        */
        static actionName: string;
        actionName: string;
        static actionBasePropertyList: IPropertyList;
        /** @ignore */
        /**
        * @description Gets or sets the target property for AddClassAction.
        * @member {{@link VisiWin.UI.JSPrimitives.String|string}} targetSelector
        */
        targetSelector: string;
        /**
        * @description Whether the conditions been successful.
        * @member {{@link VisiWin.UI.JSPrimitives.Boolean|boolean } }conditionResult
        */
        conditionResult: boolean;
        private operand1;
        private operator;
        private operand2;
        private propertyList;
        private __triggerData;
        private _actionId;
        private _target;
        private _resultId;
        private set resultId(value);
        private get resultId();
        private _resultIdIfTrue;
        private set resultIdIfTrue(value);
        private get resultIdIfTrue();
        private _resultIdIfFalse;
        private set resultIdIfFalse(value);
        private get resultIdIfFalse();
        constructor();
        /**
         * addPropertyList
         * @description Combines property lists from different classes.
         * @param { ActionBase } base
         * @param {IPropertyList} val
         */
        addPropertyList(base: typeof ActionBase, val: IPropertyList): void;
        /**
         * setActionResult
         * @description Sets the result and reason of the action.
         * @description
         * @param { string } reason
         * @param { boolean } result
         */
        setActionResult(result: boolean, reason: string): void;
        /**
         * getData
         * @description Resolves extended keywords(e.g. %value)
         * @param { string } name
         * @param { VisiWin.Actions.ExecuteValue } defaultValue
         */
        getData(name: string, defaultValue?: VisiWin.Actions.ExecuteValue): Promise<ServiceData>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: VisiWin.Actions.ITriggerData): void;
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: VisiWin.Actions.ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        dispose(): void;
        /** @ignore */
        _executeAllAsync(value: VisiWin.Actions.ExecuteValue, targetElements: VWElement[], triggerData: VisiWin.Actions.ITriggerData): Promise<null>;
        /** @ignore */
        _getInitialValueInit(targetElements: VWElement[], triggerData: VisiWin.Actions.ITriggerData): void;
        private getInitialValueAll;
        /**
        * @method getTargetElements
        * @description If there is no targetSelector then round trip targetElements, otherwise querySelectorAll(targetSelector).
        * Custom actions can use this method to modify list of target elements to apply action on.
        * @param {VWElement[]}targetElements  A collection of elements on which this action should be executed.
        */
        private getTargetElements;
        /**
        * @ignore
        * @description Deprecated do not use this! Use executeAllAsync instead.
        */
        private executeAll;
        private _setTriggerData;
        private _checkCondition;
        /** @ignore */
        _disposeActionBase(): void;
    }
}
declare namespace VisiWin.Triggers {
    /**
    * Property generator table
    */
    interface IPropertyList {
        [index: string]: {
            type: DataType;
            elementType?: ElementType;
        };
    }
    /**
    * Type of the property
    */
    type DataType = String | Boolean | Number | Array<any> | any;
    /**
    * Type of the element
    */
    type ElementType = VisiWin.Triggers.TriggerBase | any;
    /**
    * Map of attached elements with element.controlId as keys.
    */
    interface IAttachedElements {
        [index: string]: {
            element: VWElement;
        };
    }
    /**
    * PropertyList
    * @description On start-up VisiWin reads the list of properties from every class and generates the code for the properties automatically.
    * Each entry defines a property in the form <name of property>: { <option>: value, <option>: value, � }
    * @type { IPropertyList }
    */
    type PropertyList = IPropertyList;
    /** @ignore */ interface ITriggerInstances {
        [elementId: string]: TriggerBase[];
    }
    /** @ignore */
    type ExecuteValue = string | boolean | number | any;
    /** @ignore */
    type ExecuteType = any;
    /** @ignore */
    type ExecuteAdapter = any;
    /** @ignore */
    type EventMixinEvent = any;
    /** @ignore */
    type BaseControl = any;
}
/**
* @namespace
* @name VisiWin.Triggers
*/
declare namespace VisiWin.Triggers {
    interface ITriggerBase {
        /**
        * @description The name of the trigger
        * @member {@link VisiWin.UI.JSPrimitives.String|string} triggerName
        * @static
        */
        triggerName: string;
        /**
        * Array of the attached elements
        * @member { VWElement[] } triggerElements
        **/
        triggerElements: VWElement[];
        /**
        * The list of actions to fire when the event is triggered.
        * @member { VisiWin.Actions.IActionBase[[] } triggerElements
        **/
        triggeredActions: VisiWin.Actions.IActionBase[];
        /**
        * @method addPropertyList
        * @description Generates the code for the properties<VisiWin.Triggers.PropertyList>
        * Creates the member propertyList[].
        * msut be called in consturctor
        * @param {typeof TriggerBase} base
        * @param {PropertyList} values
        */
        addPropertyList(base: typeof TriggerBase, values: PropertyList): void;
        /**
        * @method executeActionsAsync
        * @description Executes action for all target elements.
        * @param {ExecuteValue} value
        * @param {HTMLElement[]} targetElements  A collection of elements on which actions should be executed.
        * @param { VisiWin.Actions.ITriggerData} triggerData Optional info provided by triggers.
        */
        executeActionsAsync?(value: ExecuteValue, targetElements: HTMLElement[], triggerData: VisiWin.Actions.ITriggerData): Promise<void>;
        /**
         * @method disposeActions
         * @description  Disposes all triggered actions
         */
        disposeActions(): void;
        /**
        * @method onElementAttached
        * @description Called when an element is attached to a trigger. <br>
        * abstract should be implemented
        * @param {VWElement} element An element which has been attached.
        */
        onElementAttached(element: VWElement): void;
        /**
        * @method onElementDetached
        * @description Called before element is about to be detached from a trigger. <br>
        * abstract should be implemented
        * @param {VWElement} element An element which has been attached.
        */
        onElementDetached(element: VWElement): void;
        /**
        * @method disposeTrigger
        * @description Disposes the trigger. <br>
        * abstract must be implemented
        * @param {VWElement} element The element to dispose trigger from.
        */
        disposeTrigger(element: VWElement): void;
        /** @ignore */ triggerSourcePropertyType?: ExecuteType;
        /** @ignore */ triggerSourcePropertyValue?: ExecuteValue;
        /**
         * @ignore
         * @deprecated Do not use this! Use executeActionsAsync instead.
         */
        executeActions?(value: ExecuteValue, targetElements: HTMLElement[], triggerData: VisiWin.Actions.ITriggerData): Promise<void>;
        /** @ignore */
        sourcePropertyValueName?: string;
        /** @ignore */
        sourcePropertyTypeName?: string;
        /** @ignore */
        sourcePropertyValueAdapter?: ExecuteAdapter;
    }
}
declare namespace VisiWin.Triggers {
    /** @ignore */
    function InititalizeTriggerBase(element: VWElement, triggerAttribute: string | object): TriggerBase[];
    /** @ignore */ function attach(element: VWElement, triggerAttribute: string | object): TriggerBase[];
    /** @ignore */
    function UnintitalizeTriggerBase(currentElement: VWElement): void;
    /** @ignore */ function detach(currentElement: VWElement): void;
    /** @ignore */
    function DisposeTriggerBase(currentElement: VWElement): void;
    /** @ignore */ function dispose(currentElement: VWElement): void;
    /** @ignore */
    function getTriggerInstances(element: VWElement): TriggerBase[];
    /** @ignore */
    function addTriggerInstance(element: VWElement, triggerInstance: TriggerBase): void;
}
/**
* @namespace
* @name VisiWin.Triggers
*/
declare namespace VisiWin.Triggers {
    /**
    * @class TriggerBase
    * @classdesc The base class for all triggers.
    * @memberof VisiWin.Triggers
    */
    class TriggerBase implements ITriggerBase {
        /** @ignore */
        static tiggerBasePropertyList: PropertyList;
        /** @ignore */
        /**
        * @description The name of the trigger
        * @member {@link VisiWin.UI.JSPrimitives.String|string} triggerName
        * @static
        */
        static triggerName: string;
        /** @ignore */
        triggerName: string;
        /**
        * Array of the attached elements
        * @member { VWElement[] } triggerElements
        **/
        triggerElements: VWElement[];
        /**
        * The list of actions to fire when the event is triggered.
        * @member { VisiWin.Actions.IActionBase[[] } triggerElements
        **/
        triggeredActions: VisiWin.Actions.IActionBase[];
        private _attachedElementsMap;
        private _attachedElementsCount;
        propertyList: IPropertyList[];
        /**
        * Initializes a new instance of VisiWin.Triggers.TriggerBase that defines a trigger.
        * @constructor
        * @param { string } configBlock Construct the object properties based on the config block.
        * @param {VWElement} element The element attachment of the trigger.
        **/
        constructor(configBlock?: string, element?: VWElement);
        /**
        * @method addPropertyList
        * @description Generates the code for the properties<VisiWin.Triggers.PropertyList>
        * Creates the member propertyList[].
        * @param {typeof TriggerBase} base
        * @param {PropertyList} values
        */
        addPropertyList(base: typeof TriggerBase, val: PropertyList): void;
        /**
        * @method executeActionsAsync
        * @description Executes action for all target elements.
        * @param {VisiWin.Triggers.ExecuteValue} value
        * @param {HTMLElement[]} targetElements  A collection of elements on which actions should be executed.
        * @param { VisiWin.Actions.ITriggerData} triggerData Optional info provided by triggers.
        */
        executeActionsAsync(value: VisiWin.Triggers.ExecuteValue, targetElements: VWElement[], triggerData: VisiWin.Actions.ITriggerData): Promise<void>;
        /**
         * @method disposeActions
         * @description  Disposes all triggered actions
         */
        disposeActions(): void;
        /**
         * returns collection of target elements to fire actions on.
         * @method getAttachedElements
         * @returns VWElement[]
         */
        getAttachedElements(): VWElement[];
        /**
         * returns the attached elements counter.
         * @method getAttachedElementsCount
         * @returns VWElement[]
         */
        getAttachedElementsCount(): number;
        /**
         * returns the requested element.
         * @method getAttachedElementInfo
         * @param { VWElement } element
         * @returns VWElement
         */
        getAttachedElementInfo(element: VWElement): VWElement | null;
        /**
         * returns the initial value from the action, if implemented.
         * @method getAttachedElementInfo
         * @param { VWElement[] } targetElements
         * @param { VisiWin.Actions.ITriggerData } triggerData
         * @returns  VisiWin.Triggers.ExecuteValue
         */
        getInitialValueActions(targetElements: VWElement[], triggerData: VisiWin.Actions.ITriggerData): VisiWin.Triggers.ExecuteValue | null;
        /**
         * wether the given element is attached
         * @method isElementAttached
         * @param { VWElement[] } element
         * @returns boolean
         */
        isElementAttached(element: VWElement): boolean;
        private adapter;
        private setSourceProperties;
        /** @ignore */ _disposeTriggerBase(element: VWElement): void;
        /** @ignore */ _inititalizeBase(element: VWElement): void;
        /** @ignore */ _unititalizeBase(element: VWElement): void;
        /** @ignore */ executeActions(value: VisiWin.Triggers.ExecuteValue, targetElements: VWElement[], triggerData: VisiWin.Actions.ITriggerData): Promise<void>;
        /** @ignore */ executeDispose(): void;
        /**
        * @method onElementAttached
        * @description Called when an element is attached to a trigger. <br>
        * abstract must be implemented
        * @param {VWElement} element An element which has been attached.
        */
        onElementAttached(element: VWElement): void;
        /**
        * @method onElementDetached
        * @description Called before element is about to be detached from a trigger. <br>
        * abstract must be implemented
        * @param {VWElement} element An element which has been attached.
        */
        onElementDetached(element: VWElement): void;
        /**
        * @method disposeTrigger
        * @description Disposes the trigger. <br>
        * abstract must be implemented
        * @param {VWElement} element The element to dispose trigger from.
        */
        disposeTrigger(element: VWElement): void;
    }
}
/**
* @namespace
* @name VisiWin.Triggers
*/
declare namespace VisiWin.Triggers {
    type SourceInfo = {
        element: VWElement;
        _eventListener?: Function;
    };
    interface ISourceListIndexer {
        [index: string]: VisiWin.Triggers.SourceInfo;
    }
    /**
    * @class SelectorSourcedTrigger
    * @classdesc The base class for all triggers with selectors.
    * @memberof VisiWin.Triggers
    */
    interface ISelectorSourcedTrigger extends ITriggerBase {
        /**
        * The name of the trigger (e.g. pressed, marked)
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } triggerDataName
        */
        triggerDataName: string;
        /**
        * The value of the trigger.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } triggerDataValue
        */
        triggerDataValue: string;
        /**
       * The value of the source property.
       * @member { {@link VisiWin.UI.JSPrimitives.String|string} } triggerSourcePropertyValue
       */
        triggerSourcePropertyValue: string;
        /**
        * Attaches the SelectorSourcedTrigger with the element
        * @method onElementAttached
        * @param { VWElement } element - The VisiWin UI Element
        * The element on which the trigger is attached.
        * If there is no source specified on the trigger, the attached-element is the source of the trigger
        * @override
        */
        onElementAttached(element: VWElement): void;
        /**
        * Detaches the SelectorSourcedTrigger
        * @method onElementDetached
        * @param { VWElement } element - The VisiWin UI Element
        * The element from which trigger has been detached.
        * @override
        */
        onElementDetached(element: VWElement): void;
        /**
        * Called when a source is removed from this trigger.
        * Derived classes can override this method to perform specific tasks.
        * @method onSourceElementRemoved
        * @param { VWElement } element - The VisiWin UI Element
        * The source element.
        * @override
        */
        onSourceElementRemoved(element: VWElement): void;
        /**
        * Called when a new source element is added to this trigger.
        * Derived classes can override this method to perform specific tasks.
        * @method onSourceElementAdded
        * @param { VWElement } element - The VisiWin UI Element
        * The source element.
        * @override
        */
        onSourceElementAdded(element: VWElement): void;
        /**
        * Returns object containing source element related info.
        * Derived classes can use it to store per source element info.
        * @method getSourceElementInfo
        * @param { VWElement } element - The VisiWin UI Element
        * @returns  VisiWin.Triggers.SourceInfo
        * The source element.
        * @override
        */
        getSourceElementInfo(element: VWElement): VisiWin.Triggers.SourceInfo;
        /**
        * Returns collection of source elements.
        * @method getSourceElements
        * @returns  VWElement[]
        * @override
        */
        getSourceElements(): VWElement[];
        /**
        * Returns collection of target elements to fire actions on.
        * If source element is one of the ttached elements then it is the only element to fire actions on.
        * Ontherwise actions should be fired on all attached elements.
        * @method getTargetElementsForEventSourceElement
        * @param { VWElement[] } element - The VisiWin UI Element
        * @returns  VisiWin.Triggers.SourceInfo
        * The source element.
        * @override
        */
        getTargetElementsForEventSourceElement(eventSourceElement: VWElement): VWElement[];
    }
}
/**
* @namespace
* @name VisiWin.Triggers
*/
declare namespace VisiWin.Triggers {
    /**
    * @class SelectorSourcedTrigger
    * @classdesc The base class for all triggers with selectors.
    * @memberof VisiWin.Triggers
    * @extends TriggerBase
    */
    class SelectorSourcedTrigger extends TriggerBase implements ISelectorSourcedTrigger {
        /**
        * The name of the trigger class
        * @static { {@link VisiWin.UI.JSPrimitives.String|string} } triggerName
        */
        static triggerName: string;
        /**
        * Properties generator table
        * @static { VisiWin.Triggers.IPropertyList } selectorSourcedPropertyList
        */
        static selectorSourcedPropertyList: IPropertyList;
        /**
        * The name of the trigger (e.g. pressed, marked)
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } triggerDataName
        */
        triggerDataName: string;
        /**
        * The value of the trigger.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } triggerDataValue
        */
        triggerDataValue: string;
        /**
       * The value of the source property.
       * @member { {@link VisiWin.UI.JSPrimitives.String|string} } triggerSourcePropertyValue
       */
        triggerSourcePropertyValue: string;
        private initialProperty;
        private _sources;
        private _sourceSelector;
        /**
        * Get the sourceSelector
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } sourceSelector
        **/
        get sourceSelector(): string;
        /**
        * Sets the value of the sourceSelector property.
        * This will find all the elements with the specified sourceSelector and apply the Trigger to these elements.
        * @param { string } value The value of the sourceSelector property.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } value
        **/
        set sourceSelector(value: string);
        /**
        * Create a SelectorSourcedTrigger
        * @param { string } configBlock - From data-win-actions='{}'
        * @param { VWElement } element - The VisiWin UI Element
        */
        constructor(configBlock: string, element: VWElement);
        /**
         * Attaches the SelectorSourcedTrigger with the element
         * @method onElementAttached
         * @param { VWElement } element - The VisiWin UI Element
         * The element on which the trigger is attached.
         * If there is no source specified on the trigger, the attached-element is the source of the trigger
         */
        onElementAttached(element: VWElement): void;
        /**
         * Detaches the SelectorSourcedTrigger
         * @method onElementDetached
         * @param { VWElement } element - The VisiWin UI Element
         * The element from which trigger has been detached.
         */
        onElementDetached(element: VWElement): void;
        /**
         * Called when a source is removed from this trigger.
         * Derived classes can override this method to perform specific tasks.
         * @method onSourceElementRemoved
         * @param { VWElement } element - The VisiWin UI Element
         * The source element.
         */
        onSourceElementRemoved(element: VWElement): void;
        /**
        * Called when a new source element is added to this trigger.
        * Derived classes can override this method to perform specific tasks.
        * @method onSourceElementAdded
        * @param { VWElement } element - The VisiWin UI Element
        * The source element.
        */
        onSourceElementAdded(element: VWElement): void;
        /**
        * Returns object containing source element related info.
        * Derived classes can use it to store per source element info.
        * @method getSourceElementInfo
        * @param { VWElement } element - The VisiWin UI Element
        * @returns  VisiWin.Triggers.SourceInfo
        * The source element.
        */
        getSourceElementInfo(element: VWElement): VisiWin.Triggers.SourceInfo;
        /**
        * Returns collection of source elements.
        * @method getSourceElements
        * @returns  VWElement[]
        */
        getSourceElements(): VWElement[];
        /**
        * Returns collection of target elements to fire actions on.
        * If source element is one of the ttached elements then it is the only element to fire actions on.
        * Ontherwise actions should be fired on all attached elements.
        * @method getTargetElementsForEventSourceElement
        * @param { VWElement[] } element - The VisiWin UI Element
        * @returns  VisiWin.Triggers.SourceInfo
        * The source element.
        */
        getTargetElementsForEventSourceElement(element: VWElement): VWElement[];
        private _initialControlEvent;
        private getInitialValueForActions;
        private _initialSources;
        private _refreshSources;
        private _removeAllSources;
        private _addAllSources;
        private _addSource;
        private _getEventItem;
    }
}
/**
* @namespace
* @name VisiWin.Triggers
*/
declare namespace VisiWin.Triggers {
    interface IEventDelay {
        eventName: string;
        currentPage: string;
        event_currentTarget: any;
        event: EventMixinEvent;
        context: any;
    }
    /**
    * @class ControlEventTrigger
    * @classdesc Class for triggers from a control event.
    * @memberof VisiWin.Triggers
    * @extends TriggerBase
    */
    class ControlEventTrigger extends SelectorSourcedTrigger implements ISelectorSourcedTrigger {
        static triggerName: string;
        static propertyList: {
            eventName: {
                type: StringConstructor;
            };
            triggeredActions: {
                type: ArrayConstructor;
                elementType: typeof Actions.ActionBase;
            };
        };
        private _eventDelay;
        private _element;
        /**
        * preloadComprise
        * check if given filename in preload main list
        * @param { string } filename
        * @return compriseFilename:boolean is true when give name is in preload list
        **/
        private preloadComprise;
        private _eventHandler;
        private _eventName;
        /**
        * Get the eventName
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } eventName
        **/
        get eventName(): string;
        /**
        * Set the eventName
        * @param { string } name
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } eventName
        **/
        set eventName(name: string);
        constructor(configBlock: string, element: VWElement);
        /** @inheritdoc */
        onSourceElementAdded(element: VWElement): void;
        /** @inheritdoc */
        onSourceElementRemoved(element: VWElement): void;
        /** @inheritdoc */
        disposeTrigger(element: any): void;
        _executeControlEventActions(sourceElement: VWElement, event: EventMixinEvent, args1?: unknown, args2?: unknown): void;
    }
}
/**
* @namespace
* @name VisiWin.Triggers
*/
declare namespace VisiWin.Triggers {
    /**
    * @class ControlPropertyTrigger
    * @classdesc Class for triggers from a control property.
    * @memberof VisiWin.Triggers
    * @extends TriggerBase
    */
    class ControlPropertyTrigger extends SelectorSourcedTrigger implements ISelectorSourcedTrigger {
        static triggerName: string;
        static propertyList: {
            propertyName: {
                type: StringConstructor;
            };
            triggeredActions: {
                type: ArrayConstructor;
                elementType: typeof Actions.ActionBase;
            };
        };
        private _sourceInfo;
        private _onNotifyPropertyChanged;
        private _propertyName;
        /**
        * Get the propertyName
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } propertyName
        **/
        get propertyName(): string;
        /**
        * Set the propertyName
        * @param { string } name
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } propertyName
        **/
        set propertyName(name: string);
        constructor(configBlock: string, element: VWElement);
        /** @inheritdoc */
        onSourceElementAdded(element: VWElement): void;
        /** @inheritdoc */
        onSourceElementRemoved(element: VWElement): void;
        /** @inheritdoc */
        disposeTrigger(element: any): void;
        private _executeControlPropertyEventActions;
    }
}
/**
* @namespace
* @name VisiWin.Triggers
*/
declare namespace VisiWin.Triggers {
    /**
    * @class VariableTrigger
    * @classdesc Class for variable based triggers.
    * @memberof VisiWin.Triggers
    * @extends TriggerBase
    */
    class VariableTrigger extends SelectorSourcedTrigger implements ISelectorSourcedTrigger {
        static triggerName: string;
        static propertyList: IPropertyList;
        private _vwVariable;
        private _sourceInfo;
        private _boundAttach;
        private _boundDetach;
        private _variableChangeHandler;
        private _variableName;
        /**
        * Get the variableName
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } variableName
        **/
        get variableName(): string;
        /**
        * Set the variableName
        * @param { string } name
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } variableName
        **/
        set variableName(name: string);
        private _variablePropertyName;
        /**
        * Get the variablePropertyName
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } variablePropertyName
        **/
        get variablePropertyName(): string;
        /**
        * Set the variablePropertyName
        * @param { string } paramName
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } name
        **/
        set variablePropertyName(name: string);
        constructor(configBlock: string, element: VWElement);
        /** @inheritdoc */
        onSourceElementAdded(element: VWElement): void;
        /** @inheritdoc */
        onSourceElementRemoved(element: VWElement): void;
        /** @inheritdoc */
        disposeTrigger(element: any): void;
        private _attachVariable;
        private _detachVariable;
        private _executeControlEventActions;
    }
}
declare namespace VisiWin.Triggers {
    /** @ignore */
    class EventTrigger extends SelectorSourcedTrigger implements ISelectorSourcedTrigger {
        /** @ignore */
        static triggerName: string;
        /** @ignore */
        static propertyList: {
            eventName: {
                type: StringConstructor;
            };
            triggeredActions: {
                type: ArrayConstructor;
                elementType: typeof Actions.ActionBase;
            };
        };
        private _eventName;
        /** @ignore */
        get eventName(): string;
        /** @ignore */
        set eventName(value: string);
        /** @ignore */
        constructor(configBlock: string, element: VWElement);
        /** @ignore */
        onSourceElementAdded(element: VWElement): void;
        /** @ignore */
        onSourceElementRemoved(element: VWElement): void;
        private _executeControlEventActions;
        /** @ignore */
        disposeTrigger(element: any): void;
    }
}
declare namespace VisiWin.Triggers {
    /** @ignore */
    class DomEventTrigger extends SelectorSourcedTrigger implements ISelectorSourcedTrigger {
        /** @ignore */
        static triggerName: string;
        /** @ignore */
        static propertyList: {
            actionName: {
                type: StringConstructor;
            };
            triggeredActions: {
                type: ArrayConstructor;
                elementType: typeof Actions.ActionBase;
            };
        };
        private _eventName;
        /** @ignore */
        get actionName(): string;
        /** @ignore */
        set eventName(value: string);
        /** @ignore */
        constructor(configBlock: string, element: VWElement);
        /** @ignore */
        onSourceElementAdded(element: VWElement): void;
        /** @ignore */
        onSourceElementRemoved(element: VWElement): void;
        private _executeControlEventActions;
        /** @ignore */
        disposeTrigger(element: any): void;
    }
}
declare namespace VisiWin.Triggers {
    /** @ignore */
    class TimerTrigger extends TriggerBase implements ITriggerBase {
        /** @ignore */
        static triggerName: string;
        /** @ignore */
        static propertyList: {
            totalTicks: {
                type: NumberConstructor;
            };
            millisecondsPerTick: {
                type: NumberConstructor;
            };
            triggeredActions: {
                type: ArrayConstructor;
                elementType: typeof Actions.ActionBase;
            };
        };
        /** @ignore */
        totalTicks: number;
        /** @ignore */
        millisecondsPerTick: number;
        /** @ignore */
        constructor(configBlock: string, element: VWElement);
        /** @ignore */
        onElementAttached(element: any): void;
        /** @ignore */
        onElementDetached(element: any): void;
        private _tickHandler;
        /** @ignore */
        disposeTrigger(element: any): void;
    }
}
declare namespace VisiWin.Triggers {
    /** @ignore */
    class RequestAnimationFrameTrigger extends TriggerBase implements ITriggerBase {
        /** @ignore */
        static triggerName: string;
        /** @ignore */
        static propertyList: {
            triggeredActions: {
                type: ArrayConstructor;
                elementType: typeof Actions.ActionBase;
            };
            booleanTriggeredActionsTrue: {
                type: ArrayConstructor;
                elementType: typeof Actions.ActionBase;
            };
            booleanTriggeredActionsFalse: {
                type: ArrayConstructor;
                elementType: typeof Actions.ActionBase;
            };
        };
        /** @ignore */
        constructor(configBlock: string, element: VWElement);
        /** @ignore */
        onElementAttached(element: any): void;
        /** @ignore */
        onElementDetached(element: any): void;
        /** @ignore */
        _frameCallBack(element: any): void;
    }
}
declare namespace VisiWin.Triggers {
    /** @ignore */
    class InitialTrigger extends SelectorSourcedTrigger implements ISelectorSourcedTrigger {
        /** @ignore */
        static triggerName: string;
        /** @ignore */
        static propertyList: {
            triggeredActions: {
                type: ArrayConstructor;
                elementType: typeof Actions.ActionBase;
            };
        };
        /** @ignore */
        constructor(configBlock: string, element: VWElement);
        /** @ignore */
        onSourceElementAdded(element: VWElement): void;
        /** @ignore */
        onSourceElementRemoved(element: VWElement): void;
        /** @ignore */
        private _executeControlEventActions;
        /** @ignore */
        disposeTrigger(element: any): void;
    }
}
declare namespace VisiWin.Triggers {
    /** @ignore */
    class ActionResultTrigger extends SelectorSourcedTrigger implements VisiWin.Triggers.ISelectorSourcedTrigger {
        /** @ignore */
        static triggerName: string;
        /** @ignore */
        static propertyList: {
            resultId: {
                type: StringConstructor;
            };
            triggeredActions: {
                type: ArrayConstructor;
                elementType: typeof Actions.ActionBase;
            };
        };
        private resultId;
        private _resultService;
        private _sourceInfo;
        /** @ignore */
        constructor(configBlock: string, element: VWElement);
        /** @ignore */
        remoteExecuteAction(targetElement: VWElement, triggerData: VisiWin.Actions.ITriggerData): Promise<void>;
        private _executeControlEventActions;
    }
}
declare namespace VisiWin.Actions {
    interface IPropertyList {
        [index: string]: {
            type: DataType;
            elementType?: ElementType;
        };
    }
    type DataType = String | Boolean | Number | Array<any> | any;
    type ElementType = VisiWin.Actions.ActionBase | any;
    type ExecuteValue = string | boolean | number | any;
    type ExecuteResut = any | boolean | string;
    type EventMixinEvent = any;
    type ValueProperty = any;
    type TriggerSourceDataProperty = any;
    type ServiceData = any;
    type OperandType = string | number | boolean | any;
    type ConvertedVariableType = string | number | boolean | any;
    interface IResultAction {
        reason: string;
        succeed: boolean;
    }
    interface ITriggerData {
        conditionResult?: boolean;
        resultAction?: IResultAction;
        event?: EventMixinEvent;
        sender?: VisiWin.Triggers.ITriggerBase;
        sourceElement?: HTMLElement;
        targetElement?: HTMLElement;
        sourceControl?: VWElement;
        targetControl?: VWElement;
        value?: ValueProperty;
        triggerSourceData?: TriggerSourceDataProperty;
    }
    interface IConditionResult {
        returnValue: boolean;
        errorText: string;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class SetThemeAction
    * @classdesc Change the current theme
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class SetThemeAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            theme: {
                type: StringConstructor;
            };
            themeIfTrue: {
                type: StringConstructor;
            };
            themeIfFalse: {
                type: StringConstructor;
            };
        };
        theme: string;
        themeIfTrue: string;
        themeIfFalse: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class SetPropertyAction
    * @classdesc Class to set a property
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class SetPropertyAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
            propertyName: {
                type: StringConstructor;
            };
            propertyValue: {
                type: StringConstructor;
            };
            propertyValueIfTrue: {
                type: StringConstructor;
            };
            propertyValueIfFalse: {
                type: StringConstructor;
            };
        };
        propertyName: string;
        propertyValue: string;
        propertyValueIfTrue: string;
        propertyValueIfFalse: string;
        private _targetPropertyType;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(element: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class TogglePropertyAction
    * @classdesc Toggles a boolean property of an element
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class TogglePropertyAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
            propertyName: {
                type: StringConstructor;
            };
        };
        propertyName: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class CallMethodAction
    * @classdesc Class to call a control method
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class CallMethodAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
            method: {
                type: StringConstructor;
            };
            arg1: {
                type: StringConstructor;
            };
            arg2: {
                type: StringConstructor;
            };
        };
        method: string;
        arg1: any;
        arg2: any;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: VisiWin.Actions.ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RestartAction
    * @classdesc Class which restarts the application with location.reload
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RestartAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {};
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class ApplicationShowAction
    * @classdesc Class to set a property
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class ApplicationShowAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            showValue: {
                type: StringConstructor;
            };
        };
        showValue: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class DelayAction
    * @classdesc Class to call a delay
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    /**
    * Internal do not use
    * @internal
    */
    class DelayAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            ticks: {
                type: NumberConstructor;
            };
        };
        ticks: number;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<ExecuteResut>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class ConverterAction
    * @classdesc Class to call a converter from AppService
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class ConverterAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            converter: {
                type: StringConstructor;
            };
        };
        converter: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class IfConditionAction
    * @classdesc
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class IfConditionAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
            propertyName: {
                type: StringConstructor;
            };
            propertyValue: {
                type: StringConstructor;
            };
            propertyValueIfTrue: {
                type: StringConstructor;
            };
            propertyValueIfFalse: {
                type: StringConstructor;
            };
        };
        propertyName: string;
        propertyValue: string;
        propertyValueIfTrue: string;
        propertyValueIfFalse: string;
        private _targetPropertyType;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(element: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class AcknowledgeAlarmAction
    * @classdesc Used in current alarmlist to acknowledge alarms
    * @memberof VisiWin.Actions
    * @extends ActionBase
    * @internal
    */
    class AcknowledgeAlarmAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
        };
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: VisiWin.Actions.ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class AcknowledgeAlarmsAction
    * @classdesc Acknowledge alarm groups, alarm classes or all alarms
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class AcknowledgeAlarmsAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            desiredGroups: {
                type: StringConstructor;
            };
            desiredClasses: {
                type: StringConstructor;
            };
        };
        desiredGroups: string;
        desiredClasses: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: VisiWin.Actions.ITriggerData): Promise<null> | null;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: VisiWin.Actions.ITriggerData): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    interface ISetVariableAction extends IActionBase {
        setValue(value: any): Promise<void>;
    }
    /**
   * @class SetVariableAction
   * @classdesc Set a varaible value
   * @memberof VisiWin.Actions
   * @extends ActionBase
   */
    class SetVariableAction extends ActionBase implements ISetVariableAction {
        static actionName: string;
        static propertyList: {
            variableName: {
                type: StringConstructor;
            };
            value: {
                type: StringConstructor;
            };
            valueIfTrue: {
                type: StringConstructor;
            };
            valueIfFalse: {
                type: StringConstructor;
            };
        };
        variableName: string;
        value: string;
        valueIfTrue: string;
        valueIfFalse: string;
        private _vwVariable;
        private _vwType;
        private _isAttach;
        private _postSetFlag;
        private _postSetValue;
        private _postSetPropertyValue;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        setValue(value: any): Promise<void>;
        private _attachVariable;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    interface IDecrementVariableAction extends IActionBase {
        setValue(bitNumber: number): Promise<void>;
    }
    /**
    * @class DecrementVariableAction
    * @classdesc Decremnts a variable by the given value
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class DecrementVariableAction extends ActionBase implements IDecrementVariableAction {
        static actionName: string;
        static propertyList: {
            variableName: {
                type: StringConstructor;
            };
            value: {
                type: NumberConstructor;
            };
            valueIfTrue: {
                type: NumberConstructor;
            };
            valueIfFalse: {
                type: NumberConstructor;
            };
            useRawValue: {
                type: BooleanConstructor;
            };
            isLimitCheckEnabled: {
                type: BooleanConstructor;
            };
            rawLimitMin: {
                type: NumberConstructor;
            };
            useVariableLimits: {
                type: BooleanConstructor;
            };
        };
        variableName: string;
        value: number;
        valueIfTrue: number;
        valueIfFalse: number;
        useRawValue: boolean;
        isLimitCheckEnabled: boolean;
        rawLimitMin: number;
        useVariableLimits: boolean;
        curentUnit: VisiWin.System.DataAccess.IUnit;
        private _vwVariable;
        private _vwType;
        private _isAttach;
        private _postSetFlag;
        private _postSetValue;
        private _postSetPropertyValue;
        private _boundUnitClassChangedHandler;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        setValue(value: any): Promise<void>;
        private _attachVariable;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
        private _unitClassChangedHandler;
        private _rawValue2value;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    interface IIncrementVariableAction extends IActionBase {
        setValue(bitNumber: number): Promise<void>;
    }
    /**
    * @class IncrementVariableAction
    * @classdesc Increments a variable by the given value
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class IncrementVariableAction extends ActionBase implements IIncrementVariableAction {
        static actionName: string;
        static propertyList: {
            variableName: {
                type: StringConstructor;
            };
            value: {
                type: NumberConstructor;
            };
            valueIfTrue: {
                type: NumberConstructor;
            };
            valueIfFalse: {
                type: NumberConstructor;
            };
            useRawValue: {
                type: BooleanConstructor;
            };
            isLimitCheckEnabled: {
                type: BooleanConstructor;
            };
            rawLimitMax: {
                type: NumberConstructor;
            };
            useVariableLimits: {
                type: BooleanConstructor;
            };
        };
        variableName: string;
        value: number;
        valueIfTrue: number;
        valueIfFalse: number;
        useRawValue: boolean;
        isLimitCheckEnabled: boolean;
        rawLimitMax: number;
        useVariableLimits: boolean;
        curentUnit: VisiWin.System.DataAccess.IUnit;
        private _vwVariable;
        private _vwType;
        private _isAttach;
        private _postSetFlag;
        private _postSetValue;
        private _postSetPropertyValue;
        private _boundUnitClassChangedHandler;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        setValue(value: any): Promise<void>;
        private _attachVariable;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
        private _unitClassChangedHandler;
        private _rawValue2value;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    interface ISetBitAction extends IActionBase {
        setBit(bitNumber: number): Promise<boolean>;
    }
    /**
    * @class SetBitAction
    * @classdesc Set a bit value
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class SetBitAction extends ActionBase implements ISetBitAction {
        static actionName: string;
        static propertyList: {
            variableName: {
                type: StringConstructor;
            };
            bitNumber: {
                type: NumberConstructor;
            };
        };
        variableName: string;
        bitNumber: number;
        private _vwVariable;
        private _vwType;
        private _isAttach;
        private _postSetFlag;
        private _postSetValue;
        private _postSetPropertyValue;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        setBit(bitNumber: number): Promise<boolean>;
        private _attachVariable;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    interface IResetBitAction extends IActionBase {
        setBit(bitNumber: number): Promise<boolean>;
    }
    /**
    * @class ResetBitAction
    * @classdesc Resets a bit value
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class ResetBitAction extends ActionBase implements IResetBitAction {
        static actionName: string;
        static propertyList: {
            variableName: {
                type: StringConstructor;
            };
            bitNumber: {
                type: NumberConstructor;
            };
        };
        variableName: string;
        bitNumber: number;
        private _vwVariable;
        private _vwType;
        private _isAttach;
        private _postSetFlag;
        private _postSetValue;
        private _postSetPropertyValue;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        setBit(bitNumber: number): Promise<boolean>;
        private _attachVariable;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    interface IToggleBitAction extends IActionBase {
        setBit(bitNumber: number): Promise<void>;
    }
    /**
    * @class ToggleBitAction
    * @classdesc Toggles a bit value
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class ToggleBitAction extends ActionBase implements IToggleBitAction {
        static actionName: string;
        static propertyList: {
            variableName: {
                type: StringConstructor;
            };
            bitNumber: {
                type: NumberConstructor;
            };
        };
        variableName: string;
        bitNumber: number;
        private _vwVariable;
        private _vwType;
        private _isAttach;
        private _postSetFlag;
        private _postSetValue;
        private _postSetPropertyValue;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        setBit(bitNumber: number): Promise<void>;
        private _attachVariable;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    interface IDialogBase {
        getDialogControl?(element: HTMLElement): VWElement;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class DialogBase
    * @description Base Class for all VisiWin dialog actions.
    * @memberof VisiWin.Actions
    */
    class DialogBase extends ActionBase implements IDialogBase {
        /**
        * @description The name of the action
        * @member {@link VisiWin.UI.JSPrimitives.String|string} actionName
        */
        static actionName: string;
        actionName: string;
        static dialogBasePropertyList: IPropertyList;
        constructor();
        getDialogControl(element: HTMLElement): VWElement;
        /**
        * init
        * This method is called after the constructor as second from the action lifecycle
        * abstract must be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        disposeAction(): void;
        /**

        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: VisiWin.Actions.ITriggerData): Promise<null>;
        /**
        * getInitialValue
        * This method is called as third from the action lifecycle
        * abstract must be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class DialogResultAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {
            dialogResult: {
                type: StringConstructor;
            };
        };
        dialogResult: string;
        private _dialogControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class ShowPopupAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            viewName: {
                type: StringConstructor;
            };
            anchor: {
                type: StringConstructor;
            };
            placement: {
                type: StringConstructor;
            };
            alignment: {
                type: StringConstructor;
            };
            mode: {
                type: StringConstructor;
            };
            popupBackgroundColor: {
                type: StringConstructor;
            };
        };
        viewName: string;
        anchor: string;
        placement: string;
        alignment: string;
        mode: string;
        popupBackgroundColor: string;
        private _boundResultHandler;
        private _popupControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: VisiWin.Actions.ITriggerData): Promise<null>;
        showAt(xPos: any, yPos: any): void;
        resultHandler(args: any, p2: unknown): void;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class ShowDialogAction extends DialogBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            anchor: {
                type: StringConstructor;
            };
            placement: {
                type: StringConstructor;
            };
            alignment: {
                type: StringConstructor;
            };
            mode: {
                type: StringConstructor;
            };
            dialogName: {
                type: StringConstructor;
            };
            dialogNameIfFalse: {
                type: StringConstructor;
            };
            autoClose: {
                type: BooleanConstructor;
            };
            dialogScrimColor: {
                type: StringConstructor;
            };
        };
        private _appService;
        private _langService;
        anchor: string;
        placement: string;
        alignment: string;
        mode: string;
        dialogName: string;
        dialogNameIfFalse: string;
        autoClose: boolean;
        dialogScrimColor: string;
        private _dialogControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        openDialog(pdialogName: string, element: VWElement): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
        showAt(xPos: any, yPos: any): void;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class ShowAlertDialogAction extends DialogBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            anchor: {
                type: StringConstructor;
            };
            placement: {
                type: StringConstructor;
            };
            alignment: {
                type: StringConstructor;
            };
            mode: {
                type: StringConstructor;
            };
            dialogName: {
                type: StringConstructor;
            };
            style: {
                type: StringConstructor;
            };
            titleText: {
                type: StringConstructor;
            };
            localizableTitleText: {
                type: StringConstructor;
            };
            contentText: {
                type: StringConstructor;
            };
            localizableContentText: {
                type: StringConstructor;
            };
            action1ButtonText: {
                type: StringConstructor;
            };
            localizableAction1ButtonText: {
                type: StringConstructor;
            };
            action2ButtonText: {
                type: StringConstructor;
            };
            localizableAction2ButtonText: {
                type: StringConstructor;
            };
            showAction1Button: {
                type: BooleanConstructor;
            };
            showAction2Button: {
                type: BooleanConstructor;
            };
            dialogScrimColor: {
                type: StringConstructor;
            };
        };
        private _appService;
        anchor: string;
        placement: string;
        alignment: string;
        mode: string;
        dialogName: string;
        style: string;
        titleText: string;
        localizableTitleText: string;
        contentText: string;
        localizableContentText: string;
        action1ButtonText: string;
        localizableAction1ButtonText: string;
        action2ButtonText: string;
        localizableAction2ButtonText: string;
        showAction1Button: boolean;
        showAction2Button: boolean;
        dialogScrimColor: string;
        private _dialogControl;
        private _boundResultHandler;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        resultHandler(args: any, p2: any): void;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
        showAt(xPos: any, yPos: any): void;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class CloseDialogAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {};
        private _dialogControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<ExecuteResut>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class CloseKeyboardDialogAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {
            applyValue: {
                type: BooleanConstructor;
            };
        };
        private _dialogControl;
        private applyValue;
        private dataSource;
        private dialogViewIdentifier;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<ExecuteResut>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
        getDataContext(): any;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class LoginAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {
            user: {
                type: StringConstructor;
            };
            password: {
                type: StringConstructor;
            };
            userElementId: {
                type: StringConstructor;
            };
            passwordElementId: {
                type: StringConstructor;
            };
            messageElementId: {
                type: StringConstructor;
            };
            userMessageElementId: {
                type: StringConstructor;
            };
            passwordMessageElementId: {
                type: StringConstructor;
            };
        };
        user: string;
        password: string;
        userElementId: string;
        passwordElementId: string;
        messageElementId: string;
        userMessageElementId: string;
        passwordMessageElementId: string;
        resultName: "LoginAction";
        private _userElement;
        private _passwordElement;
        private _messageElement;
        private _userMessageElement;
        private _passwordMessageElement;
        private _dialogControl;
        private _triggerData;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<ExecuteResut>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
        _setUserMessage(msg: string): void;
        _setPasswordMessage(msg: string): void;
        _setMessage(msg: string): void;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class LogonAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {
            user: {
                type: StringConstructor;
            };
            password: {
                type: StringConstructor;
            };
            userSelector: {
                type: StringConstructor;
            };
            passwordSelector: {
                type: StringConstructor;
            };
            userMessageSelector: {
                type: StringConstructor;
            };
            passwordMessageSelector: {
                type: StringConstructor;
            };
            initialLogon: {
                type: BooleanConstructor;
            };
        };
        user: string;
        password: string;
        userSelector: string;
        passwordSelector: string;
        userMessageSelector: string;
        passwordMessageSelector: string;
        initialLogon: boolean;
        resultName: string;
        element: any;
        private _userElement;
        private _passwordElement;
        private _userMessageElement;
        private _passwordMessageElement;
        private _dialogControl;
        private _newAlertDialog;
        private _newChangePwDialog;
        private _showDialog;
        private _boundAlertResultHandler;
        private _appService;
        constructor();
        private changePassword;
        private renewPassword;
        private alertResultHandler;
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class VerifyLoginAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {
            user: {
                type: StringConstructor;
            };
            userSelector: {
                type: StringConstructor;
            };
            password: {
                type: StringConstructor;
            };
            passwordSelector: {
                type: StringConstructor;
            };
            messageSelector: {
                type: StringConstructor;
            };
            messageText: {
                type: StringConstructor;
            };
            resultName: {
                type: StringConstructor;
            };
            userMessageSelector: {
                type: StringConstructor;
            };
            passwordMessageSelector: {
                type: StringConstructor;
            };
            autoDialogHide: {
                type: BooleanConstructor;
            };
        };
        user: string;
        userSelector: string;
        password: string;
        passwordSelector: string;
        messageSelector: string;
        messageText: string;
        resultName: string;
        userMessageSelector: string;
        passwordMessageSelector: string;
        autoDialogHide: boolean;
        private _msgElement;
        private _dialogControl;
        private _msgControl;
        private _userMsgControl;
        private _passwordMsgControl;
        private _loginTriggerData;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        private showMessageUser;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        private showMessagePassword;
        private _dialogHide;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class ChangePasswordAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {
            currentUserNameSelector: {
                type: StringConstructor;
            };
            currentUserFullNameSelector: {
                type: StringConstructor;
            };
            oldPasswordSelector: {
                type: StringConstructor;
            };
            newPasswordSelector: {
                type: StringConstructor;
            };
            repeatPasswordSelector: {
                type: StringConstructor;
            };
            currentUserNameMessageSelector: {
                type: StringConstructor;
            };
            currentUserFullNameMessageSelector: {
                type: StringConstructor;
            };
            oldPasswordMessageSelector: {
                type: StringConstructor;
            };
            newPasswordMessageSelector: {
                type: StringConstructor;
            };
            repeatPasswordMessageSelector: {
                type: StringConstructor;
            };
        };
        currentUserNameSelector: string;
        currentUserFullNameSelector: string;
        oldPasswordSelector: string;
        newPasswordSelector: string;
        repeatPasswordSelector: string;
        currentUserNameMessageSelector: string;
        currentUserFullNameMessageSelector: string;
        oldPasswordMessageSelector: string;
        newPasswordMessageSelector: string;
        repeatPasswordMessageSelector: string;
        resultName: string;
        private _currentUserNameElement;
        private _currentUserFullNameElement;
        private _oldPasswordElement;
        private _newPasswordElement;
        private _repeatPasswordElement;
        private _currentUserNameMessageElement;
        private _currentUserFullNameMessageElement;
        private _oldPasswordMessageElement;
        private _newPasswordMessageElement;
        private _repeatPasswordMessageElement;
        private _dialogControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class AddUserAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {};
        resultName: string;
        private _dialogControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class RefreshUserAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {};
        private _dialogControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class ChangeUserAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {};
        resultName: string;
        private _dialogControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class ChangeSelectedUserAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {};
        private _dialogControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(elements: HTMLElement | HTMLElement[], triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class RemoveSelectedUserAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {};
        private _dialogControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class RemoveUserAction extends DialogBase implements IDialogBase {
        static actionName: string;
        static propertyList: {
            userNameSelector: {
                type: StringConstructor;
            };
            userNameMessageSelector: {
                type: StringConstructor;
            };
        };
        userNameSelector: string;
        userNameMessageSelector: string;
        resultName: string;
        private _userNameElement;
        private _userNameMessageElement;
        private _dialogControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    class LoginAsyncAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: IPropertyList;
        user: string;
        userElementId: string;
        password: string;
        passwordElementId: string;
        messageElementId: string;
        messageText: string;
        private _msgControl;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        private _loginMsgHandler;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: VisiWin.Actions.ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class SetLanguageAction
    * @classdesc Changes the current language
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class SetLanguageAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            language: {
                type: StringConstructor;
            };
            languageIfTrue: {
                type: StringConstructor;
            };
            languageIfFalse: {
                type: StringConstructor;
            };
        };
        language: string;
        languageIfTrue: string;
        languageIfFalse: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class TrendChartBackwardAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
        };
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class TrendChartFastBackwardAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
        };
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class TrendChartForwardAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
        };
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class TrendChartFastForwardAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
        };
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class TrendChartOfflineAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
        };
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class TrendChartOnlineAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
        };
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class TrendChartRefreshAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
        };
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class TrendChartTimeSpanAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
            timeSpan: {
                type: StringConstructor;
            };
            timeSpanIfTrue: {
                type: StringConstructor;
            };
            timeSpanIfFalse: {
                type: StringConstructor;
            };
        };
        timeSpan: string;
        timeSpanIfTrue: string;
        timeSpanIfFalse: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
declare namespace VisiWin.Actions {
    class TrendChartToggleOnlineAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
        };
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: VisiWin.Actions.ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: any, triggerData: any): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class AddClassAction extends ActionBase implements IActionBase {
        static propertyList: {
            className: {
                type: StringConstructor;
            };
            targetSelector: {
                type: StringConstructor;
            };
        };
        className: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class RemoveChildrenAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            parentElement: {
                type: StringConstructor;
            };
        };
        get parentElement(): string;
        set parentElement(value: string);
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class RemoveClassAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            className: {
                type: StringConstructor;
            };
            targetSelector: {
                type: StringConstructor;
            };
        };
        className: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class RemoveElementsAction extends ActionBase implements IActionBase {
        static actionNAme: string;
        static propertyList: {
            elementsToRemove: {
                type: StringConstructor;
            };
        };
        get elementsToRemove(): string;
        set elementsToRemove(value: string);
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class SetHTMLAttributeAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
            attribute: {
                type: StringConstructor;
            };
            attributeValue: {
                type: StringConstructor;
            };
        };
        attribute: string;
        attributeValue: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class SetStyleAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
            styleProperty: {
                type: StringConstructor;
            };
            styleValue: {
                type: StringConstructor;
            };
        };
        styleProperty: string;
        styleValue: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class ToggleStyleAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            targetSelector: {
                type: StringConstructor;
            };
            styleProperty: {
                type: StringConstructor;
            };
            styleValueFirst: {
                type: StringConstructor;
            };
            styleValueSecond: {
                type: StringConstructor;
            };
        };
        styleProperty: string;
        styleValueFirst: string;
        styleValueSecond: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class ToggleClassAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            className: {
                type: StringConstructor;
            };
            targetSelector: {
                type: StringConstructor;
            };
        };
        className: string;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class NavigateToPageAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            pageOptions: {
                type: ObjectConstructor;
            };
            pageNameIfTrue: {
                type: StringConstructor;
            };
            pageNameIfFalse: {
                type: StringConstructor;
            };
            showLoadingSymbol: {
                type: BooleanConstructor;
            };
        };
        pageOptions: any;
        pageNameIfTrue: string;
        pageNameIfFalse: string;
        showLoadingSymbol: boolean;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        setPage(pageName: string, pageOptions: object): void;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
     * Internal do not use
     * @internal
     */
    class SetViewAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            pageOptions: {
                type: ObjectConstructor;
            };
            regionElementId: {
                type: StringConstructor;
            };
            viewNameIfTrue: {
                type: StringConstructor;
            };
            viewNameIfFalse: {
                type: StringConstructor;
            };
            showLoadingSymbol: {
                type: BooleanConstructor;
            };
        };
        pageOptions: any;
        regionElementId: string;
        viewNameIfTrue: string;
        viewNameIfFalse: string;
        showLoadingSymbol: boolean;
        constructor();
        /**
        * Overwrite to execute the action<br>
        * This method is called when the action is triggered. Derived Actions must override this.<br>
        * Abstract must be implemented
        * @value true, false if value exists - boolean. No other types displayed, but are possible?. The same value is in triggerData as well.
        * @element VWElement refers to the VisiWin element on which this action should be executed.
        * @triggerData Info provided by the trigger
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        setView(regionElementIdArray: string[], viewName: string, pageOptions: object, element: VWElement): void;
        /**
        * Overwrite to initialize the action<br>
        * This method is called after the constructor as second from the action lifecycle<br>
        * Abstract could be implemented<br>
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        init(elements: VWElement, triggerData: ITriggerData): void;
        /**
        * Overwrite to cleanup the action<br>
        * This method is called from TriggerBase<br>
        * Abstract should be implemented
        */
        disposeAction(): void;
        /**
        * Overwrite to initialize the action and get Execute value(typically boolean or string)<br>
        * This method is called as third from the action lifecycle<br>
        * Abstract could be implemented
        * @element VWElement refers to the VisiWin control, where the action is bind
        * @triggerData contains data from VisiWin.Actions.ActionBase
        */
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions.Recipe {
    /**
    * @class RecipeClassBaseAction
    * @classdesc base class for recipe actions
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassBaseAction extends ActionBase implements IActionBase {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
        };
        recipeClassName: string;
        recipeClass: VisiWin.System.Recipe.IRecipeClass;
        actionResultId: string;
        actionResultOutPutElement: any;
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        init(elements: VWElement, triggerData: ITriggerData): void;
        _initClass(triggerData: ITriggerData): Promise<void>;
    }
}
declare namespace VisiWin.Actions.Recipe {
    function _tryGetWinControl(id: string): any;
    function _tryGetOutputWinControl(id: string): any;
    function _displayOutputResult(element: any, logSeverity: string, msg: string): void;
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeSetClassAction
    * @classdesc Set a recipe class as default to VisiWin.AppServices.RecipeService.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeSetClassAction extends VisiWin.Actions.Recipe.RecipeClassBaseAction {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
        };
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeClassLoadFileToBufferAction
    * @classdesc Loads a recipe file to the recipe buffer.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassLoadFileToBufferAction extends Recipe.RecipeClassBaseAction {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
            recipeFileName: {
                type: StringConstructor;
            };
            recipeFileNameId: {
                type: StringConstructor;
            };
            normalized: {
                type: BooleanConstructor;
                defaultValue: boolean;
            };
        };
        recipeClassName: string;
        actionResultId: string;
        recipeFileName: string;
        recipeFileNameId: string;
        normalized: boolean;
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        init(elements: VWElement, triggerData: ITriggerData): void;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
        _get(triggerData: ITriggerData): Promise<void>;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeClassLoadFileToProcessAction
    * @classdesc Loads the recipe file values to the process.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassLoadFileToProcessAction extends Recipe.RecipeClassBaseAction {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
            recipeFileName: {
                type: StringConstructor;
            };
            recipeFileNameId: {
                type: StringConstructor;
            };
            normalized: {
                type: BooleanConstructor;
                defaultValue: boolean;
            };
        };
        recipeClassName: string;
        actionResultId: string;
        recipeFileName: string;
        recipeFileNameId: string;
        normalized: boolean;
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        init(elements: VWElement, triggerData: ITriggerData): void;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
        _get(triggerData: ITriggerData): Promise<void>;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeClassLockRecipeAction
    * @classdesc Locks the recipe class.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassLockRecipeAction extends Recipe.RecipeClassBaseAction {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
        };
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeClassReadProcessToBufferAction
    * @classdesc Reads the process values to the recipe buffer.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassReadProcessToBufferAction extends Recipe.RecipeClassBaseAction {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
        };
        recipeClassName: string;
        actionResultId: string;
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeClassSaveBufferToFileAction
    * @classdesc Saves the recipe buffer values to a file.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassSaveBufferToFileAction extends Recipe.RecipeClassBaseAction {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
            recipeFileName: {
                type: StringConstructor;
            };
            recipeFileNameId: {
                type: StringConstructor;
            };
            recipeDescription: {
                type: StringConstructor;
            };
            recipeDescriptionId: {
                type: StringConstructor;
            };
            normalized: {
                type: BooleanConstructor;
                defaultValue: boolean;
            };
            forceOverwrite: {
                type: BooleanConstructor;
                defaultValue: boolean;
            };
        };
        recipeClassName: string;
        actionResultId: string;
        recipeFileName: string;
        recipeFileNameId: string;
        recipeDescriptionId: string;
        recipeDescription: string;
        normalized: boolean;
        forceOverwrite: boolean;
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        init(elements: VWElement, triggerData: ITriggerData): void;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
        _get(triggerData: ITriggerData): Promise<void>;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeClassSaveProcessToFileAction
    * @classdesc Saves the recipe process values to a file.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassSaveProcessToFileAction extends Recipe.RecipeClassBaseAction {
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
            recipeFileName: {
                type: StringConstructor;
            };
            recipeFileNameId: {
                type: StringConstructor;
            };
            recipeDescription: {
                type: StringConstructor;
            };
            recipeDescriptionId: {
                type: StringConstructor;
            };
            normalized: {
                type: BooleanConstructor;
                defaultValue: boolean;
            };
            forceOverwrite: {
                type: BooleanConstructor;
                defaultValue: boolean;
            };
        };
        recipeClassName: string;
        actionResultId: string;
        recipeFileName: string;
        recipeFileNameId: string;
        recipeDescriptionId: string;
        recipeDescription: string;
        normalized: boolean;
        forceOverwrite: boolean;
        constructor();
        execute(value: boolean, element: VWElement, triggerData: ITriggerData): Promise<null>;
        init(elements: VWElement, triggerData: ITriggerData): void;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
        _get(triggerData: ITriggerData): Promise<void>;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeClassStartEditAction
    * @classdesc Starts the edit mode for a recipe class.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassStartEditAction extends Recipe.RecipeClassBaseAction {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
        };
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeClassStopEditAction
    * @classdesc Stops the edit mode for a recipe class.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassStopEditAction extends Recipe.RecipeClassBaseAction implements IActionBase {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
        };
        recipeClassName: string;
        actionResultId: string;
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeClassUnlockRecipeAction
    * @classdesc Locks the recipe class.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassUnlockRecipeAction extends Recipe.RecipeClassBaseAction {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
        };
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
/**
* @namespace
* @name VisiWin.Actions
*/
declare namespace VisiWin.Actions {
    /**
    * @class RecipeClassWriteBufferToProcessAction
    * @classdesc Writes the buffer values to the process values.
    * @memberof VisiWin.Actions
    * @extends ActionBase
    */
    class RecipeClassWriteBufferToProcessAction extends Recipe.RecipeClassBaseAction {
        static actionName: string;
        static propertyList: {
            recipeClassName: {
                type: StringConstructor;
            };
            actionResultId: {
                type: StringConstructor;
            };
        };
        recipeClassName: string;
        actionResultId: string;
        constructor();
        execute(value: VisiWin.Actions.ExecuteValue, element: VWElement, triggerData: ITriggerData): Promise<null>;
        disposeAction(): void;
        getInitialValue(element: VWElement, triggerData: ITriggerData): ExecuteValue;
    }
}
declare namespace VisiWin.UI {
    class EventMixinEvent {
        static supportedForProcessing: boolean;
        bubbles: {
            value: boolean;
            writable: boolean;
        };
        cancelable: {
            value: boolean;
            writable: boolean;
        };
        trusted: {
            value: boolean;
            writable: boolean;
        };
        eventPhase: {
            value: number;
            writable: boolean;
        };
        timeStamp: any;
        type: any;
        detail: any;
        private target;
        get currentTarget(): any;
        private _preventDefaultCalled;
        get defaultPrevented(): any;
        preventDefault(): void;
        constructor(type: string, detail: any, target: any);
        _stopImmediatePropagationCalled: boolean;
        stopImmediatePropagation(): void;
        stopPropagation(): void;
    }
}
declare namespace VisiWin.UI.Internal {
    /**
    * Internal do not use
    * @internal
    * */
    function _getResourceValue(ctrl: ProviderBase, propertyName: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function _toCamelCase(name: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function _msType2vwType(msType: any): string;
    /**
    * Internal do not use
    * @internal
    * */
    function _dispatchUpdateBase(ctrl: ProviderBase, changeType: string, changeName: string, newValue: any, oldValue: any): void;
    /**
    * Internal do not use
    * @internal
    * */
    function _getPredictProperty(ctrl: ProviderBase, name: string): any;
    /**
    * Internal do not use
    * @internal
    * */
    function _getEventList(ctrl: ProviderBase): any[];
    /**
    * Internal do not use
    * @internal
    * */
    function _getEventItem(ctrl: ProviderBase, eventName: string): object;
}
declare namespace VisiWin.UI.Internal {
    /**
    * Internal do not use
    * @internal
    * */
    function __getThemeResource(ctrl: ProviderBase, theme: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function __getColorResource(value: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function __getBackgroundResource(value: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function __getAnimationResource(value: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function __getShadowResource(value: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function ___c(ctrl: ProviderBase, value: string, name: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function ___t(ctrl: ProviderBase, value: string, name: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function ___b(ctrl: ProviderBase, value: string, name: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function ___a(ctrl: ProviderBase, value: string, name: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function ___s(ctrl: ProviderBase, value: string, name: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function _getThemeColor(ctrl: ProviderBase, value: string, name?: any): string;
    /**
    * Internal do not use
    * @internal
    * */
    function __unused(ctrl: ProviderBase, value: string, name: string): string;
}
declare namespace VisiWin.UI.Internal.Design {
    /**
    * Internal do not use
    * @internal
    * */
    function _toCssName(name: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function _calculatedStyle(ctrl: ProviderBase, style: string, control: ProviderBase, parent: ProviderBase, parentName: string): string;
    /**
    * Internal do not use
    * @internal
    * */
    function _getOptionsDefaultValue(ctrl: ProviderBase, propertyName: string): any;
    /**
    * Internal do not use
    * @internal
    * */
    function _getOptionsListProperty(ctrl: ProviderBase, name: string, mainControl: ProviderBase, mainName: string): object;
    /**
    * Internal do not use
    * @internal
    * */
    function _getStyle(ctrl: ProviderBase, propName: string): boolean;
    /**
    * Internal do not use
    * @internal
    * */
    function _getOptionsValue(ctrl: ProviderBase, extendFlag?: boolean): any[];
    /**
    * Internal do not use
    * @internal
    * */
    function _getActionPropertyList(ctrl: ProviderBase, triggerIndex: any, actionIndex: any): any;
    /**
    * Internal do not use
    * @internal
    * */
    function _getTriggerPropertyList(ctrl: ProviderBase, triggerIndex: any): any;
    /**
    * Internal do not use
    * @internal
    * */
    function _getStyleNameFromType(controlName: string): string[];
    /**
    * Internal do not use
    * @internal
    * */
    function _getOptionsList(ctrl: ProviderBase, extendFlag: boolean): object;
}
declare module VisiWin.UI {
    interface IProviderBase {
        inlineOptions: any;
        __VWCONTROL__: string;
        /**
         * Gets the DOM element that hosts the Control.
         * Datatype: string
         * Defaultvalue: null
        **/
        element: any;
        /**
         * Gets the resourceName of the Control.
         * Concaternate the controlType and style(if set).
         * Use a private for value with the default value: null
         * Datatype: string
         * Defaultvalue: null
        **/
        resourceName: string;
        /**
         * Gets the controlType of the Control.
         * This is the content of the attribute "data-win-control".
         * Will be read at the first get. Save in private width
         * Datatype: string
         * DefaultValue: null
        **/
        controlType: string;
        /**
         * Gets the type of the Control. "
         * Every control is in one of the four controlgroups.
         * Datatype: string as enum
         * Defaultvalue: "Control";
         * Valid values:
         *      "Control"       normal UI controls
         *      "ControlPanel", normal UI controls, in the Content can place other controls
         *      "Layout"        spezial layout control, arrange control in the content
         *      "Layout"        spezial layout control, arrange control in the content
         *      "Provider"      data control without UI, work with data and export it
        **/
        designerType: string;
        /**
         * Gets the style of the Control.
         * The style is a free control sub group. It is used für different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * Gets the controlId
         * The controlID is the HTML id from the corrosponding HTML Element.
         * Datatype: string as enum
         * Defaultvalue: null
        **/
        controlId: string;
        /**
         * Methode
         * if false, the _updateLayout function is blocked. This is for the start phase of the control-
         * If using a updateLayout function, each setting of a property will call _updateLayout.
         * This will be blocked. First call of _updateLayout is in postSetOption in the defaultConstructor.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        updateLayoutEnable(value: boolean, changeType?: string, changeName?: string): void;
        /**
         * Get the class instance from the localizations service.
         * Datatype: object
         * Defaultvalue: null
        **/
        locService: VisiWin.AppServices.ILanguageService;
        /**
         * Get the class instance from the appliation service.
         * Datatype: object
         * Defaultvalue: null
        **/
        appService: VisiWin.AppServices.Impl.AppService;
        /**
         * Get or set the tag property.
         * This property is for project use. It has no special description, it can be used for every case.
         * Datatype: any
         * Defaultvalue: null
        **/
        tag: any;
        registerSourceId: string;
        registerTargetId: string;
        maxInterrations: number;
        parentElement: HTMLElement;
        parentControl: any;
        registerChild?(cName: any, cAction: any, cElement: any, cOptions: any): boolean;
        /**
         * Creates a new ControlBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        /**
         * Implements the VisiWin UI Control Pattern
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
         * @param controlName the control name, used for registration
         * @param className the standard css class name for this control
         * @param elementType? the HTML element type, default is "DIV", when no element is given as parameter, a new element of this type will be create
        **/
        defaultConstructor(element: HTMLElement, options: any, controlName: string, className: string, elementType?: string): any;
        /**
         * basis settings for a crontrol will set.
         * element, base css class, disposeable
         * @param element The DOM element that will host the control.
         * @param name the control name, used for registration
         * @param className the standard css class name for this control
         * @param elementType? the HTML element type, default is "DIV", when no element is given as parameter, a new element of this type will be create
        **/
        baseSettings(element: HTMLElement, name: string, className: string, elementType?: string): void;
        /**
         * a property or a member will be observe
         * @param name name of the property or member.
         * @param handler handler that will be call at a value change to the observable object
         * @param preExec?
        **/
        /**
         * remove the observe as a object
         * @param name name of the property or member.
         * @param handler handler that will be call at a value change to the observable object
        **/
        /**
         * remove a control as the VisiWin Control pattern.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    abstract class ProviderBase implements IProviderBase {
        static controlName: string;
        static supportedForProcessing: boolean;
        static ProviderBasePropertyList: {
            notifyPropertyChanged: {
                propertyType: string;
                group: string;
            };
            element: {
                propertyType: string;
                group: string;
                type: string;
                invisible: boolean;
            };
            resourceName: {
                propertyType: string;
                group: string;
                access: string;
            };
            controlType: {
                propertyType: string;
                group: string;
                access: string;
            };
            controlName: {
                propertyType: string;
                group: string;
            };
            designerType: {
                propertyType: string;
                group: string;
            };
            dataContext: {
                propertyType: string;
                type: string;
            };
            style: {
                propertyType: string;
                defaultValue: string;
            };
            basedOn: {
                propertyType: string;
                defaultValue: string;
            };
            controlId: {
                propertyType: string;
                group: string;
            };
            tag: {
                propertyType: string;
                group: string;
                type: string;
                invisible: boolean;
            };
            registerSourceId: {
                propertyType: string;
                group: string;
            };
            registerTargetId: {
                propertyType: string;
                group: string;
            };
        };
        element: VWElement;
        namespace: string;
        controlName: string;
        designerType: string;
        tag: any;
        registerTargetId: string;
        mutationElement: string;
        resizedElement: string;
        maxInterrations: number;
        __VWCONTROL__: string;
        optionsList: any[];
        eventList: any[];
        childElements: any[];
        arrayObjects: any[];
        inlineOptions: any;
        themeChangeProperties: {};
        private _firstAttach;
        private _disposed;
        private _listeners;
        private _observeListenerList;
        private _mutationObserver;
        private _resizeObserver;
        private _boundResizeHandlerDesignMode;
        private _boundResizeHandlerRunMode;
        private _boundResizeHandler;
        private _boundMutationHandlerDesignMode;
        private _boundMutationHandlerRunMode;
        private _boundMutationHandler;
        private _boundObserveHandler;
        private _boundChangeLanguageBase;
        static _mixinList: any[];
        static _disposeList: any[];
        private _dataContext;
        set dataContext(name: string);
        get dataContext(): string;
        private _parentElement;
        get parentElement(): VWElement;
        private _parentControl;
        get parentControl(): any;
        /**
            * Gets the resourceName of the Control.
            * Concaternate the controlType and style(if set).
            * Use a private for value with the default value: null
            * Datatype: string
            * Defaultvalue: null
        **/
        private _resourceName;
        private _resourceNameBase;
        get resourceName(): string;
        set resourceName(val: string);
        private _controlType;
        /**
         * Gets the controlType of the Control.
         * This is the content of the static properties namespceName and controlName
         * Will be read at the first get. Save in private width
         * Datatype: string
         * DefaultValue: null
        **/
        get controlType(): string;
        set controlType(val: string);
        private _style;
        private _styleBase;
        /**
            * Gets the style of the Control.
            * The style is a free control sub group. It is used für different default options.
            * Datatype: string
            * Defaultvalue: "Default"
        **/
        get style(): string;
        set style(value: string);
        private _basedOn;
        /**
            * Gets the basedOn of the Control.
            * The basedOn is the basis style definition, after this it will be add the style definition.
            * Datatype: string
            * Defaultvalue: "Default"
        **/
        get basedOn(): string;
        set basedOn(value: string);
        private _controlId;
        /**
         * Gets the id of the control
         * The controlID is the HTML id from the corrosponding HTML Element.
         * Datatype: string as enum
         * Defaultvalue: null
        **/
        get controlId(): string;
        set controlId(value: string);
        private _locService;
        /**
         * Get the class instance from the localizations service.
         * Datatype: object
         * Defaultvalue: null
        **/
        get locService(): VisiWin.AppServices.ILanguageService;
        set locService(val: VisiWin.AppServices.ILanguageService);
        private _appService;
        /**
         * Get the class instance from the appliation service.
         * Datatype: object
         * Defaultvalue: null
        **/
        get appService(): VisiWin.AppServices.Impl.AppService;
        set appService(val: VisiWin.AppServices.Impl.AppService);
        private _registerSourceId;
        set registerSourceId(value: string);
        get registerSourceId(): string;
        private _blockAction;
        /**
         * private property
         * get and set the blockAction.
         * If this property is set, the control is not activ, it will have no action and no change of the dispklayed style.
         * click and touch events will be blocked.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        get blockAction(): boolean;
        set blockAction(val: boolean);
        /**
         * Creates a new ControlBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: any, options: any);
        private createControlBaseHandler;
        private removeControlBaseHandler;
        private _updateLayoutEnable;
        updateLayoutEnable(value: boolean, changeType?: string, changeName?: string): void;
        /** @ignore */
        initializedBase(element: VWElement): void;
        /** @ignore */
        readyBase(element: VWElement): void;
        private _isAttached;
        get isAttached(): boolean;
        set isAttached(value: boolean);
        attach(): Promise<any>;
        detach(): Promise<any>;
        private registerAtParent;
        private unregisterAtParent;
        private mixProperties;
        private setDefaultOptionsBasedOn;
        private setDefaultOptionsResource;
        private setDefaultOptionsId;
        private setLangOptions;
        /** @ignore */
        dispatchNotifyPropertyChanged(changeType: string, changeName: string, newValue: any, oldValue: any, addEvent?: string, args?: any): void;
        /** @ignore */
        updateLayout(name?: string): void;
        private _updateLayoutAsync;
        private _updateLayoutWork;
        _updateLayoutBase(changeType: any, changeName?: string, newValue?: any, oldValue?: any): void;
        private _updateColorAsync;
        private _updateColorWork;
        _updateColorsBase(changeType: any, changeName?: string, newValue?: any, oldValue?: any): void;
        private getOptionListDefault;
        /**
         * Implements the VisiWin UI Control Pattern
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
         * @param controlName the control name, used for registration
         * @param className the standard css class name for this control
         * @param elementType? the HTML element type, default is "DIV", when no element is given as parameter, a new element of this type will be create
        **/
        defaultConstructor(element: VWElement, options: any, controlName: string, className: string, elementType?: string): void;
        private _defaultConstructor2;
        /**
         * basis settings for a crontrol will set.
         * element, base css class, disposeable
         * @param element The DOM element that will host the control.
         * @param name the control name, used for registration
         * @param className the standard css class name for this control
         * @param elementType? the HTML element type, default is "DIV", when no element is given as parameter, a new element of this type will be create
        **/
        baseSettings(element: VWElement, name: string, className: string, elementType?: string): void;
        /** @ignore */
        processElements(elements: any[]): any | null;
        initializeChilds(addElements?: HTMLElement[]): Promise<any> | null;
        /**
         * a property or a member will be observe
         * @param name name of the property or member.
         * @param handler handler that will be call at a value change to the observable object
        **/
        private _observeHandler;
        /**
         * remove the observe as a object
         * @param name name of the property or member.
         * @param handler handler that will be call at a value change to the observable object
        **/
        private _changeLanguageBase;
        getColor(propertyName: string): string;
        setColor(propertyName: string, styleName?: string, elementName?: string, controlElement?: string): string;
        /**
            * Methode addPropertyList
            * fügt den Resource Listen "optionList" und "eventList" neue Properties aus
            * aus einer statischen Liste hinzu.
            * @param val statische Liste die den resource Listen hingefügt wird.
        **/
        addPropertyList(base: any, val: any): void;
        addEventListener(type: string, listener: any, useCapture?: boolean): void;
        dispatchEvent(type: any, details: any): any;
        removeEventListener(type: any, listener: any, useCapture?: any): void;
        getStyleProperty(name: string): any;
        /**
         * remove a control as the VisiWin Control pattern.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
        private setPropertyInfo;
        private getResourceValue;
        private toCamelCase;
        private msType2vwType;
        private dispatchUpdateBase;
        private getPredictProperty;
        private getEventList;
        private getEventItem;
        private _updateLayoutTimerId;
        private _basedOnBase;
        private _changeMediaArgs;
        private _updateColorTimerId;
        private createProviderBaseHandler;
        private removeProviderBaseHandler;
        private addDisposeList;
        private _changeMediaBase;
        private _changeColorBase;
        private _getThemeResource;
        private _getColorResource;
        private _getBackgroundResource;
        private _getAnimationResource;
        private _getShadowResource;
        private __m;
        private __t;
        private __c;
        private __b;
        private __a;
        private __s;
        getThemeColor(value: string, name?: any): string;
        /** @ignore */
        getStyleNameFromType(controlName: string): string[];
        /** @ignore */
        getOptionsValue(extendFlag: boolean): any[];
        /** @ignore */
        private getOptionsList;
        /**
        * Internal do not use
        * @internal
        */
        private toCssName;
        /**
        * Internal do not use
        * @internal
        */
        private getOptionsListProperty;
        /**
        * Internal do not use
        * @internal
        */
        private calculatedStyle;
        /**
        * Internal do not use
        * @internal
        */
        private getStyle;
    }
}
declare module VisiWin.UI {
    class CurrentAlarmProvider extends VisiWin.UI.ProviderBase {
        static namespace: string;
        static controlName: string;
        static propertyList: {
            sampleDataLoaded: {
                propertyType: string;
            };
            alarmItemChange: {
                propertyType: string;
            };
            sampleData: {
                propertyType: string;
            };
            desiredClasses: {
                propertyType: string;
            };
            desiredGroups: {
                propertyType: string;
            };
            desiredStates: {
                propertyType: string;
            };
            maxPriority: {
                propertyType: string;
            };
            minPriority: {
                propertyType: string;
            };
            sortMode: {
                propertyType: string;
            };
        };
        requestID: string;
        currentAlarmList: any;
        private _initObserve;
        private _alarmService;
        private _currentAlarm;
        private _currentAlarmFilter;
        /**
         * Properties: active...   inactiv... activack... inactiveack...
         * These properties will set binding datas for the alarm item template.
         * The alarmItem Properties:
         *	   alarmRow.stateText, alarmRow.stateBackgroundColor, alarmRow.stateForegroundColor, alarmRow.stateSymbol
         * can bind in the template. It depends on the "alarmState" according to the prefix property name.
        **/
        activeText: string;
        activeBackgroundColor: string;
        activeForegroundColor: string;
        activeSymbol: string;
        activeTag: any;
        inactiveText: string;
        inactiveBackgroundColor: string;
        inactiveForegroundColor: string;
        inactiveSymbol: string;
        inactiveTag: any;
        activeackText: string;
        activeackBackgroundColor: string;
        activeackForegroundColor: string;
        activeackSymbol: string;
        activeackTag: any;
        inactiveackText: string;
        inactiveackBackgroundColor: string;
        inactiveackForegroundColor: string;
        inactiveackSymbol: string;
        inactiveackTag: any;
        /**
         * Property: sampleData.
         * Setting the sampleData will loading a file with some sample alarm data.
         * This is use at design time.
         * When finished loading the sample data, event will dispatch: "sampleDataLoaded"
        **/
        private _sampleData;
        set sampleData(val: string);
        get sampleData(): string;
        /**
          * Property: desiredClasses
          * A Filer for the alarmlist.
          * Alarm will be add to alarm list when class of alarm item is the array from desiredClasses.
          * Setting the filter will new initialize the alarmsystem.
         **/
        private _desiredClasses;
        private _desiredClassesArray;
        set desiredClasses(val: any);
        get desiredClasses(): any;
        /**
         * Property: desiredGroups
         * A Filer for the alarmlist.
         * Alarm item will be add to alarm list when historical group of alarm item is the array from desiredGroups.
         * Setting the filter will new initialize the alarmsystem.
        **/
        private _desiredGroups;
        private _desiredGroupsArray;
        set desiredGroups(val: any);
        get desiredGroups(): any;
        /**
         * Property: desiredStates
         * A Filer for the alarmlist.
         * Alarm will be add to alarm list when historical state of alarm item is the array from desiredStates.
         * Setting the filter will new initialize the alarmsystem.
        **/
        private _desiredStates;
        private _desiredStatesArray;
        set desiredStates(val: any);
        get desiredStates(): any;
        /**
         * Property: maxPriority
         * A Filer for the alarmlist.
         * Alarm will be add to alarm list when current prority of alarm item is between minPriority ans maxPrioriry.
         * Setting the filter will new initialize the alarmsystem.
         * If the value equal -1, the priotity filter is off.
        **/
        private _maxPriority;
        set maxPriority(val: number);
        get maxPriority(): number;
        /**
         * Property: minPriority
         * A Filer for the alarmlist.
         * Alarm will be add to alarm list when current prority of alarm item is between minPriority ans maxPrioriry.
         * Setting the filter will new initialize the alarmsystem.
         * If the value equal -1, the priotity filter is off.
        **/
        private _minPriority;
        set minPriority(val: number);
        get minPriority(): number;
        private _sortMode;
        get sortMode(): string;
        set sortMode(value: string);
        /**
         * constructor: Creates a new CurrentAlarmProvider.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: VWElement, options: any);
        /**
         * constructorMethod: preCheck
         * @preCheck
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        preCheck(element: VWElement, options: any): number;
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        updateOnLanguageChanged(): void;
        updateOnThemeChange(): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        /**
         * constructorMethod: postSetOptions
         * @postSetOptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        afterInit(): void;
        insertSampleData(): void;
        private _mixProperties;
        _translateResource(alarmRow: any): void;
        private _orignalAlarms;
        private _currentAlarmChange;
        /**
         * public method: forceLayout
         * @forceLayout control will be refresh, new drawing, new connection to alarm system
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        _refresh(): void;
        private _filterAlarms;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call aber dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class HistoricalAlarmProvider extends VisiWin.UI.ProviderBase {
        static namespace: string;
        static controlName: string;
        static _counter: number;
        static propertyList: {
            sampleDataLoaded: {
                propertyType: string;
            };
            alarmItemChange: {
                propertyType: string;
            };
            updateAlarmListEvent: {
                propertyType: string;
            };
            sampleData: {
                propertyType: string;
            };
            desiredClasses: {
                propertyType: string;
            };
            desiredGroups: {
                propertyType: string;
            };
            desiredStates: {
                propertyType: string;
            };
            maxPriority: {
                propertyType: string;
            };
            minPriority: {
                propertyType: string;
            };
            maxDate: {
                propertyType: string;
            };
            minDate: {
                propertyType: string;
            };
            period: {
                propertyType: string;
                defaultValue: string;
            };
        };
        historicalAlarmList: WinJS.Binding.List<any>;
        private _historicalAlarmsFilter;
        private _historicalAlarmsService;
        private _historicalAlarms;
        dateAdd(date: any, interval: any, units: any): Date;
        dateSub(date: any, interval: any, units: any): Date;
        private _minDate;
        set minDate(val: any);
        get minDate(): any;
        private _maxDate;
        set maxDate(val: any);
        get maxDate(): any;
        private _period;
        set period(val: string);
        get period(): string;
        /**
         * Property: sampleData.
         * Setting the sampleData will loading a file with some sample alarm data.
         * This is use at design time.
         * When finished loadind the sample data, event will dispatch: "sampleDataLoaded"
        **/
        private _sampleData;
        set sampleData(val: string);
        get sampleData(): string;
        /**
          * Property: desiredClasses
          * A Filer for the alarmlist.
          * Alarm will be add to alarm list when class of alarm item is the array from desiredClasses.
          * Setting the filter will new initialize the alarmsystem.
         **/
        private _desiredClasses;
        private _desiredClassesArray;
        set desiredClasses(val: any);
        get desiredClasses(): any;
        /**
         * Property: desiredGroups
         * A Filer for the alarmlist.
         * Alarm item will be add to alarm list when historical group of alarm item is the array from desiredGroups.
         * Setting the filter will new initialize the alarmsystem.
        **/
        private _desiredGroups;
        private _desiredGroupsArray;
        set desiredGroups(val: any);
        get desiredGroups(): any;
        /**
         * Property: desiredStates
         * A Filer for the alarmlist.
         * Alarm will be add to alarm list when historical state of alarm item is the array from desiredStates.
         * Setting the filter will new initialize the alarmsystem.
        **/
        private _desiredStates;
        private _desiredStatesArray;
        set desiredStates(val: any);
        get desiredStates(): any;
        /**
         * Property: maxPriority
         * A Filer for the alarmlist.
         * Alarm will be add to alarm list when historical prority of alarm item is between minPriority ans maxPrioriry.
         * Setting the filter will new initialize the alarmsystem.
         * If the value equal -1, the priotity filter is off.
        **/
        private _maxPriority;
        set maxPriority(val: number);
        get maxPriority(): number;
        /**
         * Property: minPriority
         * A Filer for the alarmlist.
         * Alarm will be add to alarm list when current prority of alarm item is between minPriority ans maxPrioriry.
         * Setting the filter will new initialize the alarmsystem.
         * If the value equal -1, the priotity filter is off.
        **/
        private _minPriority;
        set minPriority(val: number);
        get minPriority(): number;
        updateAlarmList(args?: any): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        /**
         * constructor: Creates a new CurrentAlarmsProvider.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(element: VWElement, options: any): void;
        removeHandler(): void;
        updateOnLanguageChanged(): void;
        updateOnThemeChange(): void;
        insertSampleData(): void;
        private _mixProperties;
        _translateResource(alarmRow: any): void;
        private _historicalAlarmsChange;
        private _historicalAlarmsSample;
        _refresh(): void;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call aber dispose
        **/
        dispose(): boolean;
        _createRequestId(): string;
    }
}
declare module VisiWin.UI {
    class RecipeProvider extends VisiWin.UI.ProviderBase {
        static namespace: string;
        static controlName: string;
        static propertyList: {
            recipeFileUpdate: {
                propertyType: string;
            };
            recipeClassList: {
                propertyType: string;
            };
            recipeFileList: {
                propertyType: string;
            };
            aktRecipeClass: {
                propertyType: string;
            };
            aktRecipeFileList: {
                propertyType: string;
            };
            listViewId: {
                propertyType: string;
            };
        };
        listViewId: string;
        aktRecipeFileList: string;
        private _recipeService;
        private _currentRecipeClass;
        private _recipeClassList;
        private _recipeClassArray;
        set recipeClassList(value: any);
        get recipeClassList(): any;
        private _recipeFileList;
        recipeFileArray: any;
        set recipeFileList(value: any);
        get recipeFileList(): any;
        /**
         * constructor: Creates a new RecipeProvider.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        updateOnLanguageChanged(): void;
        updateOnThemeChange(): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        setRecipeClassName(value: any): void;
        _setRecipeClass(value: any): Promise<void>;
        transferRecipeBufferToFile(name: string, description?: string): Promise<boolean>;
        transferRecipeBufferToSPS(): Promise<boolean>;
        transferRecipeFileToBuffer(name: string): Promise<boolean>;
        transferRecipeFileToSPS(name: string): Promise<boolean>;
        transferRecipeSPSToBuffer(): Promise<boolean>;
        deleteRecipeFile(name: string): Promise<boolean>;
        /**
         * constructorMethod: postSetOptions
         * @postSetOptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        afterInit(): Promise<void>;
        insertSampleData(): void;
        /**
         * public method: forceLayout
         * @forceLayout control will be refresh, new drawing, new connection to recipe system
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        _refresh(): void;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call aber dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class VariableProvider extends VisiWin.UI.ProviderBase {
        static namespace: string;
        static controlName: string;
        static propertyList: {
            variableNameList: {
                propertyType: string;
                type: string;
            };
            variableList: {
                propertyType: string;
                type: string;
            };
        };
        private _varItems;
        /**
          * Property: desiredClasses
          * A Filer for the alarmlist.
          * Alarm will be add to alarm list when class of alarm item is the array from desiredClasses.
          * Setting the filter will new initialize the alarmsystem.
         **/
        private _variableNameList;
        private _variableNameArray;
        private _variableList;
        set variableNameList(value: any);
        get variableNameList(): any;
        get variableList(): any;
        /**
         * constructor: Creates a new CurrentAlarmProvider.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: VWElement, options: any);
        /**
         * constructorMethod: preCheck
         * @preCheck
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        preCheck(element: VWElement, options: any): number;
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        updateOnLanguageChanged(): void;
        updateOnThemeChange(): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        /**
         * constructorMethod: postSetOptions
         * @postSetOptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        afterInit(): void;
        /**
         * public method: forceLayout
         * @forceLayout control will be refresh, new drawing, new connection to alarm system
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        _refresh(): void;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call aber dispose
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    /** @ignore */
    interface IUpdateLayout {
        /**
        * @description Causes type. "property", "state", "status", "updateColor", "update", "eventProperty", "lifiCycle", "event"
        * @member { string } changeType
        */
        changeType: string;
        /**
        * @description Change name
        * @member { string } changeName
        */
        changeName?: string;
        /**
        * @description Contains the current value
        * @member { any } newValue
        */
        newValue?: any;
        /**
        * @description Contains the old value
        * @member { any } oldValue
        */
        oldValue?: any;
    }
    /** @ignore */
    interface IUpdateColors {
        /**
        * @description Causes type. "property", "state", "status", "updateColor", "update", "eventProperty", "lifiCycle", "event"
        * @member { string } changeType
        */
        changeType: string;
        /**
        * @description Change name
        * @member { string } changeName
        */
        changeName?: string;
        /**
        * @description Contains the current value
        * @member { any } newValue
        */
        newValue?: any;
        /**
        * @description Contains the old value
        * @member { any } oldValue
        */
        oldValue?: any;
    }
    /** @ignore */
    interface INotifyPropertyChanged {
        /**
        * @description Causes type. "property", "state", "status", "updateColor", "update", "eventProperty", "lifiCycle", "event"
        * @member { string } changeType
        */
        changeType: string;
        /**
        * @description Change name
        * @member { string } changeName
        */
        changeName?: string;
        /**
        * @description Contains the current value
        * @member { any } newValue
        */
        newValue?: any;
        /**
        * @description Contains the old value
        * @member { any } oldValue
        */
        oldValue?: any;
        sender?: IControlBase;
        eventName?: string;
    }
    /** @ignore */
    interface INotifyPropertyChanged {
        detail: any;
    }
    /** @ignore */
    type IOptionsLiteral = any;
}
declare namespace VisiWin.UI {
    /** @ignore */
    const WINCONTROL = "winControl";
    /**
    * @constant The default namespace for a control
    *  @type {string}
    */
    const DEFAULT_NAMESPACE = "VisiWin.UI";
    /**
    * @constant The default css class prefix
    *  @type {string}
    */
    const CSS_CLASSPREFIX = "vw";
    /**
    * @constant The action attribute
    *  @type {string}
    */
    const ATTRIB_DATA_WIN_ACTIONS = "data-win-actions";
    /**
    * @constant The options attribute
    * @type {string}
    */
    const ATTRIB_DATA_WIN_OPTIONS = "data-win-options";
    /**
    * @constant The control attribute
    *  @type {string}
    */
    const ATTRIB_DATA_WIN_CONTROL = "data-win-control";
    /**
    * @constant The ref attribute
    *  @type {string}
    */
    const ATTRIB_DATA_REF_CONTROL = "data-ref";
    /**
    * @constant The ref element attribute
    *  @type {string}
    */
    const ATTRIB_DATA_REF_ELEMENT = "data-ref-element";
}
/**
* @namespace
* @name VisiWin.UI
*/
declare namespace VisiWin.UI {
    interface IControlBase {
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.top|top}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } top
        **/
        top: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.bottom|bottom}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } bottom
        **/
        bottom: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.left|left}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } left
        **/
        left: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.right|right}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } right
        **/
        right: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.width|width}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } width
        **/
        width: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.minWidth|minWidth}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } minWidth
        **/
        minWidth: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.maxWidth|maxWidth}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } maxWidth
        **/
        maxWidth: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.height|height}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } height
        **/
        height: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.minHeight|minHeight}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } minHeight
        **/
        minHeight: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.maxHeight|maxHeight}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } maxHeight
        **/
        maxHeight: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.padding|padding}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } padding
        **/
        padding: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.margin|margin}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } margin
        **/
        margin: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.border|border}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } border
        **/
        border: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.background|background}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } background
        **/
        background: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.borderRadius|borderRadius}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } borderRadius
        **/
        borderRadius: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.borderStyle|borderStyle}.
        * @member { {@link VisiWin.UI.Enums.BorderStyle|borderStyle} } borderStyle
        **/
        borderStyle: Enums.BorderStyle;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.borderWidth|borderWidth}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } borderWidth
        **/
        borderWidth: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.boxShadow|boxShadow}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } shadow
        **/
        shadow: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.opacity|opacity}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } opacity
        **/
        opacity: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.flex|flex}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } flex
        **/
        flex?: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.flexShrink|flexShrink}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } flexShrink
        **/
        flexShrink?: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.flexGrow|flexGrow}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } flexGrow
        **/
        flexGrow?: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.flexBasis|flexBasis}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } flexBasis
        **/
        flexBasis?: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.visibility|visibility}.
        * @member { {@link VisiWin.UI.Enums.Visibility} } visibility
        **/
        visibility: Enums.Visibility;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.hover|hover}.
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } hover
        **/
        hover: boolean;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.focus|focus}.
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } focused
        **/
        focused: boolean;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.disabled|disabled}.
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } disabled
        **/
        disabled: boolean;
        /**
        * CSS transform property
        * @see {@link VisiWin.UI.CSSProperties.scale|scale}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } scale
        **/
        scale: string;
        /**
        * @description Returns the DOM element that hosts the Control.
        * @member { VWElement | null } element
        */
        element: VWElement;
        /**
        * Element property
        * @see {@link VisiWin.UI.ElementProperties.className|className}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } top
        **/
        className: string;
        /**
        * @method addEventListener
        * @description The addEventListener method attaches an event handler to the specified element.
        * @param { string } type
        * @param { any } listener
        * @param { boolean } useCapture
        */
        addEventListener(type?: string, listener?: any, useCapture?: boolean): void;
        /**
        * @method removeEventListener
        * @description The removeEventListener method removes an event handler from the specified element.
        * @param { string } type
        * @param { any } listener
        * @param { boolean } useCapture
        */
        removeEventListener(type?: string, listener?: any, useCapture?: boolean): void;
        /**
        * @description Gets or sets the style for the control
        * @member { string } style
        */
        style: string;
        /**
        * @description The control instance for the HTML element.
        * @member { any} winControl
        */
        winControl?: any;
        /**
        * @description The Control Name without namespace
        * @member { string } __VWCONTROL__
        */
        __VWCONTROL__: string;
        /**
        * @description Returns the parent element.
        * @member { HTMLElement } parentElement
        */
        parentElement: HTMLElement;
        /**
        * @description Returns the parent control.
        * @member { VWElement } parentControl
        */
        parentControl: VWElement;
        /**
        * @description Returns the control name without namespace
        * @member { string } controlName
        */
        controlName: string;
        /**
        * @description Returns the controlId
        * The HTML id from the corresponding HTML Element.
        * @member { string } controlId
        */
        controlId: string;
        /**
        * @description Returns the namespace for the control
        * @member { string } namespace
        */
        namespace: string;
        /** @ignore */
        locService: VisiWin.AppServices.ILanguageService;
        /** @ignore */
        appService: VisiWin.AppServices.Impl.AppService;
        /**
        * @description Gets or sets the authorization mode for the control
        * @member {@link VisiWin.UI.Enums.AuthorizationMode|authorizationMode } authorizationMode
        */
        authorizationMode: VisiWin.UI.Enums.AuthorizationMode;
        /**
        * @description Wether the user is authorized
        * @member { boolean } authorized
        */
        authorized: boolean;
        /**
        * @description Returns the current right name
        * @member { string } authorizationRight
        */
        authorizationRight: string;
        /**
        * @method attach
        * @description Adds the element to the DOM
        * @returns { Promise<any> | null }
        */
        attach(): Promise<any> | null;
        /**
        * @method detach
        * @description Detaches the element from the DOM
        * @returns { Promise<any> | null }
        */
        detach(): Promise<any> | null;
        /**
        * @method dispose
        * @description Removes the control
        * true when the control is disposed, false if the control already is disposed.
        * @returns { boolean }
        */
        dispose(): boolean;
        /**
        * @method initializeChilds
        * @description Process all chid elements for the given elements
        * @param {VWElement[]} addElements
        * @returns {Promise<any> | null}
        */
        initializeChilds(addElements?: HTMLElement[], userControl?: boolean, isInEditMode?: boolean): Promise<any> | null;
        /**
        * @method getThemeColor
        * @description Returns the color string
        * @param { string } value
        * @param { string } name
        * @returns {string}
        */
        getThemeColor(value?: string, name?: any): string;
        /**
        * @method getColor
        * @description Returns the color string
        * @param { string } propertyName
        * @returns {string}
        */
        getColor(propertyName?: string): string;
        /**
        * @method setColor
        * @description Sets the color string
        * @param { string } propertyName
        * @param { string } styleName
        * @param { string } elementName
        * @param { string } controlElement
        * @returns {string}
        */
        setColor(propertyName?: string, styleName?: string, elementName?: string, controlElement?: string): string | null;
        /**
        * @method dispatchEvent
        * @description Dispatches an Event at the specified target
        * @param { string } type
        * @param { any } details
        * @returns { boolean }
        */
        dispatchEvent(type?: string, details?: any): boolean;
        /**
        * @method createTemplate
        * @description Part of the control life cycle.
        *
        * Is called from ControlBase, after the constructor method
        * @param { VWElement | null } element
        * @param { any } options
        * @returns {Promise<any> | null}
        */
        createTemplate?(element?: VWElement, options?: any): Promise<any> | null;
        /**
        * @method _updateLayout
        * @description Part of the control life cycle.
        *
        * Indicates that a property has changed
        * @param { VisiWin.UI.IUpdateLayout } changeArgs
        */
        _updateLayout?(changeArgs?: VisiWin.UI.IUpdateLayout): void;
        /**
        * @method _updateColors
        * @description Part of the control life cycle.
        *
        * Indicates that a color property has changed
        * @param { VisiWin.UI.IUpdateColors } changeArgs
        */
        _updateColors?(changeArgs?: VisiWin.UI.IUpdateColors): void;
        /**
        * @description Returns the controlType of the Control.
        *
        * This is the content of the attribute "data-win-control"
        * @member { string } controlType
        */
        controlType: string;
        /**
        * @description Returns the type of the Control.
        *
        * Defaultvalue: "Control";
        * Valid values:
        * "Control"       normal UI controls
        * "ControlPanel", normal UI controls, in the Content can place other controls
        * "Layout"        spezial layout control, arrange control in the content
        * "Provider"      data control without UI, work with data and export it
        * @member { string } designerType
        */
        designerType: string;
        /**
         * Implements the VisiWin UI Control Pattern
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
         * @param controlName the control name, used for registration
         * @param className the standard css class name for this control
         * @param elementType? the HTML element type, default is "DIV", when no element is given as parameter, a new element of this type will be create
        **/
        /** @ignore */
        inlineOptions: any;
        /** @ignore */
        inputEventsEnable: boolean;
        /** @ignore */
        resourceName: string;
        /** @ignore */
        updateLayoutEnable(value: boolean, changeType?: string, changeName?: string): void;
        /**
         * basis settings for a crontrol will set.
         * element, base css class, disposeable
         * @param element The DOM element that will host the control.
         * @param name the control name, used for registration
         * @param className the standard css class name for this control
         * @param elementType? the HTML element type, default is "DIV", when no element is given as parameter, a new element of this type will be create
        **/
        /** @ignore */
        baseSettings(element: VWElement, name: string, className: string, elementType?: string): void;
        /** @ignore */
        addPropertyList(obj: any, list: any): void;
        /** @ignore */
        defaultConstructor(element: VWElement, options: any, controlName: string, className: string, elementType?: string): any;
        /** @ignore */
        /** @ignore */
        registerChild?(cName: any, cAction: any, cElement: any, cOptions: any): boolean;
        /** @ignore */
        registerSourceId: string;
        /** @ignore */
        registerTargetId: string;
        /** @ignore */
        blockAction: boolean;
    }
}
declare module VisiWin.UI {
    /**
    * @class
    * @name VisiWin.UI.ControlBase
    * @description Base Class for all VisiWin.UI controls.
    * @memberof VisiWin.UI
    */
    abstract class ControlBase implements IControlBase {
        /** @ignore */
        static controlName: string;
        /** @ignore */
        static className: string;
        /** @ignore */
        static classHide: string;
        /** @ignore */
        static classDisabled: string;
        /** @ignore */
        static attributDisabled: string;
        /** @ignore */
        static classFocused: string;
        /** @ignore */
        static classCollapsed: string;
        /** @ignore */
        static classHover: string;
        /** @ignore */
        static classUnauthorized: string;
        /** @ignore */
        static supportedForProcessing: boolean;
        /** @ignore */
        static loaded: boolean;
        /** @ignore */
        static controlBasePropertyList: {
            click: {
                propertyType: string;
            };
            down: {
                propertyType: string;
            };
            up: {
                propertyType: string;
            };
            enablePreventEvents: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            notifyPropertyChanged: {
                propertyType: string;
            };
            disabledChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            visibilityChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            focusedChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            hoverChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            attached: {
                propertyType: string;
            };
            detached: {
                propertyType: string;
            };
            initialized: {
                propertyType: string;
            };
            element: {
                propertyType: string;
                type: string;
                invisible: boolean;
            };
            gridArea: {
                propertyType: string;
                type: string;
            };
            resourceName: {
                propertyType: string;
                access: string;
            };
            controlType: {
                propertyType: string;
                access: string;
            };
            controlName: {
                propertyType: string;
            };
            designerType: {
                propertyType: string;
            };
            dataContext: {
                propertyType: string;
                type: string;
            };
            style: {
                propertyType: string;
                defaultValue: string;
            };
            controlId: {
                propertyType: string;
            };
            classNames: {
                propertyType: string;
            };
            tag: {
                propertyType: string;
                type: string;
                invisible: boolean;
            };
            actionType: {
                propertyType: string;
                access: string;
            };
            triggerCollection: {
                propertyType: string;
                type: string;
                invisible: boolean;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
            };
            registerTargetId: {
                propertyType: string;
                type: string;
            };
            visibility: {
                propertyType: string;
                type: string;
            };
            top: {
                propertyType: string;
                type: string;
            };
            bottom: {
                propertyType: string;
                type: string;
            };
            left: {
                propertyType: string;
                type: string;
            };
            right: {
                propertyType: string;
                type: string;
            };
            width: {
                propertyType: string;
                type: string;
            };
            minWidth: {
                propertyType: string;
                type: string;
            };
            maxWidth: {
                propertyType: string;
                type: string;
            };
            height: {
                propertyType: string;
                type: string;
            };
            minHeight: {
                propertyType: string;
                type: string;
            };
            maxHeight: {
                propertyType: string;
                type: string;
            };
            padding: {
                propertyType: string;
                type: string;
            };
            margin: {
                propertyType: string;
                type: string;
            };
            flex: {
                propertyType: string;
                type: string;
            };
            flexShrink: {
                propertyType: string;
                type: string;
            };
            flexGrow: {
                propertyType: string;
                type: string;
            };
            flexBasis: {
                propertyType: string;
                type: string;
            };
            opacity: {
                propertyType: string;
                type: string;
            };
            borderStyle: {
                propertyType: string;
                type: string;
            };
            borderWidth: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
            };
            borderRadius: {
                propertyType: string;
                type: string;
            };
            scale: {
                propertyType: string;
                type: string;
            };
            authorizationMode: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            authorized: {
                propertyType: string;
                type: string;
            };
            authorizationRight: {
                propertyType: string;
                type: string;
            };
            disabled: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            shadow: {
                propertyType: string;
                style: string;
                resourceValue: string[];
            };
            background: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            backgroundImage: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
        };
        element: VWElement;
        /** @ignore */
        gridArea: string;
        controlName: string;
        className: string;
        namespace: string;
        designerType: string;
        /** @ignore */
        tag: any;
        /** @ignore */
        registerTargetId: string;
        top: string;
        bottom: string;
        left: string;
        right: string;
        width: string;
        minWidth: string;
        maxWidth: string;
        height: string;
        minHeight: string;
        maxHeight: string;
        padding: string;
        margin: string;
        background: string;
        backgroundImage: string;
        border: string;
        borderRadius: string;
        borderStyle: Enums.BorderStyle;
        flex: string;
        shadow: string;
        opacity: string;
        triggerCollection: any;
        private _isUserControl;
        private _changeMediaArgs;
        private _firstAttach;
        private _boundFocusOn;
        private _boundFocusOff;
        private _boundAuthHandler;
        private _authObj;
        /** @ignore */
        mutationElement: string;
        /** @ignore */
        resizedElement: string;
        /** @ignore */
        maxInterrations: number;
        __VWCONTROL__: string;
        /** @ignore */
        optionsList: any[];
        /** @ignore */
        eventList: any[];
        /** @ignore */
        childElements: any[];
        /** @ignore */
        childControls: any[];
        /** @ignore */
        arrayObjects: any[];
        /** @ignore */
        inlineOptions: any;
        /** @ignore */
        _varBinding: {};
        /** @ignore */
        themeChangeProperties: {};
        /** @ignore */
        _disposed: boolean;
        private _listeners;
        private _observeListenerList;
        private _mutationObserver;
        private _resizeObserver;
        private _pointerEventsArgs;
        private _currentPage;
        enablePreventEvents: boolean;
        returnPreventDefaults(event: any): any;
        private _boundHoverIn;
        private _hoverIn;
        private _boundHoverOut;
        private _hoverOut;
        private _boundPointerUpBase;
        private _pointerUpHandlerBase;
        private _boundPointerDownHandlerBase;
        private _pointerDownHandlerBase;
        private _boundPointerClickUpBase;
        private _pointerClickUpHandlerBase;
        private _boundPointerClickHandlerBase;
        private _pointerClickHandlerBase;
        /** @ignore */
        boundPreventEvent: any;
        private _preventEvent;
        private _initHandler;
        private _removeHandler;
        private _boundResizeHandlerDesignMode;
        private _boundResizeHandlerRunMode;
        private _boundResizeHandler;
        private _boundMutationHandlerDesignMode;
        private _boundMutationHandlerRunMode;
        private _boundMutationHandler;
        private _boundObserveHandler;
        private _boundChangeLanguageBase;
        private _boundChangeColorBase;
        private _boundChangeMediaBase;
        /** @ignore */
        static _mixinList: any[];
        /** @ignore */
        static _disposeList: any[];
        /** @ignore */
        inputEventsEnable: boolean;
        /** @ignore */
        isInDesignMode: boolean;
        /** @ignore */
        isInRunMode: boolean;
        /** @ignore */
        cssClassPrefix: string;
        private _borderWidth;
        /**
        * Set the borderWidth
        * @see {@link VisiWin.UI.CSSProperties.borderWidth|borderWidth}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } borderWidth
        **/
        set borderWidth(value: string);
        /**
        * Get the borderWidth
        * @see {@link VisiWin.UI.CSSProperties.borderWidth|borderWidth}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } borderWidth
        **/
        get borderWidth(): string;
        private _disabled;
        set disabled(value: boolean);
        get disabled(): boolean;
        private _visibilityDisplay;
        private _visibility;
        get visibility(): Enums.Visibility;
        set visibility(value: Enums.Visibility);
        private _authorizationMode;
        get authorizationMode(): Enums.AuthorizationMode;
        set authorizationMode(value: Enums.AuthorizationMode);
        private _authorized;
        get authorized(): boolean;
        set authorized(value: boolean);
        /** @ignore */
        _authHandler(e: any): void;
        private _authorizationRight;
        get authorizationRight(): string;
        set authorizationRight(value: string);
        private _hover;
        get hover(): boolean;
        set hover(value: boolean);
        private _focusOn;
        private _focusOff;
        private _focused;
        get focused(): boolean;
        set focused(value: boolean);
        private _scale;
        get scale(): string;
        set scale(value: string);
        private _dataContext;
        /** @ignore */
        set dataContext(name: string);
        /** @ignore */
        get dataContext(): string;
        private _parentElement;
        /** @ignore */
        get parentElement(): VWElement;
        private _parentControl;
        /** @ignore */
        get parentControl(): any;
        private _resourceName;
        get resourceName(): string;
        set resourceName(val: string);
        private _controlType;
        get controlType(): string;
        set controlType(val: string);
        private _classNames;
        /** @ignore */
        get classNames(): string;
        /** @ignore */
        set classNames(value: string);
        private _actionType;
        /** @ignore */
        get actionType(): string;
        /** @ignore */
        set actionType(value: string);
        private _style;
        private _resultStyle;
        get style(): string;
        set style(value: string);
        private _controlId;
        get controlId(): string;
        set controlId(value: string);
        private _registerSourceId;
        /** @ignore */
        set registerSourceId(value: string);
        /** @ignore */
        get registerSourceId(): string;
        private _blockAction;
        /** @ignore */
        get blockAction(): boolean;
        /** @ignore */
        set blockAction(val: boolean);
        /** @ignore */
        get navigationService(): VisiWin.AppServices.Impl.NavigationService;
        /** @ignore */
        set navigationService(val: VisiWin.AppServices.Impl.NavigationService);
        /** @ignore */ get locService(): VisiWin.AppServices.ILanguageService;
        /** @ignore */
        set locService(val: VisiWin.AppServices.ILanguageService);
        /** @ignore */ get langService(): VisiWin.AppServices.ILanguageService;
        /** @ignore */
        set langService(val: VisiWin.AppServices.ILanguageService);
        /** @ignore */
        get appService(): VisiWin.AppServices.Impl.AppService;
        /** @ignore */
        set appService(val: VisiWin.AppServices.Impl.AppService);
        /**
        * Creates a new ControlBase Control
        * @constructor
        * @param {VWElement} element The DOM element that will host the control.
        * @param {any} options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: VWElement, options: any);
        private eventHandlerEnabled;
        /** @ignore */
        private createControlBaseHandler;
        /** @ignore */
        private removeControlBaseHandler;
        private _updateLayoutEnable;
        /** @ignore */
        updateLayoutEnable(value: boolean, changeType?: string, changeName?: string): void;
        /** @ignore */
        initializedBase(element: VWElement): void;
        /** @ignore */
        readyBase(element: VWElement): void;
        private _isAttached;
        /** @ignore */
        get isAttached(): boolean;
        /** @ignore */
        set isAttached(value: boolean);
        attach(): Promise<any> | null;
        detach(): Promise<any> | null;
        /** @ignore */
        private registerAtParent;
        /** @ignore */
        private unregisterAtParent;
        private mixProperties;
        private setMediaOptions;
        private setDefaultOptions;
        private setColorOptions;
        private setLangOptions;
        /** @ignore */
        dispatchNotifyPropertyChanged(changeType: string, changeName: string, newValue: any, oldValue: any, addEvent?: string, args?: any): void;
        /** @ignore */
        updateLayout(name?: string): void;
        /** @ignore */
        updateColors(name?: string): void;
        private _updateLayoutWork;
        /** @ignore */
        _updateLayoutBase(changeType: any, changeName?: string, newValue?: any, oldValue?: any): void;
        private _updateColorWork;
        /** @ignore */
        _updateColorsBase(changeType: any, changeName?: string, newValue?: any, oldValue?: any): void;
        /** @ignore */
        private setOptionListProperties;
        /** @ignore */
        private getOptionListDefault;
        /** @ignore */
        defaultConstructor(element: VWElement, options: any, controlName: string, className: string, elementType?: string): void;
        private _defaultConstructor2;
        /** @ignore */
        baseSettings(element: VWElement, name: string, className: string, elementType?: string): void;
        /** @ignore */
        initialize(control: any, controlOptions?: any): void;
        /** @ignore */
        processElements(elements: any[]): any | null;
        initializeChilds(addElements?: HTMLElement[], userControl?: boolean, isInEditMode?: boolean): Promise<any> | null;
        _initializeChilds(addElements?: HTMLElement[]): Promise<any> | null;
        private _observeHandler;
        private _changeLanguageBase;
        getColor(propertyName: string): string;
        setColor(propertyName: string, styleName?: string, elementName?: string | null, controlElement?: string): string | null;
        private _changeMediaBase;
        private _changeColorBase;
        /** @ignore */
        addDisposeList(methode: string): void;
        /** @ignore */
        addPropertyList(base: any, propertyList?: any, cssval?: any): boolean;
        /** @ignore */
        createStyles(control: any, styleString: any): boolean;
        addEventListener(type: string, listener: any, useCapture?: boolean): void;
        dispatchEvent(type: any, details: any): boolean;
        removeEventListener(type: any, listener: any, useCapture?: any): void;
        private _processActions;
        /** @ignore */
        getStyleProperty(name: string): any;
        /** @ignore */
        reparentChildren(originalParent: any, destinationParent: any): void;
        /** @ignore */
        detachSubTree(element: any, rootElementFlag?: boolean): void;
        /** @ignore */
        attachSubTree(element: any, rootElementFlag?: boolean): void;
        /** @ignore */
        initializeSubTree(element: VWElement, rootElementFlag?: boolean): void;
        /** @ignore */
        readySubTree(element: VWElement, rootElementFlag?: boolean): void;
        /** @ignore */
        disposeSubTree: (element: VWElement, rootElementFlag?: boolean) => void;
        /** @ignore */
        verifyShowProperty(name: string): boolean;
        /** @ignore */
        get isDisposed(): boolean;
        /** @ignore */
        set isDisposed(value: boolean);
        dispose(): boolean;
        private getResourceValue;
        private toCamelCase;
        private msType2vwType;
        private dispatchUpdateBase;
        private getPredictProperty;
        private getEventList;
        private getEventItem;
        private _getThemeResource;
        private _getColorResource;
        private _getBackgroundResource;
        private _getAnimationResource;
        private _getShadowResource;
        private __m;
        private __t;
        private __c;
        private __b;
        private __a;
        private __s;
        getThemeColor(value: string, name?: any): string;
        /** @ignore */
        getOptionsValue(): any[];
        /** @ignore */
        getActionPropertyList(triggerIndex: any, actionIndex: any): any;
        /** @ignore */
        getTriggerPropertyList(triggerIndex: any): any;
        /** @ignore */
        getStyleNameFromType(controlName: string): string[];
        /** @ignore */
        private getOptionsList;
        /**
        * Internal do not use
        * @internal
        */
        private getOptionsListProperty;
        /**
        * Internal do not use
        * @internal
        */
        private getOptionsDefaultValue;
        /**
        * Internal do not use
        * @internal
        */
        private calculatedStyle;
        /**
        * Internal do not use
        * @internal
        */
        private getStyle;
        /**
        * Internal do not use
        * @internal
        */
        private toCssName;
    }
}
declare module VisiWin.UI {
    interface IVariableBase extends IControlBase {
        /**
         * variableName    property / option
         * legt die VisiWin Variable Fest die angemeldet werden soll.
         * War zuvor eine Varable angemeldet, so wird diese zuvor detach und abgemeldet.
         * Intern wird ein Event Handler auf Veränderungen der Variable angemeldet.
         * Dadurch werden einige Properties des VariablenBase automatisch verändert:
         *      value, bitValue
         * Soll die Variable abgemeldet und keine neue angemeldet werden, so muss 'null'
         * als Parameter übergeben werden.
         * Datatype: string
         * Defaultvalue: null
        */
        variableName: string;
        /**
         * useVariableLimits    property / option
         * Die variablenBase Properties rawLimitMin und rawLimitMax werden von
         * den rawLimit Einträgen der verwendeten Variablen überschrieben.
         * Dieser Wert darf zur Laufzeit NICHT verändert werden.
         * Datatype: boolean
         * Defaultvalue: false
         */
        useVariableLimits: boolean;
        /**
         * value    property / option
         * Der Wert von value wird automatisch einer angemeldeten Variablen nachgeführt.
         * In Ihr wird der Einheiten Umgerechnete Wert durch den Variablen Event Handler eingetragen.
         * Zus#tzlich wird der option angegebene formatString zur darstellung ausgewertet.
         * Ein aufruf des Setters von value beschreibt NICHT automatisch die VisiWin Variable.
         * Je nach Datentype der Variabe kann sich der Datentype von value ändern.
         * Datatype: any
         * Defaultvalue: null
         */
        value: any;
        /**
         * bitValue    property / option
         * Wird zusätzlich zum variablenNamen noch eine bitNumber (Bitnummer) angegeben, so wird
         * hier der Wert der entsprechenen bitNumber wiedergegeben.
         * Datatype: boolean
         * Defaultvalue: null
         */
        bitValue: boolean;
        /**
         * useRawValue    property / option
         * Ist dieser Wert gesetzt, so wird im value nur der direkte Wert aus der Steuerung
         * dargestellt. Die Unitumrechnung und der FormatString wird nicht angewendet.
         * Datatype: boolean
         * Defaultvalue: false
         */
        useRawValue: boolean;
        /**
         * bitNumber    property / option
         * Ist dieser Wert gesetzt, so wird im value nur der direkte Wert aus der Steuerung
         * dargestellt. Die Unitumrechnung und der FormatString wird nicht angewendet.
         * Datatype: boolean
         * Defaultvalue: false
         */
        /**
         * formatString    property / option
         * Ist dieser Wert gesetzt, so wird der Wert value vor der Ausgabe Formatiert:
         *    Fx    Floatformatierung mit x Nachkommastellen
         *    Dx    Dezimalformatierung, Ausgabe mit minimum x Stellen, ggf werden führende Nullen einegesetzt
         * Datatype: boolean
         * Defaultvalue: false
         */
        formatString: string;
        /**
         * locFormatString    property / option
         * Sprachabhängig kann der formatString dynamisch geändert werden.
         * Bei einer Sprachumschaltung wird die übergebene TextID in den Sprachabhängigen
         * formatString gewandelt und in das Property formatString geschrieben.
         * Datatype: string
         * Defaultvalue: null
         */
        locFormatString: string;
        /**
         * unitText    property / option
         * Einheit der Variablen für die Darstellung.
         * Datatype: string
         * Defaultvalue: null
         */
        unitText: string;
        /**
         * locUnittext    property / option
         * Sprachabhängig kann die Einheit dynamisch geändert werden.
         * Bei einer Sprachumschaltung wird die übergebene TextID in den Sprachabhängigen
         * unitText gewandelt und in das Property unitText geschrieben.
         * Datatype: string
         * Defaultvalue: null
         */
        locUnitText: string;
        /**
         * useVariableUnitText    property / option
         * Ist dieses Property gesetzt, so wird der Text für die Einheitendarstellung
         * direkt der Varablen entnommen und in der Property unittext geschrieben.
         * Datatype: boolean
         * Defaultvalue: false
         */
        useVariableUnitText: boolean;
        /**
         * text    property / option
         * Beschreibungstext der Variablen zur Darstellung in der UI.
         * Dieser Text kann z.B. dem Variablenwert zur identifizierung vorrangestellt werden.
         * Datatype: string
         * Defaultvalue: null
         */
        text: string;
        /**
         * locText    property / option
         * Sprachabhängig kann der Text der Variablen dynamisch geändert werden.
         * Bei einer Sprachumschaltung wird die übergebene TextID in den Sprachabhängigen
         * Text gewandelt und in das Property text geschrieben.
         * Datatype: string
         * Defaultvalue: null
         */
        locText: string;
        /**
         * useVariableText    property / option
         * Ist dieses Property gesetzt, so wird der Text der Variablen
         * direkt der Variablen entnommen und in das Property "text" geschrieben.
         * Datatype: boolean
         * Defaultvalue: false
         */
        useVariableText: boolean;
        /**
         * Mixin Constructor Aufruf
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        /**
         * validateValue    method
         * Der aktuelle Wert der Variable kann mit einer VisiWin Status Tabelle verglichen werden.
         * Die Tabelle wird als Parameter übergeben, als Returnwert wird der ermittelte Wert der
         * Tabelle zurückgegeben.
         * @param valueToValidate string, Tabelle in Stringform als Arbeitsgrundlage.
         * @return boolean Wert der aus der Tabelle ermittelt wurde.
        **/
        validateValue(valueToValidate: string): boolean;
        /**
         * Calculates the formatted minimum limit with decimalplaces for numeric in and output controls
         * @param rawLimitMin rawLimit which is set in the control
         * @return number value that represents the formatted minimum Limit with decimalplaces
         */
        getFormattedMinValue(rawLimitMin: number): number;
        /**
         * Calculates the formatted maximum limit with decimalplaces for numeric in and output controls
         * @param rawLimitMax rawLimit which is set in the control
         * @return number value that represents the formatted maximum Limit with decimalplaces
         */
        getFormattedMaxValue(rawLimitMax: number): number;
    }
}
declare module VisiWin.UI {
    enum _VariableError {
        VARERR_None = 0,
        VARERR_NoConnection = 1,
        VARERR_NoRegister = 2,
        VARERR_NoAttach = 4,
        VARERR_LowQuality = 8,
        VARERR_WriteToServer = 16,
        VARERR_OverflowLimitMin = 32,
        VARERR_OverflowLimitMax = 64
    }
    abstract class VariableBase extends ControlBase implements IVariableBase {
        static controlName: string;
        static VariableBaseOptionsList: {
            formatTextChanged: {
                propertyType: string;
            };
            unitTextChanged: {
                propertyType: string;
            };
            textChanged: {
                propertyType: string;
            };
            labelTextChanged: {
                propertyType: string;
            };
            bitNrChanged: {
                propertyType: string;
            };
            valueChanged: {
                propertyType: string;
            };
            variableNameChanged: {
                propertyType: string;
            };
            valueError: {
                propertyType: string;
            };
            variableName: {
                propertyType: string;
                type: string;
            };
            canRecipeEdit: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            value: {
                propertyType: string;
                type: string;
            };
            rawValue: {
                propertyType: string;
                type: string;
            };
            useRawValue: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            bitValue: {
                propertyType: string;
                type: string;
            };
            bitNumber: {
                propertyType: string;
                type: string;
            };
            varRawLimitMin: {
                propertyType: string;
                type: string;
            };
            varRawLimitMax: {
                propertyType: string;
                type: string;
            };
            varLimitMin: {
                propertyType: string;
                type: string;
            };
            varLimitMax: {
                propertyType: string;
                type: string;
            };
            useVariableLimits: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            decimalPlaces: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            formatString: {
                propertyType: string;
                type: string;
            };
            locFormatString: {
                propertyType: string;
                type: string;
            };
            formattedValue: {
                propertyType: string;
                type: string;
            };
            bitCalculation: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            bitNumberSetLSB: {
                propertyType: string;
                type: string;
            };
            bitNumberSetMSB: {
                propertyType: string;
                type: string;
            };
            bitNumberSetCnt: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            text: {
                propertyType: string;
                type: string;
            };
            locText: {
                propertyType: string;
                type: string;
            };
            localizableText: {
                propertyType: string;
                type: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            unitText: {
                propertyType: string;
                type: string;
            };
            locUnitText: {
                propertyType: string;
                type: string;
            };
            localizableUnitText: {
                propertyType: string;
                type: string;
            };
            useVariableUnitText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            labelText: {
                propertyType: string;
                type: string;
            };
            locLabelText: {
                propertyType: string;
                type: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
            };
            showRemotePressed: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            font: {
                propertyType: string;
                type: string;
            };
            fontClassName: {
                propertyType: string;
                type: string;
            };
            fontClass: {
                propertyType: string;
                type: string;
            };
            fontFamily: {
                propertyType: string;
                type: string;
            };
            fontSize: {
                propertyType: string;
                type: string;
            };
            fontWeight: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            lineHeight: {
                propertyType: string;
                type: string;
            };
        };
        fontSize: string;
        lineHeight: string;
        rawValue: number;
        showRemotePressed: true;
        bitCalculation: boolean;
        bitNumber: number;
        bitNumberSetLSB: number;
        bitNumberSetMSB: number;
        bitNumberSetCnt: number;
        private _varProperty;
        private _sourceDecPoint;
        private _rawValue;
        private _numValue;
        private _isVariableAttached;
        private _variableType;
        private _jsType;
        _typeMin: number;
        _typeMax: number;
        private _service;
        private x;
        private currentUnit;
        private unitClass;
        private _block;
        private _variableName;
        private _propVariableName;
        _vwVariable: VisiWin.System.DataAccess.IVariable;
        _negFlag: boolean;
        _floatFlag: boolean;
        _dividerFlag: boolean;
        _eFlag: boolean;
        private _fromVarChangeHandler;
        private _boundLocFormatStringHandler;
        private _boundLocalizedTextChangedHandler;
        private _boundUnitClassChangeHandler;
        private _boundLoctextHandler;
        private _boundLocUnitTextHandler;
        private _boundLocLabelTextHandler;
        private _boundVariableChangeHandler;
        private _boundWriteValue;
        private _boundRecipeItemChangeHandler;
        private _canRecipeEdit;
        set canRecipeEdit(value: boolean);
        get canRecipeEdit(): boolean;
        private _isRecipeEditing;
        set isRecipeEditing(value: boolean);
        get isRecipeEditing(): boolean;
        private _resultDecimalPlaces;
        set resultDecimalPlaces(value: number);
        get resultDecimalPlaces(): number;
        private _decimalPlaces;
        get decimalPlaces(): number;
        set decimalPlaces(value: number);
        _font: any;
        get font(): string;
        set font(value: string);
        private _fontClass;
        private _fontClassName;
        /**
         * Get and set the fontClass of the control.
         * If set, the corrosponding Css fontclass will be set to the HTML Element.
         * In this Css Class is define the:
         *   font-family, font-size, font-weight, text-transform, line-height, letter-spacing, and opacity
         * Note: if the Application.Settings["HighContrastText"] is true, the opacity will be set always to "1.0"
         * Datatype: enum as string
         * Defaultvalue: null
         * Valid values:
         *      "display 4", "display 3", "display 2", "display 1", "headline", "title", "subheading",
         *      "subheading 2", "body 2", "body 1", "caption", "menu", "button", "button (all caps)", "label", "label1","label2","label3","label4"
        **/
        get fontClassName(): any;
        get fontClass(): any;
        set fontClass(value: any);
        private _fontWeight;
        set fontWeight(value: string);
        get fontWeight(): string;
        private _fontFamily;
        set fontFamily(value: string);
        get fontFamily(): string;
        private _unitClassChangeHandler;
        private _localizedTextChangedHandler;
        detachUpdate(item: any): void;
        detach(): Promise<any>;
        attachUpdate(item: any): void;
        attach(): Promise<any>;
        /**
         * variableName    property / option
         * legt die VisiWin Variable Fest die angemeldet werden soll.
         * War zuvor eine Varable angemeldet, so wird diese zuvor detach und abgemeldet.
         * Intern wird ein Event Handler auf Veränderungen der Variable angemeldet.
         * Dadurch werden einige Properties des VariablenBase automatisch verändert:
         *      value, bitValue
         * Soll die Variable abgemeldet und keine neue angemeldet werden, so muss 'null'
         * als Parameter übergeben werden.
         * Datatype: string
         * Defaultvalue: null
        */
        set variableName(value: string);
        get variableName(): string;
        private _varRawLimitMin;
        set varRawLimitMin(value: any);
        get varRawLimitMin(): any;
        private _varRawLimitMax;
        set varRawLimitMax(value: any);
        get varRawLimitMax(): any;
        private _varLimitMin;
        set varLimitMin(value: any);
        get varLimitMin(): any;
        private _varLimitMax;
        set varLimitMax(value: any);
        get varLimitMax(): any;
        private _useVariableLimits;
        /**
         * useVariableLimits    property / option
         * Die variablenBase Properties rawLimitMin und rawLimitMax werden von
         * den rawLimit Einträgen der verwendeten Variablen überschrieben.
         * Dieser Wert darf zur Laufzeit NICHT verändert werden.
         * Datatype: boolean
         * Defaultvalue: false
         */
        set useVariableLimits(value: boolean);
        get useVariableLimits(): boolean;
        private _formattedValue;
        set formattedValue(value: any);
        get formattedValue(): any;
        private __value;
        /**
         * value    property / option
         * Der Wert von value wird automatisch einer angemeldeten Variablen nachgeführt.
         * In Ihr wird der Einheiten Umgerechnete Wert durch den Variablen Event Handler eingetragen.
         * Zus#tzlich wird der option angegebene formatString zur darstellung ausgewertet.
         * Ein aufruf des Setters von value beschreibt NICHT automatisch die VisiWin Variable.
         * Je nach Datentype der Variabe kann sich der Datentype von value ändern.
         * Datatype: any
         * Defaultvalue: null
         */
        set value(value: any);
        get value(): any;
        set _value(val: any);
        get _value(): any;
        private _bitValue;
        /**
         * bitValue    property / option
         * Wird zusätzlich zum variablenNamen noch eine bitNumber (Bitnummer) angegeben, so wird
         * hier der Wert der entsprechenen bitNumber wiedergegeben.
         * Datatype: boolean
         * Defaultvalue: null
         */
        set bitValue(value: boolean);
        get bitValue(): boolean;
        private _useRawValue;
        /**
         * useRawValue    property / option
         * Ist dieser Wert gesetzt, so wird im value nur der direkte Wert aus der Steuerung
         * dargestellt. Die Unitumrechnung und der FormatString wird nicht angewendet.
         * Datatype: boolean
         * Defaultvalue: false
         */
        set useRawValue(value: boolean);
        get useRawValue(): boolean;
        private _formatString;
        /**
         * formatStrint    property / option
         * Ist dieser Wert gesetzt, so wird der Wert value vor der Ausgabe Formatiert:
         *    Fx    Floatformatierung mit x Nachkommastellen
         *    Dx    Dezimalformatierung, Ausgabe mit minimum x Stellen, ggf werden führende Nullen einegesetzt
         * Datatype: boolean
         * Defaultvalue: false
         */
        set formatString(value: string);
        get formatString(): string;
        private _locFormatString;
        private _locFormatObject;
        /**
         * locFormatString    property / option
         * Sprachabhängig kann der formatString dynamisch geändert werden.
         * Bei einer Sprachumschaltung wird die übergebene TextID in den Sprachabhängigen
         * formatString gewandelt und in das Property formatString geschrieben.
         * Datatype: string
         * Defaultvalue: null
         */
        private _locFormatStringHandler;
        set locFormatString(value: string);
        get locFormatString(): string;
        private _varUnitText;
        set varUnitText(value: string);
        get varUnitText(): string;
        private _unitText;
        /**
         * unitText    property / option
         * Einheit der Variablen für die Darstellung.
         * Datatype: string
         * Defaultvalue: null
         */
        set unitText(value: string);
        get unitText(): string;
        private _locUnitText;
        private _locUnitObject;
        /**
         * locUnittext    property / option
         * Sprachabhängig kann die Einheit dynamisch geändert werden.
         * Bei einer Sprachumschaltung wird die übergebene TextID in den Sprachabhängigen
         * unitText gewandelt und in das Property unitText geschrieben.
         * Datatype: string
         * Defaultvalue: null
         */
        private _locUnitTextHandler;
        set locUnitText(value: string);
        get locUnitText(): string;
        set localizableUnitText(value: string);
        get localizableUnitText(): string;
        private _useVariableUnitText;
        /**
         * useVariableUnitText    property / option
         * Ist dieses Property gesetzt, so wird der Text für die Einheitendarstellung
         * direkt der Varablen entnommen und in der Property unittext geschrieben.
         * Datatype: boolean
         * Defaultvalue: false
         */
        set useVariableUnitText(value: boolean);
        get useVariableUnitText(): boolean;
        private _varText;
        get varText(): any;
        set varText(value: any);
        private _text;
        /**
         * text    property / option
         * Beschreibungstext der Variablen zur Darstellung in der UI.
         * Dieser Text kann z.B. dem Variablenwert zur identifizierung vorrangestellt werden.
         * Datatype: string
         * Defaultvalue: null
         */
        set text(value: string);
        get text(): string;
        private _locText;
        private _locTextObject;
        private _loctextHandler;
        /**
         * locText    property / option
         * Sprachabhängig kann der Text der Variablen dynamisch geändert werden.
         * Bei einer Sprachumschaltung wird die übergebene TextID in den Sprachabhängigen
         * Text gewandelt und in das Property text geschrieben.
         * Datatype: string
         * Defaultvalue: null
         */
        set locText(value: string);
        get locText(): string;
        set localizableText(value: string);
        get localizableText(): string;
        private _labelText;
        set labelText(value: string);
        get labelText(): string;
        private _locLabelText;
        private _locLabeltextObject;
        private _locLabelTextHandler;
        set locLabelText(value: string);
        get locLabelText(): string;
        set localizableLabelText(value: string);
        get localizableLabelText(): string;
        private _useVariableText;
        /**
         * useVariableText    property / option
         * Ist dieses Property gesetzt, so wird der Text der Variablen
         * direkt der Varablen entnommen und in der Property text geschrieben.
         * Datatype: boolean
         * Defaultvalue: false
         */
        set useVariableText(value: boolean);
        get useVariableText(): boolean;
        constructor(element: VWElement, options: any);
        /**
         * validateValue    method
         * Der aktuelle Wert der Variable kann mit einer VisiWin Status Tabelle verglichen werden.
         * Die Tabelle wird als Parameter übergeben, als Returnwert wird der ermittelte Wert der
         * Tabelle zurückgegeben.
         * @param valueToValidate string, Tabelle in Stringform als Arbeitsgrundlage.
         * @return boolean Wert der aus der Tabelle ermittelt wurde.
        **/
        validateValue(valueToValidate: string): boolean;
        writeVariable(args: any): Promise<void>;
        private _exponent;
        get exponent(): boolean;
        set exponent(val: boolean);
        private _dezimalPoint;
        get dezimalPoint(): boolean;
        set dezimalPoint(val: boolean);
        private _setTypeProperties;
        private _isInteger;
        private _recipeItemChangeHandler;
        private _variableChangeHandler;
        value2rawValue(value: number): number;
        rawValue2value(value: number): any;
        calcValueWithUnitClass(value: any, multiplier: any): number;
        getFormattedMinValue(rawLimitMin: number): number;
        getFormattedMaxValue(rawLimitMax: number): number;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IButtonBase extends IVariableBase {
        /**
         * Gets / set the inderterminate property.
         * This is the "third" value for a checkbox.
         * If inderterminate is set, is has a higher priority as the checked status.
         * If indeterminate is false, checked show the tru of false state.
         * A css class indeterminate will be set to the control element when if it set.
         * The event "indetermnateChange" will be trigger when the value of indeterminate will change.
         * The event "notifyPropertyChanged" will also triggert.
         * Defaultvalue: false
        **/
        indeterminate: boolean;
        /**
         * Gets or set the checked property.
         * if the control a togglebutton, checked shows if the button activ / on.
         * A css class "checked" will be set to the control element when if it set.
         * The event "checkedCahnge" will be trigger when the value of checked will change.
         * The event "notifyPropertyChanged" will also triggert.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        checked: boolean;
        /**
         * pressed    property / option
         * Gets or set the pressed property.
         * the value of this property is thrue when the button is activ pressed with a pointer device.
         * A css class "pressed" will be set to the control element when if it set.
         * The event "pressedChange" will be trigger when the value of checked will change.
         * The event "notifyPropertyChanged" will also triggert.
         * The css class pressed will be set on the corrosponding HTML Element.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        pressed: boolean;
        actionHandler: any;
        /**
         * remoteActionHandler     Property
         * will be used when the button will be registert from a parent control.
         * In this property will be save the original action handler. The action handler
         * will be call a new action in the parent control. In this handler will be
         * be call the original action handler (saved in remoteActionhandler).
         * The remoteActionHandler will not be ised as options!
         * Datatype: handler
         * Defaultvalue: null
         */
        remoteActionHandler: any;
        /**
         * dragThreshold    Property / Option
         * get or set the dragThreshold property
         * If the dragThreshold is set, a move more pixel than the dragThreshold value
         * from the pointer device, will be disable the tap / click on a button.
         * The value 10 will be a good try when you will use this function.
         * At default, the value of this property is null, disable this function.
         * This function is usefull when "behind" the button is a scroll panel.
         * When the button identyfy a move from the ponter devices, the move will be
         * bubble to the next control were can be scroll the elements.
         * Datatype: number
         * Defaultvalue: null
         */
        dragThreshold: number;
        /**
         * toggle    Property
         * get or set the toggle property
         * If togghle is set, the button will be have two states: "true" "false"
         * It will be show in the checked property. One tap or click will be set
         * to true, the next tap or click will be reset to false.
         * If toggle is not set, checked will be not set wicth taps ot clicks.
         * Datatype: boolean
         * Defaultvalue: false
         */
        toggle: boolean;
        /**
         * radio    Property
         * get or set the radio property
         * If radio is set, the button will be work as a radioButton.
         * Checked Property will be set on tap or click. But it will be not retset
         * on the next tab / click. The Reset will be done by a main group control.
         * Datatype: boolean
         * Defaultvalue: false
         */
        radio: boolean;
        /**
         * checkbox    Property
         * get or set the checkbox property
         * If checkbox is the set, the main working is like as a togghleButton.
         * Addition the indeterminate property will be used.
         * Datatype: boolean
         * Defaultvalue: false
         */
        checkbox: boolean;
        /**
         * enablePreventEvents    Property
         * if enablePreventEvents is set, the bubbeling for the pointer events
         * will be disabled.
         * Datatype: boolean
         * Defaultvalue: false
         */
        enablePreventEvents: boolean;
        /**
         * pageName    property / option
         * Soll in der main action eine Navigation ausgeführt werden so muß in pageName das Ziel angegeben werden
         * mir regionId und target Propertie kann die Navigation beeinflusst werden.
         * Ist der wert null oder undefined so nicht navigiert.
         * Datatype: string
         * Defaultvalue: null
         */
        pageName: string;
        /**
         * pageOption    property / option
         * diess Object wird dem pageControl als option mitgegeben wenn zu einer neuen Seite navigiert wird.
         * So kann abhängig von den pageOptions die neue Seite beeinflusst werden.
         * Datatype: object
         * Defaultvalue: {}, leeres Object
         */
        pageOptions: any;
        /**
         * regionId    property / option
         * ist das property regionId gesetzt, so wird anstatt der default Navigation mit Navigator.navigate
         * das uri Property des angegebenen Controls gesetzt
         * Datatype: object
         * Defaultvalue: {}, leeres Object
         */
        regionId: string;
        /**
         * targetProperty    property / option
         * ist das targetProperty gesetzt, so wird anstatt der default Navigation mit Navigator.navigate
         * das angegebene Property im regionId
         * Datatype: object
         * Defaultvalue: {}, leeres Object
         */
        targetProperty: string;
        /**
         * Creates a new NavButtonBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        /**
         * Creates a new ButtonBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        /**
          * läd die neue Seite die in url angegeben ist in den pageNavigator.
          * Wird durch den default mainAction Handler ausgeführt.
          * Ist die regionId gesetzt, so wird alternativ die region mit der ID geladen.
          * nach dem navigieren wird ein Event "navigate" ausgeführt.
          * @navigate
          * @param url seitenadresse zu der navigiert werden soll, optional.
          *
         **/
        navigate(url: string): void;
        /**
         * remove the ButtonBase control.
         * all work will do in the dispose super class.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ButtonBase extends VariableBase implements IButtonBase {
        static controlName: string;
        static classPressed: string;
        static classChecked: string;
        static classUnchecked: string;
        static classIndeterminate: string;
        static ButtonBaseOptionsList: {
            interdetermintateChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            buttonclick: {
                propertyType: string;
                triggerDataName: string;
            };
            buttondown: {
                propertyType: string;
            };
            buttonup: {
                propertyType: string;
            };
            pressedChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            checkedChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            navigated: {
                propertyType: string;
                triggerDataValue: boolean;
            };
            navigateError: {
                propertyType: string;
            };
            indeterminate: {
                propertyType: string;
                type: string;
            };
            lastPointerAction: {
                propertyType: string;
                type: string;
            };
            checked: {
                propertyType: string;
                type: string;
                group: string;
            };
            pressed: {
                propertyType: string;
                type: string;
                group: string;
            };
            remoteActionHandler: {
                propertyType: string;
                type: string;
                invisible: boolean;
            };
            actionHandler: {
                propertyType: string;
                type: string;
                invisible: boolean;
            };
            dragThreshold: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            toggle: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            radio: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            key: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            checkbox: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            fastTap: {
                propertyType: string;
                type: string;
            };
            pageName: {
                propertyType: string;
                type: string;
            };
            viewName: {
                propertyType: string;
                type: string;
            };
            pageOptions: {
                propertyType: string;
                type: string;
                invisible: boolean;
                defaultValue: {};
            };
            regionId: {
                propertyType: string;
                type: string;
            };
            showLoadingSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            targetProperty: {
                propertyType: string;
                type: string;
            };
            textOn: {
                propertyType: string;
                type: string;
            };
            localizableTextOn: {
                propertyType: string;
                type: string;
            };
            textOff: {
                propertyType: string;
                type: string;
            };
            localizableTextOff: {
                propertyType: string;
                type: string;
            };
            touchRippleEnabled: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            rippleElement: {
                propertyType: string;
                type: string;
                defaultValue: any;
            };
            rippleTarget: {
                propertyType: string;
                type: string;
                defaultValue: any;
            };
            rippleTargetAsParent: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            rippleRadius: {
                propertyType: string;
                type: string;
                defaultValue: any;
            };
            rippleSpeedAmount: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            rippleCentered: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            rippleUnbounded: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            ripplePersistent: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            rippleFadeInDuration: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            rippleFadeOutDuration: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            rippleColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        lastPointerAction: string;
        remoteActionHandler: any;
        actionHandler: any;
        dragThreshold: number;
        toggle: boolean;
        radio: boolean;
        key: boolean;
        checkbox: boolean;
        fastTap: boolean;
        pageName: string;
        viewName: string;
        pageOptions: any;
        regionId: string;
        targetProperty: string;
        touchRippleEnabled: boolean;
        rippleElement: string;
        rippleTarget: string;
        rippleTargetAsParent: boolean;
        rippleRadius: number;
        rippleSpeedAmount: number;
        rippleCentered: boolean;
        rippleUnbounded: boolean;
        ripplePersistent: boolean;
        rippleFadeInDuration: number;
        rippleFadeOutDuration: number;
        rippleColor: string;
        ripple: TouchRipple;
        showLoadingSymbol: boolean;
        private _mousedown;
        private _inuse;
        private outside;
        private _dragXStart;
        private _dragYStart;
        private _dragX;
        private _dragY;
        private _dragOff;
        private _boundPointerMove;
        private _boundPointerUp;
        private _boundPointerDownHandler;
        private _boundPointerCancelHandler;
        private _boundDocumentPointerCancelHandler;
        private _boundLocalizableTextOnHandler;
        private _boundLocalizableTextOffHandler;
        private _initRipple;
        private _changeRippleColor;
        private _textOn;
        get textOn(): string;
        set textOn(value: string);
        private _localizableTextOn;
        private _localizableTextOnObject;
        private _localizableTextOnHandler;
        set localizableTextOn(value: string);
        get localizableTextOn(): string;
        private _textOff;
        get textOff(): string;
        set textOff(value: string);
        private _localizableTextOff;
        private _localizableTextOffObject;
        private _localizableTextOffHandler;
        get localizableTextOff(): string;
        set localizableTextOff(value: string);
        private _indeterminate;
        /**
         * Gets / set the inderterminate property.
         * This is the "third" value for a checkbox.
         * If inderterminate is set, is has a higher priority as the checked status.
         * If indeterminate is false, checked show the true or false state.
         * A css class indeterminate will be set to the control element when if it set.
         * The event "indetermnateChange" will be trigger when the value of indeterminate will change.
         * The event "notifyOptionChanged" will also triggert.
         * Defaultvalue: false
        **/
        set indeterminate(value: boolean);
        get indeterminate(): boolean;
        private _checked;
        /**
         * Gets or set the checked property.
         * if the control a togglebutton, checked shows if the button activ / on.
         * A css class "checked" will be set to the control element when if it set.
         * The event "checkedCahnge" will be trigger when the value of checked will change.
         * The event "notifyOptionChanged" will also triggert.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        set checkedWithoutWrite(value: boolean);
        set checked(value: boolean);
        get checked(): boolean;
        set checkedIntern(value: boolean);
        get checkedIntern(): boolean;
        private _pressed;
        set pressed(value: boolean);
        get pressed(): boolean;
        /**
         * Creates a new ButtonBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: VWElement, options: any);
        beforeInitBase(element: any, options: any): void;
        postSetOptionsBase(element: VWElement, options: any): void;
        /**
        * läd die neue Seite die in url angegeben ist in den pageNavigator.
        * Wird durch den default mainAction Handler ausgeführt.
        * Ist die regionId gesetzt, so wird alternativ die region mit der ID geladen.
        * nach dem navigieren wird ein Event "navigate" ausgeführt.
        * @navigate
        * @param url seitenadresse zu der navigiert werden soll, optional.
        *
       **/
        navigate(url?: string): void;
        private _navAction;
        buttonInitHandler(element: VWElement): void;
        buttonRemoveHandler(): void;
        private _resetPressedState;
        _doumentPointerCancelHandler(e: PointerEvent): void;
        _pointerCancelHandler(e: PointerEvent): void;
        private _pointerDownHandler;
        private writePromise;
        private _pointerUpHandler;
        private _pointerMoveHandler;
        private _keyDownHandler;
        /**
         * remove the ButtonBase control.
         * all work will do in the dispose super class.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
        private _dispatchButtonEvents;
    }
}
declare module VisiWin.UI {
    interface INavButtonBase extends VisiWin.UI.IButtonBase {
        /**
         * Creates a new NavButtonBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        /**
         * läd die neue Seite die in url angegeben ist in den pageNavigator.
         * Wird durch den default mainAction Handler ausgeführt.
         * Ist die regionId gesetzt, so wird alternativ die region mit der ID geladen.
         * nach dem navigieren wird ein Event "navigate" ausgeführt.
         * @navigate
         * @param url seitenadresse zu der navigiert werden soll, optional.
         *
        **/
        /**
         * remove the NavButtonBase control.
         * all work will do in the dispose super class.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    abstract class NavButtonBase extends ButtonBase implements INavButtonBase {
        static controlName: string;
        /**
         * Creates a new NavButtonBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: any, options: any);
        /**
         * remove the NavButtonBase control.
         * all work will do in the dispose super class.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IKeyBase extends VisiWin.UI.IButtonBase {
        /**
         * keyMode    property / option
         * Es gibt vier Arbeitsweisen des Keys:
         *  "toggle":   Bei jeder Action des Button wird der boolsche Wert "checked" geändert.
         *  "on":       Bei jeder Action des Button wird der boolsche Wert "checked" gesetzt.
         *  "off":      Bei jeder Action des Button wird der boolsche Wert "checked" gelöscht.
         *  "key":      Der boolsche Wert ist solange gesetzt wie der Button gehalten wird.
         * Datatype: string
         * Defaultvalue: "key"
         * Valid values: "toggle", "on", off", "key"
        */
        keyMode: string;
        /**
         * Creates a new Symbol Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        /**
         * remove a control as the VisiWin Control pattern.
         * dipose baseControl without inner Controls
         * @return true when the control is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    abstract class KeyBase extends VisiWin.UI.ButtonBase implements IKeyBase {
        static controlName: string;
        static KeyBaseOptionsList: {
            mode: {
                propertyType: string;
                type: string;
            };
            keyMode: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            key: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        private _boundKeyEventHandler;
        private _pending;
        private _lastValue;
        private _lastValueValid;
        /**
         * keyMode    property / option
         * Es gibt vier Arbeitsweisen des Keys:
         *  "toggle":   Bei jeder Action des Button wird der boolsche Wert "checked" geändert.
         *  "on":       Bei jeder Action des Button wird der boolsche Wert "checked" gesetzt.
         *  "off":      Bei jeder Action des Button wird der boolsche Wert "checked" gelöscht.
         *  "key":      Der boolsche Wert ist solange gesetzt wie der Button gehalten wird.
         * Datatype: string
         * Defaultvalue: "key"
         * Valid values: "toggle", "on", off", "key"
        */
        set mode(value: string);
        private _keyMode;
        get keyMode(): string;
        set keyMode(value: string);
        /**
         * Creates a new Key Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: VWElement, options: any);
        _onVariableValueChanged(vwVariable: any, newValue: any): void;
        detach(): Promise<any>;
        keyReset(): void;
        private _keyEventHandler;
        /**
         * remove a control as the VisiWin Control pattern.
         * dipose baseControl without inner Controls
         * @return true when the control is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IToggleButtonBase extends IButtonBase {
        pageOn: string;
        pageOff: string;
        pageOffBack: string;
        dispose(): boolean;
        /**
         * Creates a new ToggleButtonBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        /**
         * remove the ToggleButtonBase control.
         * Handler für lokalisierte Texte entfern.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    abstract class ToggleButtonBase extends ButtonBase implements IToggleButtonBase {
        static controlName: string;
        static ToggleButtonBaseOptionsList: {
            buttonclick: {
                propertyType: string;
                triggerDataName: string;
            };
            pageOn: {
                propertyType: string;
                type: string;
            };
            pageOff: {
                propertyType: string;
                type: string;
            };
            pageOffBack: {
                propertyType: string;
                type: string;
            };
            viewOn: {
                propertyType: string;
                type: string;
            };
            viewOff: {
                propertyType: string;
                type: string;
            };
            bitNumber: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            toggle: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        pageOn: string;
        pageOff: string;
        pageOffBack: string;
        viewOn: string;
        viewOff: string;
        /**
         * Creates a new ToggleButtonBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: any, options: any);
        onLanguageChangedBase(): void;
        beforeInitBase(element: any, options: any): void;
        afterInit(element: any, options: any): void;
        onNavToggleAction(args: any): void;
        /**
         * remove the ToggleButtonBase control.
         * Handler für lokalisierte Texte entfern.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface INavToggleButtonBase extends IToggleButtonBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    abstract class NavToggleButtonBase extends ToggleButtonBase implements INavToggleButtonBase {
        static controlName: string;
        constructor(element: any, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IRadioButtonBase extends IToggleButtonBase {
        /**
         * remove a control as the VisiWin Control pattern.
         * dipose baseControl without inner Controls
         * @return true when the control is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    abstract class RadioButtonBase extends ToggleButtonBase implements IRadioButtonBase {
        static controlName: string;
        static RadioButtonBaseOptionsList: {
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            radio: {
                propertyType: string;
                defaultValue: boolean;
            };
        };
        constructor(element: any, options: any);
        beforeInitBase(element: any, options: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ICheckboxBase extends IToggleButtonBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class CheckboxBase extends ToggleButtonBase implements ICheckboxBase {
        static controlName: string;
        static CheckboxBaseOptionsList: {};
        /**
         * Creates a new ButtonBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: any, options: any);
        beforeInitBase(element: any, options: any): void;
        /**
         * method dispose
         * remove the ButtonBase control.
         * all work will do in the dispose super class.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ITabButtonBase extends IButtonBase {
        /**
         * remove the NavButtonBase control.
         * all work will do in the dispose super class.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    abstract class TabButtonBase extends ButtonBase implements ITabButtonBase {
        static controlName: string;
        static TabButtonBaseOptionsList: {
            toggle: {
                propertyType: string;
                defaultValue: boolean;
            };
            radio: {
                propertyType: string;
                defaultValue: boolean;
            };
            bitNumber: {
                propertyType: string;
                defaultValue: number;
            };
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
        };
        /**
         * Creates a new NavButtonBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: any, options: any);
        /**
         * remove the TabButtonBase control.
         * all work will do in the dispose super class.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IDropDownBoxBase extends IButtonBase {
        /**
         * Gets or sets the selectedIndex
         * set will change the selected dropDownBoxItem in the flyout.
        **/
        selectedIndex: number;
        /**
         * Gets or sets the Property placement
         * to be used for this Flyout relative to the DropDown element..
         * @param val The placment type to register:,
         * "top"           Position the Flyout explicitly on the top of the anchor, resized to fit and adding scrollbar as needed.
         * "bottom"        Position the Flyout explicitly below the anchor, resized to fit and adding scrollbar as needed.
         * "left"          Position the Flyout left of the anchor, resized to fit and adding a vertical scrollbar as needed.
         * "right"         Position the Flyout right of the anchor, resized to fit and adding a vertical scrollbar as needed.
         * "auto"          Automatic placement such that the entire Flyout can be shown without being resized; typical placement is the vertical center of the display. If the Flyout fits above that centered anchor, then the Flyout is placed vertically in relation to the anchor, otherwise placement is horizontal.This is the default value.
         * "autohorizontal"Automatic placement is limited to the left or right of the anchor element. A vertical scrollbar is added if necessary.
         * "autovertical"  Automatic placement is limited to the top or bottom of the anchor element. A vertical scrollbar is added if necessary.
        **/
        menuPlacement: string;
        /** Gets or sets the default alignment to be used for this Flyout relative to the DropDown element.
         * "right"      The right edge of the Flyout is aligned to the right edge of the anchor element.
         * "left"       The left edge of the Flyout is aligned to the left edge of the anchor element.
         * "center"     The horizontal midpoint of the Flyout is positioned at the horizontal midpoint of the anchor element.This is the default value.
        */
        menuAlignment: string;
        menuWidth: string;
        menuHeight: string;
        onValueChanged(args: any): void;
        createTemplateBase(element: VWElement, options: any): any;
        createHandlerDropDownBoxBase(element: VWElement, options: any): void;
        removeHandlerDropDownBoxBase(element: VWElement): void;
        /** DropDownBox ListItem hinzufügen, ListItem werden consumiert,
         * andere werden dem übergeordneten Control weitergegeben
         * @param element das register aufgerufen hat.
        */
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    abstract class DropDownBoxBase extends ButtonBase implements IDropDownBoxBase {
        static controlName: string;
        static DropDownBoxBaseOptionsList: {
            selectedIndexChanged: {
                propertyType: string;
            };
            selectedIndex: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            menuPlacement: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            menuAlignment: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            menuWidth: {
                propertyType: string;
                type: string;
            };
            menuHeight: {
                propertyType: string;
                type: string;
            };
            open: {
                propertyType: string;
                type: string;
                defaultValue_DM: boolean;
            };
        };
        private _iconElement;
        private _firstPage;
        private _flyoutOptions;
        private _flyoutControl;
        private _focusIndex;
        private _flyoutOpenFlag;
        private _wheelEvent;
        private _keyFlagAlt;
        _listItems: any[];
        _listItemCnt: number;
        _flyoutElement: any;
        private _selectedIndex;
        private _collectionContainerElement;
        private _boundFlyoutDismissHandler;
        private _boundFlyoutKeypressHandler;
        private _boundKeypressHandler;
        selectedItem: {
            itemSymbolElement: any;
            textElement: any;
            anchorElement: any;
        };
        /**
         * Gets or sets the selectedIndex
         * set will change the selected dropDownBoxItem in the flyout.
        **/
        set selectedIndex(value: number);
        get selectedIndex(): number;
        /**
         * Gets or sets the Property placement
         * to be used for this Flyout relative to the DropDown element..
         * @param val The placment type to register:,
         * "top"           Position the Flyout explicitly on the top of the anchor, resized to fit and adding scrollbar as needed.
         * "bottom"        Position the Flyout explicitly below the anchor, resized to fit and adding scrollbar as needed.
         * "left"          Position the Flyout left of the anchor, resized to fit and adding a vertical scrollbar as needed.
         * "right"         Position the Flyout right of the anchor, resized to fit and adding a vertical scrollbar as needed.
         * "auto"          Automatic placement such that the entire Flyout can be shown without being resized; typical placement is the vertical center of the display. If the Flyout fits above that centered anchor, then the Flyout is placed vertically in relation to the anchor, otherwise placement is horizontal.This is the default value.
         * "autohorizontal"Automatic placement is limited to the left or right of the anchor element. A vertical scrollbar is added if necessary.
         * "autovertical"  Automatic placement is limited to the top or bottom of the anchor element. A vertical scrollbar is added if necessary.
        **/
        private _menuPlacement;
        set menuPlacement(value: string);
        get menuPlacement(): string;
        /** Gets or sets the default alignment to be used for this Flyout relative to the DropDown element.
         * "right"      The right edge of the Flyout is aligned to the right edge of the anchor element.
         * "left"       The left edge of the Flyout is aligned to the left edge of the anchor element.
         * "center"     The horizontal midpoint of the Flyout is positioned at the horizontal midpoint of the anchor element.This is the default value.
         */
        private _menuAlignment;
        set menuAlignment(value: string);
        get menuAlignment(): string;
        private _menuWidth;
        set menuWidth(value: string);
        get menuWidth(): string;
        private _menuHeight;
        set menuHeight(value: string);
        get menuHeight(): string;
        /** Open or close items container (DesignMode).
         *  true  - Open items container.
         *  false - Close items container.
         */
        private _open;
        set open(value: boolean);
        get open(): boolean;
        /**
         * Creates a new DropDownControlBase.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        constructor(element: VWElement, options: any);
        onValueChanged(args: any): void;
        createTemplateBase(): any;
        createHandlerDropDownBoxBase(element: VWElement, options: any): void;
        removeHandlerDropDownBoxBase(element: VWElement): void;
        _keypressHandler(args: any): void;
        _flyoutKeypressHandler(args: any): void;
        _flyoutDismissHandler(args: any): void;
        _dropdownAction(args: any): void;
        /** DropDownBox ListItem hinzufügen, ListItem werden consumiert,
         * andere werden dem übergeordneten Control weitergegeben
         * @param element das register aufgerufen hat.
        */
        registerItem(element: HTMLElement): boolean;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IOptionBase extends VisiWin.UI.IButtonBase {
        index: any;
        color: string;
        createTemplate(element: VWElement, options: any): any;
        createControlForce(element: VWElement, action: string, options: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    abstract class OptionBase extends VisiWin.UI.ButtonBase implements VisiWin.UI.IOptionBase {
        static controlName: string;
        static OptionBasePropertyList: {
            color: {
                propertyType: string;
                type: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        color: string;
        private _iconElement;
        private _labelElement;
        private _submenuIconElement;
        private _submenuElement;
        private _submenu;
        private _lastSymbol;
        index: any;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _onItemAction(item: VisiWin.UI.OptionBase): void;
        createControlForce(element: VWElement, action: string, options: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IDropDownBoxItemBase extends VisiWin.UI.IButtonBase {
        index: any;
        color: string;
        createControlForce(element: VWElement, action: string, options: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    abstract class DropDownBoxItemBase extends VisiWin.UI.ButtonBase implements VisiWin.UI.IDropDownBoxItemBase {
        static controlName: string;
        static DropDownBoxItemBaseOptionsList: {
            color: {
                propertyType: string;
                type: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        color: string;
        private _iconElement;
        private _labelElement;
        private _submenuIconElement;
        private _submenuElement;
        private _submenu;
        private _lastSymbol;
        index: any;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _onItemAction(item: VisiWin.UI.DropDownBoxItemBase): void;
        createControlForce(element: VWElement, action: string, options: any): void;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI.RegionHelper {
    /**
    * Internal do not use
    * @internal
    * */
    function _attachPage(regionBase: IRegionBase | IRuntimeRegionBase, element: VWElement, controlType: string): WinJS.Promise<any>;
    /**
    * Internal do not use
    * @internal
    * */
    function _detachPage(element: VWElement): WinJS.Promise<any>;
    /**
    * Internal do not use
    * @internal
    * */
    function _beforeInit(regionBase: IRegionBase | IRuntimeRegionBase): void;
    /**
    * Internal do not use
    * @internal
    * */
    function _createPageElement(element: VWElement, className: string): HTMLDivElement;
    /**
    * Internal do not use
    * @internal
    * */
    function __getAnimationElements(regionBase: IRegionBase | IRuntimeRegionBase): any;
    /**
    * Internal do not use
    * @internal
    * */
    function _refresh(regionBase: IRegionBase | IRuntimeRegionBase, regionBaseCounter: string): void;
    /**
    * Internal do not use
    * @internal
    * */
    function _navigatedEnd(regionBase: IRegionBase | IRuntimeRegionBase, args: VisiWin.AppServices.Impl.Navigation.INavigationResultDetails): void;
    /**
    * Internal do not use
    * @internal
    * */
    function _navigatingStart(regionBase: IRegionBase | IRuntimeRegionBase, args: VisiWin.AppServices.Impl.Navigation.INavigationResultDetails): Promise<any>;
}
declare module VisiWin.UI {
    interface IRegionBase extends VisiWin.UI.IControlBase {
        pageName: string;
        pageOptions: any;
        readonly pageControl: any;
        readonly pageElement: any;
        /**
        * Internal helper do not use
        * @internal
        * */
        createPageElement(): HTMLDivElement;
        /**
        * Internal helper do not use
        * @internal
        * */
        _newTempElement: any;
        /**
        * Internal helper do not use
        * @internal
        * */
        _oldTempElement: any;
        /**
        * Internal helper do not use
        * @internal
        * */
        _navigationRunning: boolean;
        /**
        * Internal helper do not use
        * @internal
        * */
        _regionBaseId: string;
    }
}
declare module VisiWin.UI {
    let pages: any;
    class RegionBase extends VisiWin.UI.ControlBase implements IRegionBase {
        static controlName: string;
        static classNamePageControl: string;
        static regionBaseCounter: number;
        static PropertyList: {
            initialized: {
                propertyType: string;
            };
            navigated: {
                propertyType: string;
            };
            navigating: {
                propertyType: string;
            };
            navigationStarting: {
                propertyType: string;
            };
            navigationEnding: {
                propertyType: string;
            };
            pageName: {
                propertyType: string;
                type: string;
            };
            viewName: {
                propertyType: string;
                type: string;
            };
            pageOptions: {
                propertyType: string;
                type: string;
                invisible: boolean;
            };
            pageControl: {
                propertyType: string;
                type: string;
                access: string;
                invisible: boolean;
            };
            pageElement: {
                propertyType: string;
                type: string;
                access: string;
                invisible: boolean;
            };
            showLoadingSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        pageOptions: any;
        showLoadingSymbol: boolean;
        private _viewName;
        set viewName(value: string);
        get viewName(): string;
        private _privatePageName;
        private _pageName;
        set pageName(value: string);
        get pageName(): string;
        get pageControl(): any;
        set pageControl(val: any);
        get pageElement(): any;
        set pageElement(val: any);
        _lastPage: string;
        /**
        * Internal helper do not use
        * @internal
        * */
        _oldTempElement: any;
        /**
        * Internal helper do not use
        * @internal
        * */
        _newTempElement: any;
        /**
        * Internal helper do not use
        * @internal
        * */
        _navigationRunning: boolean;
        /**
        * Internal helper do not use
        * @internal
        * */
        _regionBaseId: string;
        /**
        * Internal helper do not use
        * @internal
        * */
        createPageElement(): HTMLDivElement;
        constructor(element: VWElement, options: any);
        navigationStarting(args: VisiWin.AppServices.Impl.Navigation.INavigationResultDetails): Promise<void>;
        navigationEnding(args: VisiWin.AppServices.Impl.Navigation.INavigationResultDetails): void;
        private _navigateFromNameSetter;
        /**
        * Internal do not use
        * @internal
        * */
        attachPage(element: VWElement): WinJS.Promise<any>;
        /**
        * Internal do not use
        * @internal
        * */
        detachPage(element: VWElement): WinJS.Promise<any>;
        /**
        * Internal do not use
        * @internal
        * */
        private _getAnimationElements;
        /**
        * Internal do not use
        * @internal
        * */
        private refresh;
        /**
        * @internal
        * called from ResizeObserver
        * */
        resizeHandler(args: ResizeObserverEntry[]): any;
        beforeInit(): void;
        /**
         * remove a control as the VisiWin Control pattern.
         * dipose baseControl without inner Controls
         * @return true when the control is dispose, false when the control alredy finished dispose.
        **/
        dispose(): any;
        private navigatingInternal;
        private navigatingAction;
        private navigated;
        private navigating;
    }
}
declare module VisiWin.UI {
    interface IRuntimeRegionBase extends VisiWin.UI.IControlBase {
        pageName: string;
        pageOptions: any;
        readonly pageControl: any;
        readonly pageElement: any;
        /**
        * Internal helper do not use
        * @internal
        * */
        createPageElement(): HTMLDivElement;
        /**
        * Internal helper do not use
        * @internal
        * */
        _newTempElement: any;
        /**
        * Internal helper do not use
        * @internal
        * */
        _oldTempElement: any;
        /**
        * Internal helper do not use
        * @internal
        * */
        _navigationRunning: boolean;
        /**
        * Internal helper do not use
        * @internal
        * */
        _regionBaseId: string;
    }
}
declare module VisiWin.UI {
    class RuntimeRegionBase extends VisiWin.UI.ControlBase implements IRuntimeRegionBase {
        static controlName: string;
        static classNamePageControl: string;
        static runtimeRegionBaseCounter: number;
        static PropertyList: {
            initialized: {
                propertyType: string;
            };
            navigated: {
                propertyType: string;
            };
            navigating: {
                propertyType: string;
            };
            pageName: {
                propertyType: string;
                type: string;
            };
            viewName: {
                propertyType: string;
                type: string;
            };
            pageOptions: {
                propertyType: string;
                type: string;
                invisible: boolean;
            };
            pageControl: {
                propertyType: string;
                type: string;
                access: string;
                invisible: boolean;
            };
            pageElement: {
                propertyType: string;
                type: string;
                access: string;
                invisible: boolean;
            };
            showLoadingSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        pageOptions: any;
        showLoadingSymbol: boolean;
        private _viewName;
        private _lastViewName;
        set viewName(value: string);
        get viewName(): string;
        private _pageName;
        set pageName(value: string);
        get pageName(): string;
        get pageControl(): any;
        set pageControl(val: any);
        get pageElement(): any;
        set pageElement(val: any);
        /**
        * Internal helper do not use
        * @internal
        * */
        _oldTempElement: any;
        /**
        * Internal helper do not use
        * @internal
        * */
        _newTempElement: any;
        /**
        * Internal helper do not use
        * @internal
        * */
        _navigationRunning: boolean;
        /**
        * Internal helper do not use
        * @internal
        * */
        _regionBaseId: string;
        /**
        * Internal helper do not use
        * @internal
        * */
        createPageElement(): HTMLDivElement;
        constructor(element: VWElement, options: any);
        private navigatingInternal;
        /**
        * Internal do not use
        * @internal
        * */
        attach(): Promise<any> | null;
        detach(): Promise<any> | null;
        /**
        * Internal do not use
        * @internal
        * */
        private _getAnimationElements;
        private refresh;
        /**
        * @internal
        * called from ResizeObserver
        * */
        resizeHandler(args: ResizeObserverEntry[]): any;
        beforeInit(): void;
        /**
         * remove a control as the VisiWin Control pattern.
         * dipose baseControl without inner Controls
         * @return true when the control is dispose, false when the control alredy finished dispose.
        **/
        dispose(): any;
        private navigated;
        private navigating;
    }
}
declare module VisiWin.UI {
    interface IGroupBase {
        dragThreshold: number;
        actionTarget: string;
        _itemCount: number;
        _items: any[];
        selectedIndex: number;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
    }
}
declare module VisiWin.UI {
    abstract class GroupBase extends ControlBase implements IGroupBase {
        static controlName: string;
        static groupBasePropertyList: {
            selectedIndexChanged: {
                propertyType: string;
            };
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            dragThreshold: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            selectedIndex: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            mode: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerItems: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        dragThreshold: number;
        actionTarget: string;
        registerItem: boolean;
        _itemCount: number;
        _items: any[];
        private _preventActionHandler;
        private _mode;
        set mode(value: string);
        get mode(): string;
        private _selectedIndex;
        set selectedIndex(value: number);
        get selectedIndex(): number;
        constructor(element: VWElement, options: any);
        readyBasis(element: VWElement, options: any): void;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        private _registerItem;
        private _firstRemoteAction;
        private _actionHandler;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface INavGroupBase {
        dragThreshold: number;
        actionTarget: string;
        _itemCount: number;
        _items: any[];
        selectedIndex: number;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
    }
}
declare module VisiWin.UI {
    abstract class NavGroupBase extends ControlBase implements INavGroupBase {
        static controlName: string;
        static basePropertyList: {
            selectedIndexChanged: {
                propertyType: string;
            };
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            dragThreshold: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            selectedIndex: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
        };
        dragThreshold: number;
        actionTarget: string;
        _itemCount: number;
        _items: any[];
        firstPage: boolean;
        private _preventActionHandler;
        private _selectedIndex;
        set selectedIndex(value: number);
        get selectedIndex(): number;
        constructor(element: VWElement, options: any);
        ready(element: VWElement, options: any): Promise<void>;
        _updateMenuItem(pageName: string): void;
        _getMenuTitle(pageName: string): string;
        registerChild(controlType: string, action: string, element: HTMLElement, options: any): any;
        private _registerItem;
        private _firstRemoteAction;
        private _actionHandler;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ILayoutBase extends VisiWin.UI.IControlBase {
        designWidth: string;
        designHeight: string;
    }
}
declare module VisiWin.UI {
    abstract class LayoutBase extends VisiWin.UI.ControlBase implements ILayoutBase {
        static controlName: string;
        static LayoutBaseOptionsList: {
            layoutclick: {
                propertyType: string;
                triggerDataName: string;
                triggerCondition: string;
            };
            layoutmove: {
                propertyType: string;
            };
            layoutclickTrue: {
                propertyType: string;
                triggerDataName: string;
                triggerCondition: string;
            };
            layoutclickFalse: {
                propertyType: string;
                triggerDataName: string;
                triggerCondition: string;
            };
            layoutdown: {
                propertyType: string;
                triggerDataName: string;
                triggerCondition: string;
            };
            layoutup: {
                propertyType: string;
                triggerDataName: string;
                triggerCondition: string;
            };
            designWidth: {
                propertyType: string;
                type: string;
            };
            designHeight: {
                propertyType: string;
                type: string;
            };
            pressed: {
                propertyType: string;
                type: string;
            };
            enablePreventEvents: {
                propertyType: string;
                type: string;
            };
            enablePointerDownEvent: {
                propertyType: string;
                type: string;
                defaultValu: boolean;
            };
            enablePointerCancelEvents: {
                propertyType: string;
                type: string;
                defaultValu: boolean;
            };
            enableContextEvents: {
                propertyType: string;
                type: string;
                defaultValu: boolean;
            };
        };
        designWidth: string;
        designHeight: string;
        enablePreventEvents: boolean;
        enablePointerDownEvent: boolean;
        enablePointerCancelEvents: boolean;
        enableContextEvents: boolean;
        private _mousedown;
        private _boundPointerMove;
        private _boundPointerUp;
        private _boundPointerDownHandler;
        private _boundPointerCancelHandler;
        private _pressed;
        set pressed(value: boolean);
        get pressed(): boolean;
        constructor(element: VWElement, options: any);
        layoutInitHandler(element: VWElement): void;
        layoutRemoveHandler(): void;
        returnPreventDefaults(event: any): any;
        private _resetPressedState;
        private _pointerCancelHandler;
        private _pointerDownHandler;
        private _pointerUpHandler;
        private _pointerMoveHandler;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class RippleRender {
        element: HTMLElement;
        options: any;
        private _isMouseDown;
        private _activeRipples;
        constructor(element: any, options: any);
        setRippleElement(element: HTMLElement): void;
        setRippleOptions(options: any): void;
        addEvents(element: HTMLElement): void;
        removeEvents(element: HTMLElement): void;
        handleEvent: (e: any) => void;
        onPointerDown(e: any): void;
        onPointerUp: (e: any) => void;
        onPointerLeave(e: any): void;
        getPosition(element: HTMLElement, border?: any): {
            document: {
                width: number;
                height: number;
                left: number;
                top: number;
                right: number;
                bottom: number;
            };
            element: {
                width: number;
                height: number;
                left: number;
                top: number;
                right: number;
                bottom: number;
                borderLeft: number;
                borderTop: number;
                borderRight: number;
                borderBottom: number;
            };
        };
        fadeIn(pageX: number, pageY: number, options: any): void;
        fadeOut(ripple: any): void;
        fadeOutAll(): void;
        enforceStyleRecalculation(element: HTMLElement): void;
        distanceToFurthestCorner(x: number, y: number, rect: any): number;
        dispose(): void;
    }
}
interface Set<T> {
    add(value: T): Set<T>;
    clear(): void;
    delete(value: T): boolean;
    entries(): Array<[T, T]>;
    forEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void;
    has(value: T): boolean;
    keys(): Array<T>;
    readonly size: number;
}
interface SetConstructor {
    new <T>(): Set<T>;
    new <T>(iterable: Array<T>): Set<T>;
    readonly prototype: Set<any>;
}
declare var Set: SetConstructor;
declare module VisiWin.UI {
    class TouchRipple {
        private _isMouseDown;
        private _activeRipples;
        options: any;
        element: HTMLElement;
        private _boundPointerDown;
        private _boundPointerLeave;
        private _boundPointerUp;
        private _boundFocusOut;
        constructor(element: HTMLElement, options: any);
        setRippleElement(element: HTMLElement): void;
        setRippleOptions(options: any): void;
        addEvents(element: any): void;
        removeEvents(element: any): void;
        onPointerDown(e: any): void;
        onPointerLeave(): void;
        onPointerUp(): void;
        onFocusOut(): void;
        fadeIn(pageX: any, pageY: any, options: any): void;
        fadeOut(ripple: any): void;
        fadeOutAll(): void;
        getPosition(element: HTMLElement, border?: any): {
            document: {
                width: number;
                height: number;
                left: number;
                top: number;
                right: number;
                bottom: number;
            };
            element: {
                width: number;
                height: number;
                left: number;
                top: number;
                right: number;
                bottom: number;
                borderLeft: number;
                borderTop: number;
                borderRight: number;
                borderBottom: number;
            };
        };
        enforceStyleRecalculation(element: any): void;
        distanceToFurthestCorner(x: any, y: any, rect: any): number;
        dispose(): void;
    }
}
declare module VisiWin.UI {
    interface ITextBase extends IControlBase {
        localizableText: string;
        text: string;
        /**
         * Creates a new ButtonBase Control
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new NumericVarInCore control.
        **/
        /**
         * remove the ButtonBase control.
         * all work will do in the dispose super class.
         * @param innerDispose boolean, if innerDispose is treu, the VisiWin.Utilities.disposeSubTree function will call on the content of the control.
         * @return true when the control aktuel is dispose, false when the control alredy finished dispose.
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class TextBase extends VisiWin.UI.ControlBase {
        static controlName: string;
        static TextBasePropertyList: {
            show: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            text: {
                propertyType: string;
            };
            textContent: {
                propertyType: string;
                access: string;
            };
            localizableText: {
                propertyType: string;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            lineClamp: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            textWrapping: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            textTrimming: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            textContrast: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            uppercase: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            textDecoration: {
                propertyType: string;
            };
            textShadow: {
                propertyType: string;
            };
            fontClass: {
                propertyType: string;
                defaultValue: string;
            };
            fontFamily: {
                propertyType: string;
            };
            fontSize: {
                propertyType: string;
            };
            fontWeight: {
                propertyType: string;
            };
            lineHeight: {
                propertyType: string;
            };
            fontStyle: {
                propertyType: string;
            };
            letterSpacing: {
                propertyType: string;
            };
        };
        displayValue: string | null;
        fontFamily: string;
        fontSize: string;
        lineHeight: string;
        fontStyle: string;
        letterSpacing: string;
        textDecoration: string;
        textShadow: string;
        private _boundLocalizableTextHandler;
        private _boundTextHandler;
        constructor(element: VWElement, options: any);
        private _textObject;
        private _text;
        private _textHandler;
        get text(): string;
        set text(value: string);
        private _localizableTextObject;
        private _localizableTextHandler;
        private _localizableText;
        get localizableText(): string;
        set localizableText(value: string);
        get textContent(): string;
        set textContent(value: string);
        private _textAlignment;
        get textAlignment(): string;
        set textAlignment(value: string);
        private _textContrast;
        get textContrast(): number;
        set textContrast(value: number);
        private _textWrapping;
        get textWrapping(): string;
        set textWrapping(value: string);
        private _textTrimming;
        get textTrimming(): string;
        set textTrimming(value: string);
        private _lineClamp;
        get lineClamp(): number;
        set lineClamp(value: number);
        private _uppercase;
        get uppercase(): boolean;
        set uppercase(value: boolean);
        private _show;
        get show(): boolean;
        set show(value: boolean);
        private _fontClass;
        get fontClass(): string;
        set fontClass(value: string);
        private _fontWeight;
        get fontWeight(): string;
        set fontWeight(value: string);
        _setTextWrapping(): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    abstract class RepeaterBase extends VisiWin.UI.ControlBase implements IRepeaterBase {
        static controlName: string;
        static properties: {
            itemsLoaded: {
                propertyType: string;
            };
            itemChanging: {
                propertyType: string;
            };
            itemChanged: {
                propertyType: string;
            };
            itemInserting: {
                propertyType: string;
            };
            itemInserted: {
                propertyType: string;
            };
            itemMoving: {
                propertyType: string;
            };
            itemMoved: {
                propertyType: string;
            };
            itemRemoving: {
                propertyType: string;
            };
            itemRemoved: {
                propertyType: string;
            };
            itemsReloading: {
                propertyType: string;
            };
            itemsReloaded: {
                propertyType: string;
            };
            templateReady: {
                propertyType: string;
            };
            dataSource: {
                propertyType: string;
            };
            dataTemplate: {
                propertyType: string;
            };
            compiledDataTemplate: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            renderMode: {
                defaultValue: Enums.RenderMode;
            };
            selectedIndex: {
                type: string;
                defaultValue: number;
            };
            selectedValue: {};
            selectionMode: {
                defaultValue: Enums.SelectionMode;
            };
            selectedItem: {
                type: string;
            };
            inlineTemplate: {
                type: string;
                defaultValue: boolean;
            };
        };
        itemsLoaded(): void;
        itemChangingBase(renderedItem: VWElement, index: number, key: string, detail: any): void;
        itemInsertingBase(renderedItem: VWElement, index: number, detail: any): void;
        itemMovingBase(affectedElement: any, newIndex: number, oldIndex: number, key: string): void;
        itemMovedBase(affectedElement: any, newIndex: number, oldIndex: number, key: string): void;
        itemRemovingBase(removedItem: VWElement, index: number, detail: any): void;
        itemsReloadingBase(detail: any): void;
        itemsReloadedBase(affectedElements: any[]): void;
        compiledDataTemplate: boolean;
        get itemList(): any[];
        renderMode: VisiWin.UI.Enums.RenderMode;
        selectedIndex: number;
        selectedValue: string;
        selectionMode: VisiWin.UI.Enums.SelectionMode;
        selectedItem: any;
        inlineTemplate: boolean;
        _inlineItems: boolean;
        _boundItemCheckedChanged: any;
        private _repeatedDOM;
        private _render;
        private _dataSource;
        private _modifying;
        private _dataListeners;
        private _repeatedDOMOrigin;
        private _dataTemplateObject;
        private _checkDataReady;
        get dataSource(): any;
        set dataSource(data: any);
        private _dataTemplate;
        get dataTemplate(): any;
        set dataTemplate(templateName: any);
        private _boundDataTemplateReady;
        dataTemplateReady(dataTemp: any): void;
        constructor(element: VWElement, options: any);
        _renderAllItems(): void;
        _reloadRepeater(shouldDisposeElements: boolean): void;
        _unloadRepeatedDOM(shouldDisposeElements: boolean): void;
        _addDataListeners(): void;
        _removeDataListeners(): void;
        _beginModification(): void;
        _endModification(): void;
        _dataItemChangedHandler(eventInfo: {
            detail: {
                index: number;
                key: string;
                renderedItem: any;
                newValue: any;
                oldItem: any;
                oldValue: any;
                setPromise: (delayPromise: any) => void;
            };
        }): void;
        _dataItemInsertedHandler(eventInfo: {
            detail: {
                index: number;
                key: string;
                value: any;
                affectedElement: any;
            };
        }): void;
        _dataItemMovedHandler(eventInfo: {
            detail: {
                key: string;
                newIndex: number;
                oldIndex: number;
                affectedElement: any;
            };
        }): void;
        boundDataItemRemovedHandler: any;
        _dataItemRemovedHandler(eventInfo: {
            detail: {
                index: number;
                item: any;
                key: string;
                value: any;
            };
        }): void;
        _dataReloadHandler(): void;
        _reloadSortedList(): void;
        private renderedItemBase;
        private itemChangedBase;
        private itemInsertedBase;
        private itemRemovedBase;
        _setDesignerType(item: VWElement): void;
        _onItemCheckedChanged(ev: {
            detail: {
                sender: {
                    value: string;
                    index: number;
                };
            };
        }): void;
        getKeyByValue(object: any, value: any): string;
        _checkItem(item: any): void;
        _uncheckItem(item: any): void;
        private createEventDetails;
        findDataTemplateSelector(element: HTMLElement, dataSource: any, index: number): boolean;
        itemFromKey(key: string): VWElement;
        itemFromIndexBase(index: number): any;
        attach(): Promise<any>;
        detach(): Promise<any>;
        dispose(): boolean;
    }
    interface IEventDetail {
        selectedIndex: number;
        selectedValue: any;
        selectedItem: any;
        itemData: Object;
        affectedIndex: any;
        affectedItem: any;
        newIndex: number;
        oldIndex: number;
        newValue: any;
        oldValue: any;
        newItem: any;
        oldItem: any;
        repeatedDOMLength: number;
    }
}
declare module VisiWin.UI {
    interface IRepeaterBase extends VisiWin.UI.IControlBase {
        itemsLoaded(): void;
        itemChangingBase(renderedItem: VWElement, index: number, key: string, detail: any): void;
        itemInsertingBase(renderedItem: VWElement, index: number, detail: any): void;
        itemMovingBase(affectedElement: any, newIndex: number, oldIndex: number, key: string): void;
        itemMovedBase(affectedElement: any, newIndex: number, oldIndex: number, key: string): void;
        itemRemovingBase(removedItem: VWElement, index: number, detail: any): void;
        itemsReloadingBase(detail: any): void;
        itemsReloadedBase(affectedElements: any[]): void;
        /**
        * @description Sets whether the render function should be compiled or sync
        * @member { boolean } compiledDataTemplate
        * defaultValue: false
        */
        compiledDataTemplate: boolean;
        /**
        * @description Defines the selection mode, which indicates whether a ListItem can be selected or not.
        * @enum VisiWin.UI.Enums.SelectionMode
        * defaultValue: VisiWin.UI.Enum.SelectionMode.None
        */
        renderMode: VisiWin.UI.Enums.RenderMode;
        /**
        * @description Represents the position (index) of the selected/checked ListItem
        * @member { number } selectedIndex
        * defaultValue: -1
        */
        selectedIndex: number;
        /**
        * @description Represents the value of the selected/checked ListItem
        * @member { string } selectedValue
        * defaultValue: ""
        */
        selectedValue: string;
        /**
        * @description Defines the selection mode, which indicates whether a ListItem can be selected or not.
        * @enum VisiWin.UI.Enums.SelectionMode
        * defaultValue: VisiWin.UI.Enum.SelectionMode.None
        */
        selectionMode: VisiWin.UI.Enums.SelectionMode;
        /**
        * @description Determines if inline template is set
        * @member { boolean } inlineTemplate
        * defaultValue: false
        */
        inlineTemplate: boolean;
        /**
        * @description Determines if inline items are set
        * @member { boolean } _inlineItems
        * defaultValue: false
        */
        _inlineItems: boolean;
        /**
        * @method Creates the renderer with the selected render function dependent on the compieldDataTemplate
        * @name dataTemplateReady
        * @param {any} dataTemp Name of the dataTemplate which should be rendered
        */
        dataTemplateReady(dataTemp: any): any;
        /**
        * @method Returns the ListItem of the selected key
        * @name itemFromKey
        * @param {string} key selected key
        * @returns ListItem
        */
        itemFromKey(key: string): VWElement;
        /**
        * @method Gets the ListItem of the selected index
        * @name itemFromIndexBase
        * @param {number} index selected index
        */
        itemFromIndexBase(index: number): any;
        /**
        * public method: attaches the control
        * @name attach
        */
        attach(): Promise<any> | null;
        /**
        * public method: detaches the control
        * @name detach
        */
        detach(): Promise<any> | null;
        /**
        * public method: dispose destroy the control
        * @name dispose
        * @return:bool is true, dispose subtree will be call after dispose
        */
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    abstract class ItemBase extends VisiWin.UI.ButtonBase implements IItemBase {
        static controlName: string;
        static ItemBaseProperties: {
            radio: {
                propertyType: string;
                defaultValue: boolean;
            };
            orientation: {
                defaultValue: Enums.Orientation;
            };
            alignItems: {
                defaultValue: Enums.AlignItems;
            };
            justifyContent: {
                defaultValue: Enums.JustifyContent;
            };
            dataTemplate: {
                type: string;
                defaultValue: boolean;
            };
            inlineItems: {
                type: string;
                defaultValue: boolean;
            };
            index: {
                type: string;
                defaultValue: number;
            };
            value: {
                propertyType: string;
                type: string;
            };
            secondaryValue: {
                type: string;
            };
            keyMember: {
                propertyType: string;
                type: string;
            };
            selectionMode: {
                defaultValue: Enums.SelectionMode;
            };
            toggle: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        orientation: string;
        alignItems: string;
        justifyContent: string;
        dataTemplate: boolean;
        inlineItems: boolean;
        index: number;
        selectionMode: VisiWin.UI.Enums.SelectionMode;
        secondaryValue: string;
        private _boundItemsLoaded;
        private _keyMember;
        get keyMember(): string;
        set keyMember(value: string);
        private _valueMember;
        get value(): string;
        set value(value: string);
        constructor(element: any, options: any);
        initializedBasis(): void;
        _onActionItemChanged(args: any): void;
        setFlexProperties(changeName: string): void;
        authorizeChilds(contentElement: any, authorizationRight: string, authorizationMode: VisiWin.UI.Enums.AuthorizationMode): void;
    }
}
declare namespace VisiWin.UI {
    interface IItemBase extends VisiWin.UI.IControlBase {
        /**
        * @description Subset of the css flex-direction property.
        * @enum Orientation
        * @see {@link VisiWin.UI.Enums.Orientation|orientation(Enum)} <br>
        * defaultValue: VisiWin.UI.Enums.Orientation.Vertical
        */
        orientation: any;
        /**
        * @description Subset of the css align-items property.
        * @enum AlignItems
        * @see {@link VisiWin.UI.CSSProperties.alignItems|alignItems(Enum)} <br>
        * defaultValue: "Start"
        */
        alignItems: any;
        /**
        * @description Subset of the css justify-content property.
        * @enum JustifyContent
        * @see {@link VisiWin.UI.CSSProperties.justifyContent|justifyContent(Enum)} <br>
        * defaultValue: "Start"
        */
        justifyContent: any;
        /**
        * @description Defines, if the ListItem is used in a DataTemplateView
        * @member { boolean } dataTemplate
        * defaultValue: false
        */
        dataTemplate: boolean;
        /**
        * @description Defines, if the ListItem is rendered as an inline Item
        * @member { boolean } inlineItems
        * defaultValue: true
        */
        inlineItems: boolean;
        /**
        * @description Sets the index of a listItem
        * @member { number } index
        * defaultValue: -1
        */
        index: number;
        /**
        * @description Sets whether a ListItem can be selected or not
        * @member { VisiWin.UI.Enums.SelectionMode } selectionMode
        * defaultValue: VisiWin.UI.Enums.SelectionMode.None
        */
        selectionMode: VisiWin.UI.Enums.SelectionMode;
        /**
        * @description Sets whether a ListItem can be selected or not
        * @member { string } secondaryValue
        */
        secondaryValue: string;
        /**
        * @method Sets the orientation, alignItems and justifyContent properties
        * @name setFlexProperties
        * @param {string} changeName changeName of the updateLayout from a ListItem
        */
        setFlexProperties(changeName: string): any;
        /**
        * @method Authorizes the ChildControls with the given authorizationMode and authorizationRight
        * @name authorizeChilds
        * @param {any} contentElement parentElement whose childs should be authorized
        * @param {string} authorizationRight changeName of the updateLayout from a ListItem
        * @param {VisiWin.UI.Enums.AuthorizationMode} authorizationMode changeName of the updateLayout from a ListItem
        */
        authorizeChilds?(contentElement: any, authorizationRight: string, authorizationMode: VisiWin.UI.Enums.AuthorizationMode): any;
    }
}
declare module VisiWin.UI {
    interface INumericVarInCore extends VisiWin.UI.IControlBase {
    }
}
declare module VisiWin.UI {
    class NumericVarInCore extends VisiWin.UI.VariableBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            focusedChanged: {
                propertyType: string;
                group: string;
            };
            errorChanged: {
                propertyType: string;
                group: string;
            };
            focused: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
                forceOverwrite: boolean;
            };
            limitError: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            writeError: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            rawLimitMin: {
                propertyType: string;
                type: string;
            };
            rawLimitMax: {
                propertyType: string;
                type: string;
            };
            isLimitCheckEnabled: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            errorText: {
                propertyType: string;
                type: string;
                defaultValue: any;
            };
            limitMinErrorText: {
                propertyType: string;
                type: string;
            };
            localizableLimitMinErrorText: {
                propertyType: string;
                type: string;
            };
            limitMaxErrorText: {
                propertyType: string;
                type: string;
            };
            localizableLimitMaxErrorText: {
                propertyType: string;
                type: string;
            };
            variableWriteErrorText: {
                propertyType: string;
                type: string;
            };
            localizableVariableWriteErrorText: {
                propertyType: string;
                type: string;
            };
            watermarkText: {
                propertyType: string;
                type: string;
            };
            localizableWatermarkText: {
                propertyType: string;
                type: string;
            };
            preventDefault: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            stopPropagation: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            abortOnEsc: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            writeOnReturn: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            selectOnFocus: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            lostKeyboardFocusBehaviour: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            spellcheck: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            autocomplete: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            textContrast: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            useTouchKeyboard: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            touchKeyboardDialogName: {
                propertyType: string;
                type: string;
            };
            forceTouchKeyboardOnMobileDevice: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        limitError: boolean;
        private _previousLimitError;
        writeError: boolean;
        rawLimitMin: number;
        rawLimitMax: number;
        isLimitCheckEnabled: boolean;
        errorText: string;
        limitMinErrorText: string;
        limitMaxErrorText: string;
        variableWriteErrorText: string;
        watermarkText: string;
        preventDefault: boolean;
        stopPropagation: boolean;
        abortOnEsc: boolean;
        writeOnReturn: boolean;
        selectOnFocus: boolean;
        lostKeyboardFocusBehaviour: string;
        spellcheck: boolean;
        autocomplete: string;
        textAlignment: string;
        textContrast: string;
        private _oldInputValue;
        private _keyPress;
        private _checkValueLengthOnInput;
        private _boundKeyPressHandler;
        private _boundKeyDownHandler;
        private _boundKeyUpHandler;
        private _boundFocusHandler;
        private _boundBlurHandler;
        private _boundInputHandler;
        private _boundLocalizableWatermarkTextHandler;
        private _boundLocalizableLimitMinErrorTextHandler;
        private _boundLocalizableLimitMaxErrorTextHandler;
        private _boundLocalizableVariableWriteErrorTextHandler;
        private useTouchKeyboard;
        private touchKeyboardDialogName;
        private forceTouchKeyboardOnMobileDevice;
        private numericvarin;
        private _dialogControl;
        constructor(element: VWElement, options: any);
        preCheck(): number;
        beforeInit(): void;
        createHandler(): void;
        removeHandler(): void;
        private _localizableLimitMinErrorTextObject;
        private _localizableLimitMinErrorTextHandler;
        private _localizableLimitMinErrorText;
        get localizableLimitMinErrorText(): string;
        set localizableLimitMinErrorText(value: string);
        private _localizableLimitMaxErrorTextObject;
        private _localizableLimitMaxErrorTextHandler;
        private _localizableLimitMaxErrorText;
        get localizableLimitMaxErrorText(): string;
        set localizableLimitMaxErrorText(value: string);
        private _localizableVariableWriteErrorTextObject;
        private _localizableVariableWriteErrorTextHandler;
        private _localizableVariableWriteErrorText;
        get localizableVariableWriteErrorText(): string;
        set localizableVariableWriteErrorText(value: string);
        private _localizableWatermarkTextObject;
        private _localizableWatermarkTextHandler;
        private _localizableWatermarkText;
        get localizableWatermarkText(): string;
        set localizableWatermarkText(value: string);
        _updateLayout(changes: any): void;
        _onVariableValueChanged(variable: any, value: number): void;
        _writeValueFromVarIn(newValue: any): void;
        _writeValue(): void;
        _inputHandler(args: any): void;
        _keyPressHandler(event: any): boolean;
        _keyDownHandler(event: any): void;
        _keyUpHandler(event: any): void;
        _focusHandler(args: any): void;
        hideSoftKeyboard(element: any): void;
        _openKeyboard(): Promise<null>;
        _limitCheckTouchKeyboard(newValue: any): void;
        _blurHandler(args: any): void;
        _validateLimitMin(value: number): boolean;
        _validateLimitMax(value: number): boolean;
        _validateTypeMin(value: number): boolean;
        _validateTypeMax(value: number): boolean;
        _setSelect(start: number, end: number): void;
        _isNumericChar(char: any): boolean;
        _limitCheck(newValue: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ITextVarInCore extends IVariableBase {
    }
}
declare module VisiWin.UI {
    class TextVarInCore extends VisiWin.UI.VariableBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            focusedChanged: {
                propertyType: string;
                group: string;
            };
            errorChanged: {
                propertyType: string;
                group: string;
            };
            focused: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
                forceOverwrite: boolean;
            };
            limitError: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            writeError: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            textLengthMin: {
                propertyType: string;
                type: string;
            };
            textLengthMax: {
                propertyType: string;
                type: string;
            };
            isLimitCheckEnabled: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            errorText: {
                propertyType: string;
                type: string;
                defaultValue: any;
            };
            limitMinErrorText: {
                propertyType: string;
                type: string;
            };
            localizableLimitMinErrorText: {
                propertyType: string;
                type: string;
            };
            limitMaxErrorText: {
                propertyType: string;
                type: string;
            };
            localizableLimitMaxErrorText: {
                propertyType: string;
                type: string;
            };
            variableWriteErrorText: {
                propertyType: string;
                type: string;
            };
            localizableVariableWriteErrorText: {
                propertyType: string;
                type: string;
            };
            watermarkText: {
                propertyType: string;
                type: string;
            };
            localizableWatermarkText: {
                propertyType: string;
                type: string;
            };
            preventDefault: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            stopPropagation: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            abortOnEsc: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            writeOnReturn: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            selectOnFocus: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            lostKeyboardFocusBehaviour: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            inputType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            spellcheck: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            autocomplete: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            textContrast: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            useTouchKeyboard: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            touchKeyboardDialogName: {
                propertyType: string;
                type: string;
            };
            forceTouchKeyboardOnMobileDevice: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        limitError: boolean;
        writeError: boolean;
        textLengthMin: number;
        textLengthMax: number;
        isLimitCheckEnabled: boolean;
        errorText: string;
        limitMinErrorText: string;
        limitMaxErrorText: string;
        variableWriteErrorText: string;
        watermarkText: string;
        preventDefault: boolean;
        stopPropagation: boolean;
        abortOnEsc: boolean;
        writeOnReturn: boolean;
        selectOnFocus: boolean;
        lostKeyboardFocusBehaviour: string;
        inputType: string;
        spellcheck: boolean;
        autocomplete: string;
        textAlignment: string;
        textContrast: string;
        private _keyPress;
        private _boundKeyPressHandler;
        private _boundKeyDownHandler;
        private _boundKeyUpHandler;
        private _boundFocusHandler;
        private _boundBlurHandler;
        private _boundLocalizableWatermarkTextHandler;
        private _boundLocalizableLimitMinErrorTextHandler;
        private _boundLocalizableLimitMaxErrorTextHandler;
        private _boundLocalizableVariableWriteErrorTextHandler;
        private useTouchKeyboard;
        private touchKeyboardDialogName;
        private forceTouchKeyboardOnMobileDevice;
        private textvarin;
        private _dialogControl;
        constructor(element: VWElement, options: any);
        preCheck(): number;
        createHandler(): void;
        removeHandler(): void;
        private _localizableLimitMinErrorTextObject;
        private _localizableLimitMinErrorTextHandler;
        private _localizableLimitMinErrorText;
        get localizableLimitMinErrorText(): string;
        set localizableLimitMinErrorText(value: string);
        private _localizableLimitMaxErrorTextObject;
        private _localizableLimitMaxErrorTextHandler;
        private _localizableLimitMaxErrorText;
        get localizableLimitMaxErrorText(): string;
        set localizableLimitMaxErrorText(value: string);
        private _localizableVariableWriteErrorTextObject;
        private _localizableVariableWriteErrorTextHandler;
        private _localizableVariableWriteErrorText;
        get localizableVariableWriteErrorText(): string;
        set localizableVariableWriteErrorText(value: string);
        private _localizableWatermarkTextObject;
        private _localizableWatermarkTextHandler;
        private _localizableWatermarkText;
        get localizableWatermarkText(): string;
        set localizableWatermarkText(value: string);
        _updateLayout(changes: any): void;
        _onVariableValueChanged(variable: any, value: string): void;
        _writeValueFromVarIn(newValue: any): void;
        _writeValue(): void;
        _keyPressHandler(event: any): void;
        _keyDownHandler(event: any): void;
        _keyUpHandler(event: any): void;
        _focusHandler(args: any): void;
        hideSoftKeyboard(element: any): void;
        _openKeyboard(): Promise<null>;
        _limitCheckTouchKeyboard(newValue: any): void;
        _blurHandler(args: any): void;
        private _minLimitLengthExceeded;
        private _maxLimitLengthExceeded;
        /**
        * @deprecated do not use
        * @ignore
        */
        private _validateLimitMin;
        /**
        * @deprecated do not use
        * @ignore
        */
        private _validateLimitMax;
        _setSelect(start: number, end: number): void;
        _checkLengthLimits(): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IVarOutCore extends IVariableBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class VarOutCore extends VariableBase implements IVarOutCore {
        observe: any;
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {};
        _onVariableValueChanged(variable: any, value: number): void;
        constructor(element: any, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IDonutGaugeCore extends VisiWin.UI.IVariableBase {
        rawLimitMin: number;
        rawLimitMax: number;
        startAngle: number;
        endAngle: number;
        centerX: string;
        centerY: string;
        innerRadius: string;
        outerRadius: string;
        limits: any;
        indicatorBackgroundColor: string;
        indicatorColor: string;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class DonutGaugeCore extends VisiWin.UI.VariableBase {
        private properties;
        private cssStyles;
        rawLimitMin: number;
        rawLimitMax: number;
        startAngle: number;
        endAngle: number;
        centerX: string;
        centerY: string;
        innerRadius: string;
        outerRadius: string;
        limits: any;
        private _svgElement;
        private _limitsCollection;
        private _clientWidth;
        private _clientHeight;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        registerChild(controlType: string, action: string, limit: VWElement, options: any): any;
        resizeHandler(entries: any): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _drawDonut(width: number, height: number): void;
        _limitsChangedHandler(args: any): void;
    }
}
declare module VisiWin.UI {
    interface ISliderCore extends IVariableBase {
        directWrite: boolean;
        active: boolean;
        step: number;
        pvalue: number;
        value: any;
        variableName: string;
        snaps: boolean;
        maxMarkers: number;
        dragging: boolean;
        immediateValue: any;
        minValue: number;
        maxValue: number;
        indeterminate: boolean;
        secondaryProgressValue: number;
        activeProgressColor: string;
        secondaryProgressColor: string;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class SliderCore extends VisiWin.UI.VariableBase {
        static classPressed: string;
        static classDragging: string;
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            touchElement: {
                propertyType: string;
                type: string;
            };
            pressedChanged: {
                propertyType: string;
                group: string;
            };
            draggingChanged: {
                propertyType: string;
                group: string;
            };
            thumbPositionChanged: {
                propertyType: string;
                group: string;
            };
            pressed: {
                propertyType: string;
                type: string;
            };
            dragging: {
                propertyType: string;
                type: string;
            };
            rawLimitMin: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            rawLimitMax: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            step: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            immediate: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            orientation: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            orientationReversed: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            trackThickness: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            trackBorderRadius: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            minValue: {
                propertyType: string;
                type: string;
            };
            maxValue: {
                propertyType: string;
                type: string;
            };
            thumbBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            thumbBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            thumbBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            thumbWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            thumbHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            thumbMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            thumbPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            thumbShadow: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
                resourceValue: string[];
            };
            activeTrackColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverActiveTrackColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedActiveTrackColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledActiveTrackColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            trackColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverTrackColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedTrackColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledTrackColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            thumbBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverThumbBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedThumbBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledThumbBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            thumbBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverThumbBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedThumbBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledThumbBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        rawLimitMin: number;
        rawLimitMax: number;
        step: number;
        immediate: boolean;
        orientation: string;
        orientationReversed: boolean;
        trackThickness: string;
        trackBorderRadius: string;
        thumbBorderWidth: string;
        thumbBorderStyle: string;
        thumbBorderRadius: string;
        thumbWidth: string;
        thumbHeight: string;
        thumbMargin: string;
        thumbPadding: string;
        thumbShadow: string;
        activeTrackColor: string;
        hoverActiveTrackColor: string;
        pressedActiveTrackColor: string;
        disabledActiveTrackColor: string;
        trackColor: string;
        hoverTrackColor: string;
        pressedTrackColor: string;
        disabledTrackColor: string;
        thumbBackgroundColor: string;
        hoverThumbBackgroundColor: string;
        pressedThumbBackgroundColor: string;
        disabledThumbBackgroundColor: string;
        thumbBorderColor: string;
        hoverThumbBorderColor: string;
        pressedThumbBorderColor: string;
        disabledThumbBorderColor: string;
        private _activeTrackElement;
        private _trackElement;
        private _thumbElement;
        private _posX;
        private _posY;
        private _boundKeyDownHandler;
        private _boundPointerDownHandler;
        private _boundPointerMoveHandler;
        private _boundPointerUpHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        resizeHandler(): void;
        set minValue(value: any);
        set maxValue(value: any);
        private _touchElement;
        get touchElement(): VWElement;
        set touchElement(value: VWElement);
        private _pressed;
        get pressed(): boolean;
        set pressed(value: boolean);
        private _dragging;
        get dragging(): boolean;
        set dragging(value: boolean);
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _keyDownHandler(e: any): void;
        _pointerDownHandler(e: any): void;
        _pointerMoveHandler(e: any): void;
        _pointerUpHandler(e: any): void;
        _valueToPixel(): any;
        _pixelToValue(): number;
        _updateSliderLayout(): void;
        _clampValue(value: any, min: any, max: any): number;
        _roundValue(value: any, step: any): number;
        attach(): Promise<any>;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IDateTimeVarInCore extends IVariableBase {
        inputType: string;
        errorText: string;
        isWriteError: boolean;
        isLimit: boolean;
        writeOnReturn: boolean;
        writeOnTab: boolean;
        watermarkText: string;
        textLengthMin: number;
        textLengthMax: number;
        dispatchEvent: any;
        localizableErrorText: any;
        textAlignment: string;
        localizableWatermarkText: string;
        setSelect(start: number, end: number): void;
        inputInfo(elementx: HTMLElement): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class DateTimeVarInCore extends VisiWin.UI.VariableBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            focusedChanged: {
                propertyType: string;
                group: string;
            };
            errorChanged: {
                propertyType: string;
                group: string;
            };
            invalidDate: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            limitError: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            writeError: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            limitMin: {
                propertyType: string;
                type: string;
            };
            limitMax: {
                propertyType: string;
                type: string;
            };
            isLimitCheckEnabled: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            dateTimeMode: {
                propertyType: string;
                type: string;
                defaultValue: DateTimeModeNames;
            };
            formatDate: {
                propertyType: string;
                type: string;
                defaultValue: DateTimeFormatNames;
            };
            formatTime: {
                propertyType: string;
                type: string;
                defaultValue: DateTimeFormatNames;
            };
            userDefinedDate: {
                propertyType: string;
                type: string;
            };
            userDefinedTime: {
                propertyType: string;
                type: string;
            };
            step: {
                propertyType: string;
                type: string;
            };
            errorText: {
                propertyType: string;
                type: string;
                defaultValue: any;
            };
            invalidDateErrorText: {
                propertyType: string;
                type: string;
            };
            localizableInvalidDateErrorText: {
                propertyType: string;
                type: string;
            };
            limitMinErrorText: {
                propertyType: string;
                type: string;
            };
            localizableLimitMinErrorText: {
                propertyType: string;
                type: string;
            };
            limitMaxErrorText: {
                propertyType: string;
                type: string;
            };
            localizableLimitMaxErrorText: {
                propertyType: string;
                type: string;
            };
            variableWriteErrorText: {
                propertyType: string;
                type: string;
            };
            localizableVariableWriteErrorText: {
                propertyType: string;
                type: string;
            };
            watermarkText: {
                propertyType: string;
                type: string;
            };
            localizableWatermarkText: {
                propertyType: string;
                type: string;
            };
            preventDefault: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            stopPropagation: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            abortOnEsc: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            writeOnReturn: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            selectOnFocus: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            lostKeyboardFocusBehaviour: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            inputMode: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            spellcheck: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            autocomplete: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            textContrast: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
        };
        invalidDate: boolean;
        limitError: boolean;
        writeError: boolean;
        limitMin: string;
        limitMax: string;
        isLimitCheckEnabled: boolean;
        dateTimeMode: string;
        formatDate: string;
        formatTime: string;
        userDefinedDate: string;
        userDefinedTime: string;
        errorText: string;
        invalidDateErrorText: string;
        limitMinErrorText: string;
        limitMaxErrorText: string;
        variableWriteErrorText: string;
        watermarkText: string;
        preventDefault: boolean;
        stopPropagation: boolean;
        abortOnEsc: boolean;
        writeOnReturn: boolean;
        selectOnFocus: boolean;
        lostKeyboardFocusBehaviour: string;
        inputMode: string;
        spellcheck: boolean;
        autocomplete: string;
        textAlignment: string;
        textContrast: string;
        step: number;
        private _keyPress;
        private _boundKeyPressHandler;
        private _boundKeyDownHandler;
        private _boundKeyUpHandler;
        private _boundFocusHandler;
        private _boundBlurHandler;
        private _boundChange;
        private _boundLocalizableInvalidDateErrorTextHandler;
        private _boundLocalizableLimitMinErrorTextHandler;
        private _boundLocalizableLimitMaxErrorTextHandler;
        private _boundLocalizableVariableWriteErrorTextHandler;
        private _boundLocalizableWatermarkTextHandler;
        constructor(element: VWElement, options: any);
        preCheck(): number;
        createHandler(): void;
        removeHandler(): void;
        private _localizableInvalidDateErrorTextObject;
        private _localizableInvalidDateErrorTextHandler;
        private _localizableInvalidDateErrorText;
        get localizableInvalidDateErrorText(): string;
        set localizableInvalidDateErrorText(value: string);
        private _localizableLimitMinErrorTextObject;
        private _localizableLimitMinErrorTextHandler;
        private _localizableLimitMinErrorText;
        get localizableLimitMinErrorText(): string;
        set localizableLimitMinErrorText(value: string);
        private _localizableLimitMaxErrorTextObject;
        private _localizableLimitMaxErrorTextHandler;
        private _localizableLimitMaxErrorText;
        get localizableLimitMaxErrorText(): string;
        set localizableLimitMaxErrorText(value: string);
        private _localizableVariableWriteErrorTextObject;
        private _localizableVariableWriteErrorTextHandler;
        private _localizableVariableWriteErrorText;
        get localizableVariableWriteErrorText(): string;
        set localizableVariableWriteErrorText(value: string);
        private _localizableWatermarkTextObject;
        private _localizableWatermarkTextHandler;
        private _localizableWatermarkText;
        get localizableWatermarkText(): string;
        set localizableWatermarkText(value: string);
        private _originalDate;
        _updateLayout(changes: any): void;
        _checkIfStepAttributeIsCorrect(): void;
        _onVariableValueChanged(variable: any, value: any): void;
        _writeValue(): void;
        _keyPressHandler(event: any): void;
        _keyDownHandler(event: any): void;
        _keyUpHandler(event: any): void;
        _focusHandler(args: any): void;
        _changeHandler(args: any): void;
        _blurHandler(args: any): void;
        _formattingDateTime(value: any, inputMode: string, dateTimeMode: string, formatDate: string, formatTime: string, userDefinedDate: any, userDefinedTime: any): string;
        _validateDate(value: any): boolean;
        _validateLimitMin(value: any): boolean;
        _validateLimitMax(value: any): boolean;
        _setSelect(start: number, end: number, inputMode: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAbsoluteLayout extends ILayoutBase {
        backgroundColor: string;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AbsoluteLayout extends VisiWin.UI.LayoutBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                defaultValue: string;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            removeMargins: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        overflow: string;
        removeMargins: boolean;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        ready(): void;
        mutationHandlerDesignMode(): void;
        _setPosition(element: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IFlexLayout extends ILayoutBase {
        orientation: string;
        alignItems: string;
        justifyContent: string;
        wrap: boolean;
        backgroundColor: string;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class FlexLayout extends VisiWin.UI.LayoutBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                defaultValue: string;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            orientation: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            wrap: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        overflow: string;
        orientation: string;
        alignItems: string;
        justifyContent: string;
        alignContent: string;
        wrap: boolean;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ICardLayout extends ILayoutBase {
        /**
          * constructor: Creates a new Header.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new Header control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        ready(element: HTMLElement, options: any): void;
        shadow: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class CardLayout extends VisiWin.UI.LayoutBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            scrollYOffset: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            columnWidth: {
                propertyType: string;
                type: string;
            };
            deviceType: {
                propertyType: string;
                type: string;
            };
            gutterPhone: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            gutterTablet: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            gutterDesktop: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            gutterLargeDesktop: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            paddingPhone: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            paddingTablet: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            paddingDesktop: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            paddingLargeDesktop: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        overflow: string;
        scrollYOffset: number;
        columnWidth: string;
        deviceType: string;
        gutterPhone: string;
        gutterTablet: string;
        gutterDesktop: string;
        gutterLargeDesktop: string;
        paddingPhone: string;
        paddingTablet: string;
        paddingDesktop: string;
        paddingLargeDesktop: string;
        backgroundColor: string;
        borderColor: string;
        private pageControl;
        private cards;
        private _childs;
        constructor(element: VWElement, options: any);
        ready(): void;
        registerChild(controlType: string, action: string, element: VWElement, options: any): boolean;
        _updateLayout(changes: any): void;
        _refreshCardLayout(): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IScrollViewer extends ILayoutBase {
        scrollX: boolean;
        backgroundColor: string;
        scrollY: boolean;
        createControl(element: HTMLElement, options: any): any;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ScrollViewer extends VisiWin.UI.LayoutBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                defaultValue: string;
            };
            scrollX: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            scrollY: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            scrollXOffset: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            scrollYOffset: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        scrollX: boolean;
        scrollY: boolean;
        scrollXOffset: number;
        scrollYOffset: number;
        backgroundColor: string;
        borderColor: string;
        private _scrollContainerElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        ready(): void;
        mutationHandlerDesignMode(): void;
        _updateLayout(changes: any): void;
        _reparentChildren(originalParent: any, destinationParent: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Page extends VisiWin.UI.ControlBase {
        static namespace: string;
        static readonly controlName = "Page";
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            title: {
                propertyType: string;
            };
            localizableTitle: {
                propertyType: string;
            };
            location: {
                propertyType: string;
                typy: string;
            };
        };
        backgroundColor: string;
        constructor(element: VWElement, options: any);
        private _location;
        get location(): string;
        set location(value: string);
        private _boundTextHandler;
        private _textObject;
        private _textHandler;
        private _title;
        get title(): string;
        set title(value: string);
        private _boundLocalizableTextHandler;
        private _localizableTextObject;
        private _localizableTextHandler;
        private _localizableTitle;
        get localizableTitle(): string;
        set localizableTitle(value: string);
        attached(): void;
        postSetOptions(element: any, options: any): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class View extends VisiWin.UI.ControlBase {
        static namespace: string;
        static readonly controlName = "View";
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            title: {
                propertyType: string;
            };
            localizableTitle: {
                propertyType: string;
            };
            location: {
                propertyType: string;
                typy: string;
            };
        };
        overflow: string;
        backgroundColor: string;
        constructor(element: VWElement, options: any);
        private _location;
        get location(): string;
        set location(value: string);
        private _boundTextHandler;
        private _textObject;
        private _textHandler;
        private _Title;
        get title(): string;
        set title(value: string);
        private _boundLocalizableTextHandler;
        private _localizableTextObject;
        private _localizableTextHandler;
        private _localizableTitle;
        get localizableTitle(): string;
        set localizableTitle(value: string);
        attached(): void;
        postSetOptions(element: any, options: any): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        dispose(): boolean;
        resolve(url: any, base_url: any): any;
    }
}
declare module VisiWin.UI {
    class StylingView extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class DialogView extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            BeforeShow: {
                propertyType: string;
            };
            BeforeHide: {
                propertyType: string;
            };
            AfterShow: {
                propertyType: string;
            };
            AfterHide: {
                propertyType: string;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        overflow: string;
        backgroundColor: string;
        private _dialogControl;
        constructor(element: VWElement, options: any);
        ready(): void;
        private _getPopUPControl;
        private _boundBeforeShowHandler;
        private _boundBeforeHideHandler;
        private _boundAfterShowHandler;
        private _boundAafterHideHandler;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class TemplateView extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        overflow: string;
        backgroundColor: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class UserControlView extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Container extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            innerHtml: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        innerHtml: string;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class ViewBox extends VisiWin.UI.LayoutBase implements IViewBox {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                defaultValue: string;
            };
            removeMargins: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            stretchMode: {
                propertyType: string;
                type: string;
                defaultValue: Enums.StretchMode;
            };
            stretchDirection: {
                propertyType: string;
                type: string;
                defaultValue: Enums.StretchDirection;
            };
            overFlow: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            defaultDeviceWidth: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            defaultDeviceHeight: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            stretchInDesignMode: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            stretchAnchor: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        removeMargins: boolean;
        stretchMode: VisiWin.UI.Enums.StretchMode;
        stretchDirection: VisiWin.UI.Enums.StretchDirection;
        overFlow: string;
        defaultDeviceWidth: string;
        defaultDeviceHeight: string;
        stretchInDesignMode: boolean;
        stretchAnchor: string;
        backgroundColor: string;
        borderColor: string;
        defaultHeight: number;
        defaultWidth: number;
        tempElement: any;
        private firstLoad;
        private _desiredPageClassName;
        private _pageElement;
        setPageElement(pageClassName: string): void;
        constructor(element: VWElement, options: any);
        ready(): void;
        mutationHandlerDesignMode(): void;
        _setPosition(element: any): void;
        changelistener(pageWidth: number, pageHeight: number): void;
        stretchFill(pageWidth: number, pageHeight: number): void;
        stretchUniform(pageWidth: number, pageHeight: number): void;
        stretchUniformToFill(pageWidth: number, pageHeight: number): void;
        private previousWidth;
        private previousHeight;
        resizeObserver: ResizeObserver;
        attach(): Promise<any> | null;
        dispose(): boolean;
        detach(): Promise<any>;
    }
}
declare namespace VisiWin.UI {
    interface IViewBox extends VisiWin.UI.LayoutBase {
        /**
        * @description Describes how the content is scaled to fill the entire allocated space. None|Fill|Uniform
        * @description The default value is "None".
        * @member { string } stretchMode
        * @see {@link VisiWin.UI.Enums.StretchMode|stretchMode(Enum)} <br>
        */
        stretchMode: VisiWin.UI.Enums.StretchMode;
        /**
        * @description Describes how scaling is applied to content, and restricts scaling to named axis types. Both|DownOnly|UpOnly
        * @description The default value is "Both".
        * @member { string } stretchDirection
        * @see {@link VisiWin.UI.Enums.StretchDirection|stretchdirection(Enum)} <br>
        */
        stretchDirection: VisiWin.UI.Enums.StretchDirection;
        /**
        * @description The overflow property specifies whether to clip the content or to add scrollbars when the content of an element is too big to fit in the specified area. Visible|Hidden|Scroll|Auto
        * @member { string } overFlow
        */
        overFlow: string;
        /**
         * @description Sets the default width, with which the layout was designed originally.
         * @member { string } defaultDeviceWidth
         */
        defaultDeviceWidth: string;
        /**
         * @description Sets the default height, with which the layout was designed originally.
         * @member { string } defaultDeviceHeight
         */
        defaultDeviceHeight: string;
        /**
         * @description Whether the scaling is applied while in DesignMode.
         * @member { string } stretchInDesignMode
         */
        stretchInDesignMode: boolean;
        /**
         * @description Sets the anchor point for the transformation of the viewbox.
         * @description The default value is "left top".
         * @member { string } stretchAnchor
         */
        stretchAnchor: string;
        /**
        * @method Connected to the Resize Observer to handle changes in the size of the page
        * @name changelistener
        * @param {number} pageWidth New width of the page after a sizechanged event
        * @param {number} pageHeight  New height of the page after a sizechanged event
        */
        changelistener(pageWidth: number, pageHeight: number): void;
        /**
        * @method Scales the page and dismisses the page ratio.
        * @name stretchFill
        * @param {number} pageWidth New width of the page after a sizechanged event
        * @param {number} pageHeight  New height of the page after a sizechanged event
        */
        stretchFill(pageWidth: number, pageHeight: number): void;
        /**
        * @method Scales the page and keeps the page ratio
        * @name stretchUniform
        * @param {number} pageWidth New width of the page after a sizechanged event
        * @param {number} pageHeight  New height of the page after a sizechanged event
        */
        stretchUniform(pageWidth: number, pageHeight: number): void;
        /**
        * @method Scales the page to full size and keeps the page ratio.
        * @name stretchUniformToFill
        * @param {number} pageWidth New width of the page after a sizechanged event
        * @param {number} pageHeight  New height of the page after a sizechanged event
        */
        stretchUniformToFill(pageWidth: number, pageHeight: number): void;
    }
}
declare namespace VisiWin.UI {
    class DataTemplateView extends VisiWin.UI.ControlBase {
        private properties;
        innerHTML: string;
        dataTemplateName: string;
        private cssStyles;
        constructor(element: VWElement, options: any);
        loadTemplate(): void;
    }
}
declare module VisiWin.UI {
    class AppShellRegion extends VisiWin.UI.RegionBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            viewName: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        private _boundNavigatedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        beforeInit(): void;
        _navigatedHandler(args: any): void;
        dispose(): any;
    }
}
declare module VisiWin.UI {
    class App extends VisiWin.UI.RegionBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            viewName: {
                propertyType: string;
                type: string;
            };
        };
        private _boundNavigatedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        beforeInit(): void;
        _navigatedHandler(args: any): void;
        dispose(): any;
    }
}
declare module VisiWin.UI {
    interface IAppLayoutBase extends IControlBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    abstract class AppLayoutBase extends VisiWin.UI.ControlBase implements IAppLayoutBase {
        static namespace: string;
        static controlName: string;
        static propertyList: {};
        private _boundKeyDownTextField;
        private firstPreload;
        constructor(element: VWElement, options: any);
        preloadSub(page: string, mainPage?: string): Promise<void>;
        ready(): Promise<void>;
        _keyDownTextField(e: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAppBaseLayout extends VisiWin.UI.IAppLayoutBase {
        backgroundColor: string;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppBaseLayout extends VisiWin.UI.AppLayoutBase implements IAppBaseLayout {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            pageName: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: any;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        pageName: string;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        ready(): Promise<void>;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppLayout extends VisiWin.UI.AppLayoutBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            pageName: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: any;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        pageName: string;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        ready(): Promise<void>;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAppSideNavLayout extends VisiWin.UI.IAppLayoutBase {
        backgroundColor: string;
        edgeSwipeSensitivity: string;
        forceNarrow: boolean;
        disableEdgeSwipe: boolean;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppSideNavLayout extends VisiWin.UI.AppLayoutBase implements IAppSideNavLayout {
        static namespace: string;
        static controlName: string;
        static className: string;
        static classScrim: string;
        static classClipped: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            drawerMode: {
                propertyType: string;
                defaultValue: string;
            };
            responsiveWidth: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            edgeSwipeSensitivity: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            disableEdgeSwipe: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            open: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        responsiveWidth: string;
        edgeSwipeSensitivity: string;
        disableEdgeSwipe: boolean;
        backgroundColor: string;
        borderColor: string;
        private _scrim;
        private _leftButton;
        private _rightButton;
        private _leftDrawer;
        private _rightDrawer;
        private _contentControl;
        private _titelElement;
        private _dragElement;
        private _selector;
        forceNarrow: boolean;
        private _cnt;
        private _buttonCnt;
        private _drawerCnt;
        private _responsiveFlag;
        private _menueStatus;
        private _optionsStatus;
        private _leftDrawerActive;
        private _rightDrawerActive;
        private _dragState;
        private _dragFlagLeft;
        private _drawerTotalWidth;
        private _drawerLeftWidth;
        private _drawerRightWidth;
        private _leftDrawerWidth;
        private _rightDrawerWidth;
        private _dragMin;
        private _dragMax;
        private _dragStartX;
        private _dragXStart;
        private _dragYStart;
        private _dx;
        private dragThreshold;
        private _leftDrawerzIndex;
        private _rightDrawerzIndex;
        private _menuStartIndex;
        private _pastDrawerinit;
        private _dragOnEvent;
        private _dragOffEvent;
        private _boundPointerDownHandler;
        private _boundPointerMoveHandler;
        private _boundPointerCancelHandler;
        private _boundPointerUpHandler;
        private _boundMenueDrawOn;
        private _boundMenueDrawOff;
        private _boundMenueHandlerOn;
        private _boundMenueHandlerOff;
        private _boundOptionsDrawOn;
        private _boundOptionsDrawOff;
        private _boundOptionsHandlerOn;
        private _boundOptionsHandlerOff;
        private _boundTmpDrawerOffHandler;
        private _boundSelectorActionHandler;
        constructor(element: VWElement, options: any);
        preCheck(): number;
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        ready(): Promise<void>;
        registerChild(controlType: string, action: string, element: VWElement, options: any): boolean;
        private _drawerMode;
        get drawerMode(): string;
        set drawerMode(value: string);
        private _open;
        get open(): boolean;
        set open(value: boolean);
        _updateDrawer(): void;
        _calcDrawer(): void;
        _checkBorder(val: number, min: number, max: number, strFlag: boolean): any;
        _registerTitel(element: VWElement, action: string, options: any): void;
        _registerContent(element: VWElement, action: string, options: any): void;
        _registerSelector(element: VWElement, action: string, options: any): void;
        _registerButton(element: VWElement, action: string, options: any): void;
        _registerHamburger(element: VWElement, action: string, options: any): void;
        _registerMenu(element: any, action: any, options: any): void;
        _registerDrawer(element: VWElement, action: string, options: any): void;
        _pointerDownHandler(inEvent: PointerEvent): void;
        _pointerMoveHandler(inEvent: PointerEvent): void;
        _pointerCancelHandler(inEvent: PointerEvent): void;
        _pointerUpHandler(inEvent: PointerEvent): void;
        _menueDrawOn(args?: any): void;
        _menueDrawOff(): void;
        _menueHandlerOn(): void;
        _menueHandlerOff(): void;
        _optionsDrawOn(args: any): void;
        resizeHandler(entries: any): void;
        _optionsDrawOff(): void;
        _optionsHandlerOn(): void;
        _optionsHandlerOff(): void;
        _responsiveOn(): void;
        _responsiveOff(): void;
        _tmpDrawerOffHandler(args: any): void;
        _selectorActionHandler(args: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppNavDrawer extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            width: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        private _selectorElement;
        private _parent;
        private _boundActionHandler;
        constructor(element: VWElement, options: any);
        removeHandler(): void;
        registerChild(controlType: any, action: any, element: any, options: any): boolean;
        _actionHandler(args: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAppDrawerHeader extends VisiWin.UI.IControlBase {
        backgroundColor: string;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppDrawerHeader extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAppNavMenu extends IControlBase {
        backgroundColor: string;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppNavMenu extends VisiWin.UI.NavGroupBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            menuItems: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        menuItems: string;
        backgroundColor: string;
        borderColor: string;
        private _scrollElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        ready(element: VWElement, options: any): Promise<void>;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppBarLayout extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            margin: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        ready(): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppBar extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        registerChild(controlType: string, action: string, element: HTMLElement, options: any): any;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAppToolbar extends VisiWin.UI.IControlBase {
        /**
          * constructor: Creates a new Header.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new Header control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Header control.
        **/
        ready(element: HTMLElement, options: any): void;
        shadow: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppToolbar extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAppNavMenuButton extends VisiWin.UI.IButtonBase {
        symbol: string;
        symbolType: string;
        symbolSize: string;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppNavMenuButton extends VisiWin.UI.ButtonBase implements VisiWin.UI.IAppNavMenuButton {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        symbol: string;
        symbolType: string;
        symbolSize: string;
        backgroundColor: string;
        foregroundColor: string;
        borderColor: string;
        private _symbolElement;
        constructor(element: VWElement, options: any);
        beforeInitBase(): void;
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppPageTitle extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            showText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            textWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            text: {
                propertyType: string;
                type: string;
                child: string;
            };
            localizableText: {
                propertyType: string;
                type: string;
                child: string;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            lineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            textWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            textTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontClass: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            fontSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontWeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            lineHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            textContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            uppercase: {
                propertyType: string;
                type: string;
                child: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        showText: boolean;
        textWidth: string;
        textHeight: string;
        textMargin: string;
        textPadding: string;
        text: string;
        localizableText: string;
        textAlignment: string;
        lineClamp: number;
        textWrapping: string;
        textTrimming: string;
        fontClass: string;
        fontSize: string;
        fontWeight: string;
        lineHeight: string;
        textContrast: number;
        uppercase: boolean;
        backgroundColor: string;
        foregroundColor: string;
        borderColor: string;
        private _textElement;
        private _appSideNavLayout;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        ready(element: VWElement, options: any): void;
        private _boundLocalizableTextHandler;
        private _localizableTextObject;
        private _localizableTextHandler;
        private _localizableTitle;
        get localizableAppPageTitle(): string;
        set localizableAppPageTitle(value: string);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAppPageNavigator extends VisiWin.UI.IRegionBase {
        readonly pageControl: any;
        readonly pageElement: any;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AppPageNavigator extends VisiWin.UI.RegionBase implements VisiWin.UI.IAppPageNavigator {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        home: string;
        constructor(element: VWElement, options: any);
        ready(element: VWElement, options: any): Promise<void>;
        dispose(): any;
    }
}
declare module VisiWin.UI {
    class AppErrorList extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        foregroundColor: string;
        borderColor: string;
        private _repeaterElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        beforeInit(): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IDesignerContainer extends VisiWin.UI.IControlBase {
        pageOptions: any;
        navEvent: any;
        lastNavigationPromise: Promise<any>;
        pageName: string;
        readonly pageControl: any;
        readonly pageElement: any;
        dispose(): any;
    }
}
/**
*  module VisiWin.UI.DesignerContainer                                  UIControl
*
*  Funktion:
*      Dynamischer Container zur Darstellung eines PageControls im Designer.
*
*  Abgeleitet von:
*      ControlBase

*  Constructor Parameter:
*      Bei der Definition von UI.Control üblichen zwei Parameter werden an die Basisklasse
*      weitergegeben:
*      element:VWElement       HTML Element auf dem das Control angewendet werden soll.
*      options:any             Object in dem die Options für das Control enthaltensind*
*/
declare module VisiWin.UI {
    class DesignerContainer extends VisiWin.UI.RegionBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static classNamePageControl: string;
        static DesignerContainerOptionsList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            height: {
                propertyType: string;
                defaultValue: string;
            };
            width: {
                propertyType: string;
                defaultValue: string;
            };
            pageName: {
                propertyType: string;
                type: string;
            };
            pageOptions: {
                propertyType: string;
                type: string;
                invisible: boolean;
            };
            navEvent: {
                propertyType: string;
                type: string;
                invisible: boolean;
            };
            pageControl: {
                propertyType: string;
                type: string;
                access: string;
                invisible: boolean;
            };
            pageElement: {
                propertyType: string;
                type: string;
                access: string;
                invisible: boolean;
            };
        };
        private boundNavigatedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(element: VWElement, options: any): any;
        createHandler(): void;
        removeHandler(): void;
        navigatedHandler(args: any): void;
        dispose(): any;
    }
}
declare module VisiWin.UI {
    interface IRegion extends VisiWin.UI.IControlBase {
        pageName: string;
        pageOptions: any;
        readonly pageControl: any;
        readonly pageElement: any;
        dispose(): any;
    }
}
declare module VisiWin.UI {
    class Region extends VisiWin.UI.RuntimeRegionBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        overflow: string;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        dispose(): any;
    }
}
declare module VisiWin.UI {
    interface ITextBlock extends VisiWin.UI.IControlBase {
        show: boolean;
        text: string;
        locText: string;
        localizableText: string;
        textAlignment: string;
        lineClamp: number;
        uppercase: boolean;
        textWrapping: string;
        textTrimming: string;
        textShadow: string;
        fontClass: string;
        fontSize: string;
        fontWeight: string;
        lineHeight: string;
        textContrast: number;
        foregroundColor: string;
        backgroundColor: string;
        borderColor: string;
        disabledForegroundColor: string;
        disabledBackgroundColor: string;
        disabledBorderColor: string;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class TextBlock extends VisiWin.UI.TextBase {
        private properties;
        private cssStyles;
        backgroundColor: string;
        foregroundColor: string;
        borderColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        constructor(element: VWElement, options: any);
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
    }
}
declare module VisiWin.UI {
    interface ITextVarOutCore extends VisiWin.UI.IVariableBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class TextVarOutCore extends VariableBase implements ITextVarOutCore {
        static namespace: string;
        static controlName: string;
        static classTextVarOutCore: string;
        static TextVarOutCoreOptionList: {};
        constructor(element: any, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IValue extends VisiWin.UI.IVariableBase {
        unit: string;
        value: any;
        unitText: string;
        unitWidth: string;
        disabledColor: string;
        valueMargin: string;
        unitMargin: string;
        valueFontClassName: string;
        valueFontClass: string;
        valueFontFamily: string;
        valueFontSize: string;
        valueFontWeight: string;
        valueLineHeight: string;
        unitFontClassName: string;
        unitFontClass: string;
        unitFontFamily: string;
        unitFontSize: string;
        unitFontWeight: string;
        unitLineHeight: string;
        unitAlignment: string;
        foregroundColor: string;
        backgroundColor: string;
        borderColor: string;
        disabledBorderColor: string;
        disabledForegroundColor: string;
        disabledBackgroundColor: string;
        valueElement: any;
        unitElement: any;
        decimalPlaces: number;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IValuePresenter extends VisiWin.UI.IVariableBase {
    }
}
declare namespace VisiWin.UI {
    class ValuePresenter extends VisiWin.UI.VariableBase {
        private properties;
        private cssStyles;
        showValue: boolean;
        valueWidth: string;
        valueHeight: string;
        valueMargin: string;
        valuePadding: string;
        valueTextAlignment: string;
        valueLineClamp: number;
        valueTextWrapping: string;
        valueTextTrimming: string;
        valueFontClass: string;
        valueFontSize: string;
        valueFontWeight: string;
        valueLineHeight: string;
        valueTextContrast: number;
        showUnit: boolean;
        unitWidth: string;
        unitHeight: string;
        unitMargin: string;
        unitPadding: string;
        unitTextAlignment: string;
        unitLineClamp: number;
        unitTextWrapping: string;
        unitTextTrimming: string;
        unitFontClass: string;
        unitFontSize: string;
        unitFontWeight: string;
        unitLineHeight: string;
        unitTextContrast: number;
        unitPosition: string;
        show: boolean;
        valueBackgroundColor: string;
        valueForegroundColor: string;
        unitBackgroundColor: string;
        unitForegroundColor: string;
        borderColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        private _valueControl;
        private _unitControl;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
    }
}
declare module VisiWin.UI {
    interface IMenu extends IControlBase {
        backgroundColor: string;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Menu extends GroupBase implements IMenu {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            collectionPropertyName: {
                propertyType: string;
                type: string;
            };
            menuItems: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        collectionPropertyName: string;
        menuItems: any;
        backgroundColor: string;
        borderColor: string;
        private _scrollElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IMenuButton extends VisiWin.UI.IButtonBase {
        symbol: string;
        symbolType: string;
        symbolSize: string;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class MenuButton extends VisiWin.UI.ButtonBase implements IMenuButton {
        static namespace: string;
        static controlName: string;
        static className: string;
        static MenuButtonOptionsList: {
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                childElement: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                childElement: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                childElement: string;
            };
        };
        symbol: string;
        symbolType: string;
        symbolSize: string;
        private _symbolElement;
        constructor(element: VWElement, options: any);
        createControl(element: any, options: any): any;
        beforeInit(element: any, options: any): void;
        afterInit(element: any, options: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IPopup extends VisiWin.UI.IControlBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Popup extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            beforeShowChanged: {
                propertyType: string;
            };
            beforeHideChanged: {
                propertyType: string;
            };
            afterShowChanged: {
                propertyType: string;
            };
            afterHideChanged: {
                propertyType: string;
            };
            anchor: {
                propertyType: string;
                type: string;
            };
            placement: {
                propertyType: string;
                type: string;
            };
            alignment: {
                propertyType: string;
                type: string;
            };
            mode: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            viewName: {
                propertyType: string;
                type: string;
            };
            showAtX: {
                propertyType: string;
                type: string;
            };
            showAtY: {
                propertyType: string;
                type: string;
            };
            popupBackgroundColor: {
                propertyType: string;
                type: string;
                defaultColor: string;
            };
        };
        anchor: any;
        placement: string;
        alignment: string;
        mode: string;
        viewName: string;
        showAtX: string;
        showAtY: string;
        private _popupElement;
        private _popupControl;
        private _boundBeforeShowChangedHandler;
        private _boundBeforeHideChangedHandler;
        private _boundAfterShowChangedHandler;
        private _boundAfterHideChangedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        private _popupBackgroundColor;
        get popupBackgroundColor(): string;
        set popupBackgroundColor(value: string);
        _createPopup(): any;
        _beforeShowChangedHandler(args: any): void;
        _beforeHideChangedHandler(args: any): void;
        _afterShowChangedHandler(args: any): void;
        _afterHideChangedHandler(args: any): void;
        show(): void;
        hide(result: any): void;
        showAt(xPos: number, yPos: number): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Popover extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            beforeShowChanged: {
                propertyType: string;
            };
            beforeHideChanged: {
                propertyType: string;
            };
            afterShowChanged: {
                propertyType: string;
            };
            afterHideChanged: {
                propertyType: string;
            };
            selectedIndexChanged: {
                propertyType: string;
            };
            menuElement: {
                propertyType: string;
                type: string;
            };
            anchor: {
                propertyType: string;
                type: string;
            };
            placement: {
                propertyType: string;
                type: string;
            };
            alignment: {
                propertyType: string;
                type: string;
            };
            mode: {
                propertyType: string;
                type: string;
            };
            pageName: {
                propertyType: string;
                type: string;
            };
            viewName: {
                propertyType: string;
                type: string;
            };
            width: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
            };
            height: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
                element: string;
            };
            margin: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
                element: string;
            };
            borderRadius: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
                element: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
                style: string;
                element: string;
                resourceValue: string[];
            };
        };
        anchor: any;
        placement: string;
        alignment: string;
        mode: string;
        pageName: string;
        viewName: string;
        width: string;
        height: string;
        margin: string;
        borderRadius: string;
        shadow: string;
        private _flyoutElement;
        private _flyoutControl;
        private _menuControl;
        private _regionElement;
        private _regionControl;
        private _boundSelectedIndexChangedHandler;
        private _boundBeforeShowChangedHandler;
        private _boundBeforeHideChangedHandler;
        private _boundAfterShowChangedHandler;
        private _boundAfterHideChangedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        private _menuElement;
        get menuElement(): VWElement;
        set menuElement(element: VWElement);
        _updateLayout(changes: any): void;
        _selectedIndexChangedHandler(args: any): void;
        _beforeShowChangedHandler(args: any): void;
        _beforeHideChangedHandler(args: any): void;
        _afterShowChangedHandler(args: any): void;
        _afterHideChangedHandler(args: any): void;
        _cleanFlyoutElement(): void;
        show(): void;
        hide(): void;
        showAt(x: any, y: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Button extends VisiWin.UI.ButtonBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            padding: {
                propertyType: string;
                type: string;
                element: string;
                forceOverwrite: boolean;
            };
            transition: {
                propertyType: string;
                type: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                forceOverwrite: boolean;
            };
            pressedShadow: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            containerBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerTransition: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
            };
            symbolPressed: {
                propertyType: string;
                type: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            textWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            text: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                defaultValue: string;
            };
            localizableText: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            lineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            textWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            textTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontClass: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                defaultValue: string;
            };
            fontSize: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            fontWeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            lineHeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            textContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            uppercase: {
                propertyType: string;
                type: string;
                child: string;
            };
            textPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        padding: string;
        transition: string;
        shadow: string;
        pressedShadow: string;
        containerBorderWidth: string;
        containerBorderStyle: string;
        containerBorderRadius: string;
        containerTransition: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolPressed: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        showText: boolean;
        textWidth: string;
        textHeight: string;
        textMargin: string;
        textPadding: string;
        textAlignment: string;
        lineClamp: number;
        textWrapping: string;
        textTrimming: string;
        fontSize: string;
        lineHeight: string;
        textContrast: number;
        uppercase: boolean;
        textPosition: string;
        backgroundColor: string;
        hoverBackgroundColor: string;
        pressedBackgroundColor: string;
        disabledBackgroundColor: string;
        foregroundColor: string;
        pressedForegroundColor: string;
        disabledForegroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        disabledBorderColor: string;
        hoverForegroundColor: string;
        private _containerElement;
        private _symbolElement;
        private _textElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ICheckbox extends ICheckboxBase {
        /**
          * constructor: Creates a new Checkbox.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new Checkbox control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Checkbox control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Checkbox control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Checkbox control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Checkbox control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Checkbox control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Checkbox control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Checkbox control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Checkbox control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * fontClass property / option
         * Get and set the fontClass of the control.
         * If set, the corrosponding Css fontclass will be set to the HTML Element.
         * In this Css Class is define the:
         *   font-family, font-size, font-weight, text-transform, line-height, letter-spacing, and opacity
         * Note: if the Application.Settings["HighContrastText"] is true, the opacity will be set always to "1.0"
         * Datatype: enum as string
         * Defaultvalue: null
         * Valid values:
         *      "display 4", "display 3", "display 2", "display 1", "headline", "title", "subheading",
         *      "subheading 2", "body 2", "body 1", "caption", "menu", "button", "button (all caps)", "label", "label1"
        **/
        fontClass: any;
        /**
         * borderWidth property / option
         * Get and set the css style property "borderWidth" of the corrosponding HTML Element.
         * The border-width property sets the width of an element's four borders. This property can have from one to four values.
         * Note: Always declare the border-style property before the border-width property. An element must have borders before you can set the width.
         * Datatype: string
         * Defaultvalue: medium
         * Valid values: medium | thin | thick | length | initial | inherit
        **/
        borderWidth: string;
        /**
         * disabled property / option
         * Get and set the property "disabled".
         * If this property is set, the control will be display greyed, shadowed. Click and touch events will be blocked.
         * Changes for this property will be call the disabledCahnge eventhandler and the notifyPropertyChanged eventhandler.
         * Addition the Css Class disabled will be set when the control has the focus.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        disabled: boolean;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        checked: boolean;
        /**
         * variableName property / option
         * Get and set the property "variableName".
         * Legt die VisiWin Variable Fest die angemeldet werden soll.
         * War zuvor eine Varable angemeldet, so wird diese zuvor detach und abgemeldet.
         * Intern wird ein Event Handler auf Veränderungen der Variable angemeldet.
         * Dadurch werden einige Properties des VariablenMixin automatisch verändert:
         *      value, bitValue
         * Soll die Variable abgemeldet und keine neue angemeldet werden, so muss 'null'
         * als Parameter übergeben werden.
         * Datatype: string
         * Defaultvalue: null
        **/
        variableName: string;
        /**
         * bitNumber property / option
         * Get and set the property "bitNumber".
         * Ist dieser Wert gesetzt, so wird im value nur der direkte Wert aus der Steuerung
         * dargestellt. Die Unitumrechnung und der FormatString wird nicht angewendet.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        bitNumber: number;
        /**
         * useVariableText property / option
         * Get and set the property "useVariableText".
         * Ist dieses Property gesetzt, so wird der Text der Variablen
         * direkt der Varablen entnommen und in der Property text geschrieben.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        useVariableText: boolean;
        /**
         * showText property / option
         * Get and set the property "showText".
         * The property showText shows or hides the Text element.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        showText: boolean;
        /**
         * text property / option
         * Get and set the property "text".
         * Enthält den Text der dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
        **/
        text: string;
        /**
         * locText property / option
         * Get and set the property "locText".
         * Enthält die TextID die dargestellt werden soll.
         * Das Property "text" wird mit der aufgelösten TextID überschrieben.
         * Die TextID ist sprachabhängig und wird über einen internen Eventhandler beim Aufruf der
         * Sprachumschaltung aufgerufen, so das das Property "text" automatisch ersetzt wird.
         * Datatype: string
         * Defaultvalue: null
        **/
        locText: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
         * hoverColor property / option
         * Get and set the Property "hoverColor" of the corrosponding HTML Element.
         * The hoverColor property sets the css style property border-color of an element when the pointer hovers over element.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        hoverColor: string;
        /**
         * pressedColor property / option
         * Get and set the Property "pressedColor" of the corrosponding HTML Element.
         * The pressedColor property sets the css style property background-color of an element when the element is pressed.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        pressedColor: string;
        /**
         * checkedColor property / option
         * Get and set the Property "checkedColor" of the corrosponding HTML Element.
         * The checkedColor property sets the css style properties: background-color and border-color of an element when the element is checked.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        checkedColor: string;
        /**
         * checkmarkColor property / option
         * Get and set the Property "checkmarkColor" of the corrosponding HTML Element.
         * The checkmarkColor property sets the css style property color of an checked element.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        checkmarkColor: string;
        /**
         * disabledColor property / option
         * Get and set the Property "disabledColor" of the corrosponding HTML Element.
         * The disabledColor property sets the css style properties: color and border-color of an element when the element is disabled.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        disabledColor: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Checkbox extends VisiWin.UI.CheckboxBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            rippleTarget: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            checkmarkBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            checkmarkBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            checkmarkBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            checkmarkWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            checkmarkHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            checkmarkMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            checkmarkPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            checkmarkIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            checkmarkSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            checkmarkSymbolOn: {
                propertyType: string;
                type: string;
            };
            checkmarkSymbolOff: {
                propertyType: string;
                type: string;
            };
            checkmarkSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            checkmarkSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            checkmarkSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
                cloneProperty: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
                cloneProperty: string;
            };
            labelTextOn: {
                propertyType: string;
                type: string;
                cloneProperty: string;
            };
            localizableLabelTextOn: {
                propertyType: string;
                type: string;
                cloneProperty: string;
            };
            labelTextOff: {
                propertyType: string;
                type: string;
                cloneProperty: string;
            };
            localizableLabelTextOff: {
                propertyType: string;
                type: string;
                cloneProperty: string;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkmarkForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverCheckmarkForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedCheckmarkForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedCheckmarkForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverCheckmarkForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedCheckmarkForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledCheckmarkForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledCheckedCheckmarkForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkmarkBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverCheckmarkBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedCheckmarkBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedCheckmarkBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverCheckmarkBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedCheckmarkBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledCheckmarkBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledCheckedCheckmarkBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkmarkBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverCheckmarkBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedCheckmarkBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedCheckmarkBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverCheckmarkBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedCheckmarkBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledCheckmarkBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledCheckedCheckmarkBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        checkmarkBorderWidth: string;
        checkmarkBorderStyle: string;
        checkmarkBorderRadius: string;
        checkmarkWidth: string;
        checkmarkHeight: string;
        checkmarkMargin: string;
        checkmarkPadding: string;
        checkmarkIconFont: string;
        checkmarkSymbol: string;
        checkmarkSymbolOn: string;
        checkmarkSymbolOff: string;
        checkmarkSymbolType: string;
        checkmarkSymbolSize: string;
        checkmarkSymbolMargin: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        backgroundColor: string;
        hoverBackgroundColor: string;
        pressedBackgroundColor: string;
        checkedBackgroundColor: string;
        checkedHoverBackgroundColor: string;
        checkedPressedBackgroundColor: string;
        disabledBackgroundColor: string;
        foregroundColor: string;
        pressedForegroundColor: string;
        checkedForegroundColor: string;
        checkedPressedForegroundColor: string;
        disabledForegroundColor: string;
        hoverForegroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        checkedBorderColor: string;
        checkedHoverBorderColor: string;
        disabledBorderColor: string;
        checkmarkForegroundColor: string;
        hoverCheckmarkForegroundColor: string;
        pressedCheckmarkForegroundColor: string;
        checkedCheckmarkForegroundColor: string;
        checkedHoverCheckmarkForegroundColor: string;
        checkedPressedCheckmarkForegroundColor: string;
        disabledCheckmarkForegroundColor: string;
        disabledCheckedCheckmarkForegroundColor: string;
        checkedHoverForegroundColor: string;
        checkmarkBackgroundColor: string;
        hoverCheckmarkBackgroundColor: string;
        pressedCheckmarkBackgroundColor: string;
        checkedCheckmarkBackgroundColor: string;
        checkedHoverCheckmarkBackgroundColor: string;
        checkedPressedCheckmarkBackgroundColor: string;
        disabledCheckmarkBackgroundColor: string;
        disabledCheckedCheckmarkBackgroundColor: string;
        checkmarkBorderColor: string;
        hoverCheckmarkBorderColor: string;
        pressedCheckmarkBorderColor: string;
        checkedCheckmarkBorderColor: string;
        checkedHoverCheckmarkBorderColor: string;
        checkedPressedCheckmarkBorderColor: string;
        disabledCheckmarkBorderColor: string;
        disabledCheckedCheckmarkBorderColor: string;
        private _containerElement;
        private _checkmarkElement;
        private _checkmarkSymbolElement;
        private _labelElement;
        observe: any;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IDonutGauge extends VisiWin.UI.IControlBase {
        /**
          * constructor: Creates a new DonutGauge.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new DonutGauge control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DonutGauge control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DonutGauge control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DonutGauge control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DonutGauge control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DonutGauge control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DonutGauge control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DonutGauge control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DonutGauge control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * fontClass property / option
         * Get and set the fontClass of the control.
         * If set, the corrosponding Css fontclass will be set to the HTML Element.
         * In this Css Class is define the:
         *   font-family, font-size, font-weight, text-transform, line-height, letter-spacing, and opacity
         * Note: if the Application.Settings["HighContrastText"] is true, the opacity will be set always to "1.0"
         * Datatype: enum as string
         * Defaultvalue: null
         * Valid values:
         *      "display 4", "display 3", "display 2", "display 1", "headline", "title", "subheading",
         *      "subheading 2", "body 2", "body 1", "caption", "menu", "button", "button (all caps)", "label", "label1"
        **/
        fontClass: any;
        /**
         * borderWidth property / option
         * Get and set the css style property "borderWidth" of the corrosponding HTML Element.
         * The border-width property sets the width of an element's four borders. This property can have from one to four values.
         * Note: Always declare the border-style property before the border-width property. An element must have borders before you can set the width.
         * Datatype: string
         * Defaultvalue: medium
         * Valid values: medium | thin | thick | length | initial | inherit
        **/
        borderWidth: string;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * minValue property / option
         * Get and set the property "minValue".
         * The minValue property defines the minimal value for donut gauge element.
         * Note: To display the desired donut gauge element, the property minValue must be less than the property maxValue,
         *       otherwise, control will not display donut gauge chart.
         * Datatype: number
         * Defaultvalue: 0
         * Valid values: number
        **/
        minValue: number;
        /**
         * maxValue property / option
         * Get and set the property "maxValue".
         * The maxValue property defines the maximal value for donut gauge element.
         * Note: To display the desired donut gauge element, the property maxValue must be greater than the property minValue,
         *       otherwise, control will not display donut gauge chart.
         * Datatype: number
         * Defaultvalue: 100
         * Valid values: number
        **/
        maxValue: number;
        /**
         * startAngle property / option
         * Get and set the property "startAngle".
         * The startAngle property defines start angle for donut gauge element.
         * Note: Angles are expressed in degrees. The starting point (+/- 0) is located in the north.
         * Datatype: number
         * Defaultvalue: -135
         * Valid values: number
        **/
        startAngle: number;
        /**
         * endAngle property / option
         * Get and set the property "endAngle".
         * The endAngle property defines end angle for donut gauge element.
         * Note: Angles are expressed in degrees. The ending point (+/- 360) is located in the north.
         * Datatype: number
         * Defaultvalue: 135
         * Valid values: number
        **/
        endAngle: number;
        /**
         * innerRadius property / option
         * Get and set the property "innerRadius".
         * The innerRadius property defines inside radius for donut gauge element.
         * Note: To display the desired donut gauge element, the property innerRadius must be different than the property outerRadius,
         *       otherwise, control will not display donut gauge chart.
         * Datatype: string
         * Defaultvalue: 90%
         * Valid values: | px | % |
        **/
        innerRadius: string;
        /**
         * outerRadius property / option
         * Get and set the property "outerRadius".
         * The outerRadius property defines outside radius for donut gauge element.
         * Note: To display the desired donut gauge element, the property outerRadius must be different than the property innerRadius,
         *       otherwise, control will not display donut gauge chart.
         * Datatype: string
         * Defaultvalue: 100%
         * Valid values: | px | % |
        **/
        outerRadius: string;
        /**
         * variableName property / option
         * Get and set the property "variableName".
         * Legt die VisiWin Variable Fest die angemeldet werden soll.
         * War zuvor eine Varable angemeldet, so wird diese zuvor detach und abgemeldet.
         * Intern wird ein Event Handler auf Veränderungen der Variable angemeldet.
         * Dadurch werden einige Properties des VariablenMixin automatisch verändert:
         *      value, bitValue
         * Soll die Variable abgemeldet und keine neue angemeldet werden, so muss 'null'
         * als Parameter übergeben werden.
         * Datatype: string
         * Defaultvalue: null
        **/
        variableName: string;
        /**
         * value property / option
         * Get and set the property "value".
         * Der Wert von value wird automatisch einer angemeldeten Variablen nachgeführt.
         * In Ihr wird der Einheiten Umgerechnete Wert durch den Variablen Event Handler eingetragen.
         * Zusätzlich wird der option angegebene formatString zur darstellung ausgewertet.
         * Ein aufruf des Setters von value beschreibt NICHT automatisch die VisiWin Variable.
         * Je nach Datentype der Variabe kann sich der Datentype von value ändern.
         * Datatype: any
         * Defaultvalue: null
        **/
        value: any;
        /**
         * formatString property / option
         * Get and set the property "formatString".
         * Ist dieser Wert gesetzt, so wird der Wert value vor der Ausgabe Formatiert:
         *    Fx    Floatformatierung mit x Nachkommastellen
         *    Dx    Dezimalformatierung, Ausgabe mit minimum x Stellen, ggf werden führende Nullen einegesetzt
         * Datatype: boolean
         * Defaultvalue: false
        **/
        formatString: string;
        /**
         * locFormatString property / option
         * Get and set the property "locFormatString".
         * Sprachabhängig kann der formatString dynamisch geändert werden.
         * Bei einer Sprachumschaltung wird die übergebene TextID in den Sprachabhängigen
         * formatString gewandelt und in das Property formatString geschrieben.
         * Datatype: string
         * Defaultvalue: null
        **/
        locFormatString: string;
        /**
         * unitText property / option
         * Get and set the property "unitText".
         * Einheit der Variablen für die Darstellung.
         * Datatype: string
         * Defaultvalue: null
        **/
        unitText: string;
        /**
         * locUnitText property / option
         * Get and set the property "locUnitText".
         * Sprachabhängig kann die Einheit dynamisch geändert werden.
         * Bei einer Sprachumschaltung wird die übergebene TextID in den Sprachabhängigen
         * unitText gewandelt und in das Property unitText geschrieben.
         * Datatype: string
         * Defaultvalue: null
        **/
        locUnitText: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
         * indicatorColor property / option
         * Get and set the property "indicatorColor" of the corrosponding HTML Element.
         * The indicatorColor property paints the interior of the SVG path "indicator".
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        indicatorColor: string;
        /**
         * indicatorBackgroundColor property / option
         * Get and set the property "indicatorBackgroundColor" of the corrosponding HTML Element.
         * The indicatorBackgroundColor property paints the interior of the SVG path "indicatorBackground".
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        indicatorBackgroundColor: string;
        /**
          * width property / option
          * Get and set the css style Property "width" of the corrosponding HTML Element.
          * The width property specifies the content width of boxes.
          * Datatype: string
          * Defaultvalue: auto
          * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class DonutGauge extends VisiWin.UI.ControlBase {
        private properties;
        private cssStyles;
        variableName: string;
        decimalPlaces: number;
        useRawValue: boolean;
        valueLabelPosition: string;
        value: number;
        showValueLabel: boolean;
        showUnit: boolean;
        unitText: string;
        limits: any;
        indicatorBackgroundColor: string;
        indicatorColor: string;
        valueLabelBackgroundColor: string;
        valueBackgroundColor: string;
        unitBackgroundColor: string;
        valueForegroundColor: string;
        unitForegroundColor: string;
        valueLabelBorderColor: string;
        disabledIndicatorBackgroundColor: string;
        disabledIndicatorColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        _gaugeCoreControl: any;
        _valueLabelControl: any;
        private limitsCollection;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        registerChild(controlType: string, action: string, limit: VWElement, options: any): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _limitsChangedHandler(args: any): void;
    }
}
declare module VisiWin.UI {
    class Key extends VisiWin.UI.KeyBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            padding: {
                propertyType: string;
                type: string;
                element: string;
                forceOverwrite: boolean;
            };
            transition: {
                propertyType: string;
                type: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                forceOverwrite: boolean;
            };
            pressedShadow: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            containerBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerTransition: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
            };
            symbolPressed: {
                propertyType: string;
                type: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            textWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
            };
            text: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            localizableText: {
                propertyType: string;
                type: string;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            lineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            textWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            textTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontClass: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                defaultValue: string;
            };
            fontSize: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            fontWeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            lineHeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            textContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            uppercase: {
                propertyType: string;
                type: string;
                child: string;
            };
            textPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        padding: string;
        transition: string;
        shadow: string;
        pressedShadow: string;
        containerBorderWidth: string;
        containerBorderStyle: string;
        containerBorderRadius: string;
        containerTransition: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolPressed: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        showText: boolean;
        textWidth: string;
        textHeight: string;
        textMargin: string;
        textPadding: string;
        textAlignment: string;
        lineClamp: number;
        textWrapping: string;
        textTrimming: string;
        fontSize: string;
        lineHeight: string;
        textContrast: number;
        uppercase: boolean;
        textPosition: string;
        backgroundColor: string;
        hoverBackgroundColor: string;
        pressedBackgroundColor: string;
        disabledBackgroundColor: string;
        foregroundColor: string;
        hoverForegroundColor: string;
        pressedForegroundColor: string;
        disabledForegroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        disabledBorderColor: string;
        private _containerElement;
        private _symbolElement;
        private _textElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class LinearRange extends VisiWin.UI.VariableBase {
        private properties;
        private cssStyles;
        rawLimitMin: number;
        rawLimitMax: number;
        limits: any[];
        rawReferenceValue: number;
        position: string;
        direction: string;
        placement: string;
        reverse: boolean;
        startWidth: string;
        endWidth: string;
        rangesOffset: number;
        showAllRanges: boolean;
        backgroundColor: string;
        disabledBackgroundColor: string;
        disabledIndicatorColor: string;
        indicatorColor: string;
        private _limitsCollection;
        private _clientWidth;
        private _clientHeight;
        private _initialized;
        private _svgElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        registerChild(controlType: string, action: string, limit: VWElement, options: any): any;
        createHandler(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _drawRanges(): void;
        _limitsChangedHandler(changes: any): void;
    }
}
declare namespace VisiWin.UI {
    class LinearRangeLimit extends VisiWin.UI.ProviderBase {
        static namespace: string;
        static controlName: string;
        static propertyList: {
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            startValue: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            endValue: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            startWidth: {
                propertyType: string;
                type: string;
            };
            endWidth: {
                propertyType: string;
                type: string;
            };
            offset: {
                propertyType: string;
                type: string;
            };
            fillColor: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        constructor(element: VWElement, options: any);
    }
}
declare namespace VisiWin.UI {
    class LinearScale extends VisiWin.UI.VariableBase {
        private properties;
        private cssStyles;
        rawLimitMin: number;
        rawLimitMax: number;
        mode: string;
        position: string;
        placement: string;
        reverse: boolean;
        showBaseLine: boolean;
        limitsVisibility: string;
        showMajorTicks: boolean;
        majorStepSize: number;
        majorSteps: number;
        majorTicksLength: number;
        majorTicksWidth: number;
        showMiddleTicks: boolean;
        middleStepSize: number;
        middleSteps: number;
        middleTicksLength: number;
        middleTicksWidth: number;
        showMinorTicks: boolean;
        minorStepSize: number;
        minorSteps: number;
        minorTicksLength: number;
        minorTicksWidth: number;
        showMajorLabels: boolean;
        majorLabelsFontClass: string;
        majorLabelsFontSize: string;
        majorLabelsFontWeight: string;
        majorLabelsLineHeight: string;
        majorLabelsTextContrast: string;
        majorLabelsOffset: number;
        majorLabelsDecimalPlaces: number;
        backgroundColor: string;
        foregroundColor: string;
        majorTicksColor: string;
        middleTicksColor: string;
        minorTicksColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        private _svgElement;
        private _labels;
        private _clientWidth;
        private _clientHeight;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _drawScale(): void;
        _stepsToValues(minValue: number, maxValue: number, steps: number): any[];
        _stepSizeToValues(minValue: number, maxValue: number, stepSize: number): any[];
        _valuesToCordinates(width: number, height: number, minValue: number, maxValue: number, position: string, placement: string, reverse: boolean, ticks: any[], ticksLength: number): void;
        _drawTicks(ticks: any[], ticksWidth: number, ticksColor: string): void;
        _drawLabels(position: string, placement: string, ticks: any[], fontClass: string, fontSize: string, fontWeight: string, lineHeight: string, textContrast: string, offset: number, decimalPlaces: number): void;
        _drawBaseline(position: string, width: number, height: number, thickness: number, color: string): void;
        _drawLabelsSVG(position: string, placement: string, ticks: any[], fontClass: string, fontSize: string, fontWeight: string, lineHeight: string, textContrast: string, offset: number, decimalPlaces: number): void;
    }
}
declare var Snap: any;
declare module VisiWin.UI {
    class LinearIndicator extends VisiWin.UI.VariableBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            rawLimitMin: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            rawLimitMax: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            position: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            placement: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            reverse: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            rotate: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            rotateAngle: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            indicatorUri: {
                propertyType: string;
                type: string;
                defaultValue: any;
            };
            indicatorSize: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            indicatorOffset: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        rawLimitMin: number;
        rawLimitMax: number;
        position: string;
        placement: string;
        reverse: boolean;
        rotate: boolean;
        rotateAngle: number;
        indicatorOffset: number;
        backgroundColor: string;
        disabledBackgroundColor: string;
        private _svgLoadedFlag;
        private _svgElement;
        private _svgGroupElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        resizeHandler(): void;
        beforeInit(): void;
        private _indicatorUri;
        get indicatorUri(): any;
        set indicatorUri(value: any);
        private _indicatorSize;
        get indicatorSize(): any;
        set indicatorSize(value: any);
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class LinearInstrument extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static classLinearInstrument: string;
        static LinearInstrumentPropertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        disabledBackgroundColor: string;
        constructor(element: VWElement, options: any);
        _updateColors(): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface INumericVarIn extends VisiWin.UI.IControlBase {
        /**
         * value property / option
         * Get and set the property "value".
         * Der Wert von value wird automatisch einer angemeldeten Variablen nachgeführt.
         * In Ihr wird der Einheiten Umgerechnete Wert durch den Variablen Event Handler eingetragen.
         * Zusätzlich wird der option angegebene formatString zur darstellung ausgewertet.
         * Ein aufruf des Setters von value beschreibt NICHT automatisch die VisiWin Variable.
         * Je nach Datentype der Variabe kann sich der Datentype von value ändern.
         * Datatype: any
         * Defaultvalue: null
        **/
        value: string;
        variableName: string;
        decimalPlaces: number;
        labelText: string;
        locLabelText: string;
        useVariableText: boolean;
        unitText: string;
        locUnitText: string;
        useVariableUnitText: boolean;
        valueWidth: string;
        valueAlignment: string;
        valueMargin: string;
        valueBorderWidth: string;
        valueBorderRadius: string;
        valueFontClass: string;
        valueFontFamily: string;
        valueFontSize: string;
        valueFontWeight: string;
        valueLineHeight: string;
        showUnit: string;
        unitWidth: string;
        unitMargin: string;
        unitAlignment: string;
        unitFontClass: string;
        unitFontFamily: string;
        unitFontSize: string;
        unitFontWeight: string;
        unitLineHeight: string;
        /**
         * showLabel property / option
         * Get and set the property "showLabel".
         * The property showLabel shows or hides the Label element.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        showLabel: boolean;
        labelAlignment: string;
        labelMargin: string;
        labelLineClamp: string;
        labelFontClass: string;
        labelFontFamily: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        /**
         * showSymbol property / option
         * Get and set the property "showSymbol".
         * The property showSymbol shows or hides the Symbol element.
         * Datatype: boolean
         * Defaultvalue: false
         * Valid values: true | false
        **/
        showSymbol: boolean;
        /**
         * symbol property / option
         * Get and set the property "symbol".
         * Legt des Quelle des Symbols fest, bei
         *  "icon"        : der Name des Icons im Font.
         *  "image", "svg": der Name der Datei die dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: Iconname aus Font oder Path auf eine gültuge Image oder Svg Datei
        **/
        symbol: string;
        /**
         * symbolType property / option
         * Get and set the property "symbolType".
         * Es gibt drei gültige Werte:
         *  "icon" : Ein Zeichen aus einem Iconfont dargestellt. Es wird ein <I> Tag verwebdet.
         *  "image": Eine Bitmap Grafig in dem Format "PNG" oder "JPG" wird ausgegeben. Es wird ein "IMG" Tag verwendet.
         *  "svg"  : Eine SVF Grafig wird ausgegeben. Es wird ein <IMG> Tag verwendet.
         * Datatype: string
         * Defaultvalue: "icon"
         * Valid values: "icon", "image", svg"
        **/
        symbolType: string;
        /**
         * symbolSize property / option
         * Get and set the property "symbolSize".
         * Größe des dargestellten Symbols.
         * Dieses Property muss immer in Zusammenhang mit den den Style Propertys "with" und "height" gesehen werden.
         * Der Wert auto besagt, die größe wird über die "width" und "height" Properties festgelegt.
         * Ist ein Wert angegeben, so wird damit die Breite und Höhe des Symbols angegeben. Sind die "width" und height"
         * Properties nicht auf "auto" eingestellt, sie wird hierdurch die größe des umgebenden Containers eingestellt,
         * andernfalls wird der Container an die größe des Symbols angepasst.
         * Datatype: string
         * Defaultvalue: "auto" -  symbolType="image" and symbolType="svg"
         *               "24px" -  symbolType="icon"
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        symbolSize: string;
        symbolMargin: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        valueBackgroundColor: string;
        valueForegroundColor: string;
        valueBorderColor: string;
        labelBackgroundColor: string;
        labelForegroundColor: string;
        symbolBackgroundColor: string;
        symbolForegroundColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledValueBorderColor: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
        /** @ignore */
        writeValue(value: any): any;
        /** @ignore */
        getCurrentUnit(): VisiWin.System.DataAccess.IUnit | null;
    }
}
declare module VisiWin.UI {
    class NumericVarIn extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            valueChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            focused: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            hover: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            errorMode: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            canRecipeEdit: {
                propertyType: string;
                type: string;
                child: string;
            };
            variableName: {
                propertyType: string;
                type: string;
                child: string;
            };
            value: {
                propertyType: string;
                type: string;
                child: string;
            };
            decimalPlaces: {
                propertyType: string;
                type: string;
                child: string;
            };
            useRawValue: {
                propertyType: string;
                type: string;
                child: string;
            };
            abortOnEsc: {
                propertyType: string;
                type: string;
                child: string;
            };
            writeOnReturn: {
                propertyType: string;
                type: string;
                child: string;
            };
            selectOnFocus: {
                propertyType: string;
                type: string;
                child: string;
            };
            lostKeyboardFocusBehaviour: {
                propertyType: string;
                type: string;
                child: string;
            };
            rawLimitMin: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: number;
            };
            rawLimitMax: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: number;
            };
            useVariableLimits: {
                propertyType: string;
                type: string;
                child: string;
            };
            isLimitCheckEnabled: {
                propertyType: string;
                type: string;
                child: string;
            };
            limitMinErrorText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableLimitMinErrorText: {
                propertyType: string;
                type: string;
                child: string;
            };
            limitMaxErrorText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableLimitMaxErrorText: {
                propertyType: string;
                type: string;
                child: string;
            };
            variableWriteErrorText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableVariableWriteErrorText: {
                propertyType: string;
                type: string;
                child: string;
            };
            watermarkText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableWatermarkText: {
                propertyType: string;
                type: string;
                child: string;
            };
            inputContainerWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputBorderRadius: {
                propertyType: string;
                type: string;
            };
            inputWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputHeight: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            inputMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            inputFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            outlined: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            inputFieldMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelContainerWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showLeadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            leadingIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showFloatingLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            floatingLabelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableFloatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFixed: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            floatingLabelTransition: {
                propertyType: string;
                type: string;
            };
            floatingLabelOutlineWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            floatingLabelOutlineStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showUnit: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            unitWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableUnitText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: boolean;
            };
            unitText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: any;
            };
            localizableUnitText: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            unitTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showTrailingSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            trailingIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showErrorSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            errorIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showUnderline: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            underlineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            underlineOpacity: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            focusedUnderlineOpacity: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            underlineTransition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            underlineTransform: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            focusedUnderlineTransform: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showHelperText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            helperTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableHelperText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            helperTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showErrorText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            errorTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorText: {
                propertyType: string;
                type: string;
            };
            localizableErrorText: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
            };
            errorTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            errorTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedInputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            underlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedUnderlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            symbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            leadingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedFloatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            unitForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            trailingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            helperTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            errorColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedInputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelOutlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            caretColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledFloatingLabelOutlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            useTouchKeyboard: {
                propertyType: string;
                child: string;
                childProperty: string;
                type: string;
                defaultValue: boolean;
            };
            touchKeyboardDialogName: {
                propertyType: string;
                child: string;
                childProperty: string;
                type: string;
            };
            forceTouchKeyboardOnMobileDevice: {
                propertyType: string;
                child: string;
                childProperty: string;
                type: string;
                defaultValue: boolean;
            };
        };
        errorMode: boolean;
        alignItems: string;
        justifyContent: string;
        variableName: string;
        value: string;
        decimalPlaces: number;
        useRawValue: boolean;
        abortOnEsc: boolean;
        writeOnReturn: boolean;
        selectOnFocus: boolean;
        lostKeyboardFocusBehaviour: string;
        rawLimitMin: number;
        rawLimitMax: number;
        useVariableLimits: boolean;
        limitMinErrorText: string;
        localizableLimitMinErrorText: string;
        limitMaxErrorText: string;
        localizableLimitMaxErrorText: string;
        variableWriteErrorText: string;
        localizableVariableWriteErrorText: string;
        watermarkText: string;
        localizableWatermarkText: string;
        inputContainerWidth: string;
        inputContainerHeight: string;
        inputContainerMargin: string;
        inputContainerPadding: string;
        inputBorderWidth: string;
        inputBorderStyle: string;
        inputBorderRadius: string;
        inputWidth: string;
        inputHeight: string;
        inputMargin: string;
        inputPadding: string;
        inputTextAlignment: string;
        inputFontClass: string;
        inputFontSize: string;
        inputFontWeight: string;
        inputLineHeight: string;
        inputTextContrast: number;
        outlined: boolean;
        inputFieldMargin: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        labelContainerWidth: string;
        labelContainerHeight: string;
        labelContainerMargin: string;
        labelContainerPadding: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        useVariableText: boolean;
        labelText: string;
        localizableLabelText: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        showLeadingSymbol: boolean;
        leadingIconFont: string;
        leadingSymbol: string;
        leadingSymbolType: string;
        leadingSymbolSize: string;
        leadingSymbolMargin: string;
        showFloatingLabel: boolean;
        floatingLabelWidth: string;
        floatingLabelHeight: string;
        floatingLabelMargin: string;
        floatingLabelPadding: string;
        floatingLabelText: string;
        localizableFloatingLabelText: string;
        floatingLabelTextAlignment: string;
        floatingLabelLineClamp: number;
        floatingLabelTextWrapping: string;
        floatingLabelTextTrimming: string;
        floatingLabelFontClass: string;
        floatingLabelFontSize: string;
        floatingLabelFontWeight: string;
        floatingLabelLineHeight: string;
        floatingLabelTextContrast: number;
        floatingLabelUppercase: boolean;
        floatingLabelFixed: boolean;
        floatingLabelTransition: string;
        floatingLabelOutlineWidth: string;
        floatingLabelOutlineStyle: string;
        showUnit: boolean;
        unitWidth: string;
        unitHeight: string;
        unitMargin: string;
        unitPadding: string;
        useVariableUnitText: boolean;
        unitText: string;
        localizableUnitText: string;
        unitTextAlignment: string;
        unitLineClamp: number;
        unitTextWrapping: string;
        unitTextTrimming: string;
        unitFontClass: string;
        unitFontSize: string;
        unitFontWeight: string;
        unitLineHeight: string;
        unitTextContrast: number;
        showTrailingSymbol: boolean;
        trailingIconFont: string;
        trailingSymbol: string;
        trailingSymbolType: string;
        trailingSymbolSize: string;
        trailingSymbolMargin: string;
        showErrorSymbol: boolean;
        errorIconFont: string;
        errorSymbol: string;
        errorSymbolType: string;
        errorSymbolSize: string;
        errorSymbolMargin: string;
        showUnderline: boolean;
        underlineHeight: string;
        underlineOpacity: number;
        focusedUnderlineOpacity: number;
        underlineTransition: string;
        underlineTransform: string;
        focusedUnderlineTransform: string;
        showHelperText: boolean;
        helperTextWidth: string;
        helperTextHeight: string;
        helperTextMargin: string;
        helperTextPadding: string;
        helperText: string;
        localizableHelperText: string;
        helperTextAlignment: string;
        helperTextLineClamp: number;
        helperTextWrapping: string;
        helperTextTrimming: string;
        helperTextFontClass: string;
        helperTextFontSize: string;
        helperTextFontWeight: string;
        helperTextLineHeight: string;
        helperTextContrast: number;
        helperTextUppercase: boolean;
        showErrorText: boolean;
        errorTextWidth: string;
        errorTextHeight: string;
        errorTextMargin: string;
        errorTextPadding: string;
        errorText: string;
        errorTextAlignment: string;
        errorTextLineClamp: number;
        errorTextWrapping: string;
        errorTextTrimming: string;
        errorTextFontClass: string;
        errorTextFontSize: string;
        errorTextFontWeight: string;
        errorTextLineHeight: string;
        errorTextContrast: number;
        errorTextUppercase: boolean;
        backgroundColor: string;
        inputBackgroundColor: string;
        hoverInputBackgroundColor: string;
        focusedInputBackgroundColor: string;
        floatingLabelBackgroundColor: string;
        underlineColor: string;
        focusedUnderlineColor: string;
        symbolForegroundColor: string;
        labelForegroundColor: string;
        inputForegroundColor: string;
        hoverInputForegroundColor: string;
        leadingSymbolForegroundColor: string;
        floatingLabelForegroundColor: string;
        focusedFloatingLabelForegroundColor: string;
        unitForegroundColor: string;
        trailingSymbolForegroundColor: string;
        helperTextForegroundColor: string;
        errorColor: string;
        borderColor: string;
        inputBorderColor: string;
        hoverInputBorderColor: string;
        focusedInputBorderColor: string;
        floatingLabelOutlineColor: string;
        caretColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        disabledFloatingLabelOutlineColor: string;
        useTouchkeyboard: boolean;
        touchkeyboardDialogName: string;
        forceTouchKeyboardOnMobileDevice: boolean;
        private _labelElement;
        private _inputContainerElement;
        private _inputFieldContainerElement;
        private _inputElement;
        private _leadingSymbolElement;
        private _inputFieldElement;
        private _floatingLabelElement;
        private _unitElement;
        private _trailingSymbolElement;
        private _errorSymbolElement;
        private _underlineElement;
        private _helperTextElement;
        private _errorTextElement;
        private _boundValueChangedHandler;
        private _boundLocalizableErrorTextHandler;
        observe: any;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        afterInit(): void;
        writeValue(value: any): void;
        getCurrentUnit(): VisiWin.System.DataAccess.IUnit | null;
        valueChangeHandler(args: any): void;
        private localizableErrorTextObject;
        private _localizableErrorTextHandler;
        private _localizableErrorText;
        get localizableErrorText(): string;
        set localizableErrorText(value: string);
        _updateLayout(changes: any): void;
        _updateColors(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ITextVarIn extends VisiWin.UI.IControlBase {
        /**
         * value property / option
         * Get and set the property "value".
         * Der Wert von value wird automatisch einer angemeldeten Variablen nachgeführt.
         * In Ihr wird der Einheiten Umgerechnete Wert durch den Variablen Event Handler eingetragen.
         * Zusätzlich wird der option angegebene formatString zur darstellung ausgewertet.
         * Ein aufruf des Setters von value beschreibt NICHT automatisch die VisiWin Variable.
         * Je nach Datentype der Variabe kann sich der Datentype von value ändern.
         * Datatype: any
         * Defaultvalue: null
        **/
        value: string;
        variableName: string;
        decimalPlaces: number;
        labelText: string;
        locLabelText: string;
        useVariableText: boolean;
        valueWidth: string;
        valueAlignment: string;
        valueMargin: string;
        valueBorderWidth: string;
        valueBorderRadius: string;
        valueFontClass: string;
        valueFontFamily: string;
        valueFontSize: string;
        valueFontWeight: string;
        valueLineHeight: string;
        /**
         * showLabel property / option
         * Get and set the property "showLabel".
         * The property showLabel shows or hides the Label element.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        showLabel: boolean;
        labelAlignment: string;
        labelMargin: string;
        labelLineClamp: string;
        labelFontClass: string;
        labelFontFamily: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        /**
         * showSymbol property / option
         * Get and set the property "showSymbol".
         * The property showSymbol shows or hides the Symbol element.
         * Datatype: boolean
         * Defaultvalue: false
         * Valid values: true | false
        **/
        showSymbol: boolean;
        /**
         * symbol property / option
         * Get and set the property "symbol".
         * Legt des Quelle des Symbols fest, bei
         *  "icon"        : der Name des Icons im Font.
         *  "image", "svg": der Name der Datei die dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: Iconname aus Font oder Path auf eine gültuge Image oder Svg Datei
        **/
        symbol: string;
        /**
         * symbolType property / option
         * Get and set the property "symbolType".
         * Es gibt drei gültige Werte:
         *  "icon" : Ein Zeichen aus einem Iconfont dargestellt. Es wird ein <I> Tag verwebdet.
         *  "image": Eine Bitmap Grafig in dem Format "PNG" oder "JPG" wird ausgegeben. Es wird ein "IMG" Tag verwendet.
         *  "svg"  : Eine SVF Grafig wird ausgegeben. Es wird ein <IMG> Tag verwendet.
         * Datatype: string
         * Defaultvalue: "icon"
         * Valid values: "icon", "image", svg"
        **/
        symbolType: string;
        /**
         * symbolSize property / option
         * Get and set the property "symbolSize".
         * Größe des dargestellten Symbols.
         * Dieses Property muss immer in Zusammenhang mit den den Style Propertys "with" und "height" gesehen werden.
         * Der Wert auto besagt, die größe wird über die "width" und "height" Properties festgelegt.
         * Ist ein Wert angegeben, so wird damit die Breite und Höhe des Symbols angegeben. Sind die "width" und height"
         * Properties nicht auf "auto" eingestellt, sie wird hierdurch die größe des umgebenden Containers eingestellt,
         * andernfalls wird der Container an die größe des Symbols angepasst.
         * Datatype: string
         * Defaultvalue: "auto" -  symbolType="image" and symbolType="svg"
         *               "24px" -  symbolType="icon"
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        symbolSize: string;
        symbolMargin: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        valueBackgroundColor: string;
        valueForegroundColor: string;
        valueBorderColor: string;
        hoverBorderColor: string;
        errorBorderColor: string;
        focusedBorderColor: string;
        labelBackgroundColor: string;
        labelForegroundColor: string;
        symbolBackgroundColor: string;
        symbolForegroundColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledValueBorderColor: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
        /** @ignore */
        writeValue(value: string): any;
    }
}
declare module VisiWin.UI {
    class TextVarIn extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            valueChanged: {
                propertyType: string;
            };
            focused: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            hover: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            errorMode: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            canRecipeEdit: {
                propertyType: string;
                type: string;
                child: string;
            };
            variableName: {
                propertyType: string;
                type: string;
                child: string;
            };
            value: {
                propertyType: string;
                type: string;
                child: string;
            };
            abortOnEsc: {
                propertyType: string;
                type: string;
                child: string;
            };
            writeOnReturn: {
                propertyType: string;
                type: string;
                child: string;
            };
            selectOnFocus: {
                propertyType: string;
                type: string;
                child: string;
            };
            lostKeyboardFocusBehaviour: {
                propertyType: string;
                type: string;
                child: string;
            };
            textLengthMin: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: number;
            };
            textLengthMax: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: number;
            };
            useVariableLimits: {
                propertyType: string;
                type: string;
                child: string;
            };
            isLimitCheckEnabled: {
                propertyType: string;
                type: string;
                child: string;
            };
            limitMinErrorText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableLimitMinErrorText: {
                propertyType: string;
                type: string;
                child: string;
            };
            limitMaxErrorText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableLimitMaxErrorText: {
                propertyType: string;
                type: string;
                child: string;
            };
            variableWriteErrorText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableVariableWriteErrorText: {
                propertyType: string;
                type: string;
                child: string;
            };
            watermarkText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableWatermarkText: {
                propertyType: string;
                type: string;
                child: string;
            };
            inputContainerWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputBorderRadius: {
                propertyType: string;
                type: string;
            };
            inputWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputHeight: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            inputMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            inputFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputType: {
                propertyType: string;
                type: string;
                child: string;
            };
            outlined: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            inputFieldMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelContainerWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showLeadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            leadingIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showFloatingLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            floatingLabelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableFloatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFixed: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            floatingLabelTransition: {
                propertyType: string;
                type: string;
            };
            floatingLabelOutlineWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            floatingLabelOutlineStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showTrailingSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            trailingIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showErrorSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            errorIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showUnderline: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            underlineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            underlineOpacity: {
                propertyType: string;
                type: string;
            };
            focusedUnderlineOpacity: {
                propertyType: string;
                type: string;
            };
            underlineTransition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            underlineTransform: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            focusedUnderlineTransform: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showHelperText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            helperTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableHelperText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            helperTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showErrorText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            errorTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorText: {
                propertyType: string;
                type: string;
            };
            localizableErrorText: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
            };
            errorTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            errorTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedInputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            underlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedUnderlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            symbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            leadingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedFloatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            trailingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            helperTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            errorColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedInputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelOutlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            caretColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledFloatingLabelOutlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            useTouchKeyboard: {
                propertyType: string;
                child: string;
                childProperty: string;
                type: string;
                defaultValue: boolean;
            };
            touchKeyboardDialogName: {
                propertyType: string;
                child: string;
                childProperty: string;
                type: string;
            };
            forceTouchKeyboardOnMobileDevice: {
                propertyType: string;
                child: string;
                childProperty: string;
                type: string;
                defaultValue: boolean;
            };
        };
        errorMode: boolean;
        alignItems: string;
        justifyContent: string;
        variableName: string;
        value: string;
        abortOnEsc: boolean;
        writeOnReturn: boolean;
        selectOnFocus: boolean;
        lostKeyboardFocusBehaviour: string;
        textLengthMin: number;
        textLengthMax: number;
        useVariableLimits: boolean;
        limitMinErrorText: string;
        localizableLimitMinErrorText: string;
        limitMaxErrorText: string;
        localizableLimitMaxErrorText: string;
        variableWriteErrorText: string;
        localizableVariableWriteErrorText: string;
        watermarkText: string;
        localizableWatermarkText: string;
        inputContainerWidth: string;
        inputContainerHeight: string;
        inputContainerMargin: string;
        inputContainerPadding: string;
        inputBorderWidth: string;
        inputBorderStyle: string;
        inputBorderRadius: string;
        inputWidth: string;
        inputHeight: string;
        inputMargin: string;
        inputPadding: string;
        inputTextAlignment: string;
        inputFontClass: string;
        inputFontSize: string;
        inputFontWeight: string;
        inputLineHeight: string;
        inputTextContrast: number;
        inputType: string;
        outlined: boolean;
        inputFieldMargin: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        labelContainerWidth: string;
        labelContainerHeight: string;
        labelContainerMargin: string;
        labelContainerPadding: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        useVariableText: boolean;
        labelText: string;
        localizableLabelText: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        showLeadingSymbol: boolean;
        leadingIconFont: string;
        leadingSymbol: string;
        leadingSymbolType: string;
        leadingSymbolSize: string;
        leadingSymbolMargin: string;
        showFloatingLabel: boolean;
        floatingLabelWidth: string;
        floatingLabelHeight: string;
        floatingLabelMargin: string;
        floatingLabelPadding: string;
        floatingLabelText: string;
        localizableFloatingLabelText: string;
        floatingLabelTextAlignment: string;
        floatingLabelLineClamp: number;
        floatingLabelTextWrapping: string;
        floatingLabelTextTrimming: string;
        floatingLabelFontClass: string;
        floatingLabelFontSize: string;
        floatingLabelFontWeight: string;
        floatingLabelLineHeight: string;
        floatingLabelTextContrast: number;
        floatingLabelUppercase: boolean;
        floatingLabelFixed: boolean;
        floatingLabelTransition: string;
        floatingLabelOutlineWidth: string;
        floatingLabelOutlineStyle: string;
        showTrailingSymbol: boolean;
        trailingIconFont: string;
        trailingSymbol: string;
        trailingSymbolType: string;
        trailingSymbolSize: string;
        trailingSymbolMargin: string;
        showErrorSymbol: boolean;
        errorIconFont: string;
        errorSymbol: string;
        errorSymbolType: string;
        errorSymbolSize: string;
        errorSymbolMargin: string;
        showUnderline: boolean;
        underlineHeight: string;
        underlineOpacity: number;
        focusedUnderlineOpacity: number;
        underlineTransition: string;
        underlineTransform: string;
        focusedUnderlineTransform: string;
        showHelperText: boolean;
        helperTextWidth: string;
        helperTextHeight: string;
        helperTextMargin: string;
        helperTextPadding: string;
        helperText: string;
        localizableHelperText: string;
        helperTextAlignment: string;
        helperTextLineClamp: number;
        helperTextWrapping: string;
        helperTextTrimming: string;
        helperTextFontClass: string;
        helperTextFontSize: string;
        helperTextFontWeight: string;
        helperTextLineHeight: string;
        helperTextContrast: number;
        helperTextUppercase: boolean;
        showErrorText: boolean;
        errorTextWidth: string;
        errorTextHeight: string;
        errorTextMargin: string;
        errorTextPadding: string;
        errorText: string;
        errorTextAlignment: string;
        errorTextLineClamp: number;
        errorTextWrapping: string;
        errorTextTrimming: string;
        errorTextFontClass: string;
        errorTextFontSize: string;
        errorTextFontWeight: string;
        errorTextLineHeight: string;
        errorTextContrast: number;
        errorTextUppercase: boolean;
        backgroundColor: string;
        inputBackgroundColor: string;
        hoverInputBackgroundColor: string;
        focusedInputBackgroundColor: string;
        floatingLabelBackgroundColor: string;
        underlineColor: string;
        focusedUnderlineColor: string;
        symbolForegroundColor: string;
        labelForegroundColor: string;
        inputForegroundColor: string;
        hoverInputForegroundColor: string;
        leadingSymbolForegroundColor: string;
        floatingLabelForegroundColor: string;
        focusedFloatingLabelForegroundColor: string;
        trailingSymbolForegroundColor: string;
        helperTextForegroundColor: string;
        errorColor: string;
        borderColor: string;
        inputBorderColor: string;
        hoverInputBorderColor: string;
        focusedInputBorderColor: string;
        floatingLabelOutlineColor: string;
        caretColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        disabledFloatingLabelOutlineColor: string;
        useTouchkeyboard: boolean;
        touchkeyboardDialogName: string;
        forceTouchKeyboardOnMobileDevice: boolean;
        private _labelElement;
        private _inputContainerElement;
        private _inputFieldContainerElement;
        private _inputElement;
        private _leadingSymbolElement;
        private _inputFieldElement;
        private _floatingLabelElement;
        private _trailingSymbolElement;
        private _errorSymbolElement;
        private _underlineElement;
        private _helperTextElement;
        private _errorTextElement;
        private _boundValueChangedHandler;
        private _boundLocalizableErrorTextHandler;
        observe: any;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        afterInit(): void;
        writeValue(value: string): void;
        valueChangeHandler(args: any): void;
        private localizableErrorTextObject;
        private _localizableErrorTextHandler;
        private _localizableErrorText;
        get localizableErrorText(): string;
        set localizableErrorText(value: string);
        _updateLayout(changes: any): void;
        _updateColors(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class DateTimeVarIn extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            valueChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            focused: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            hover: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            canRecipeEdit: {
                propertyType: string;
                type: string;
                child: string;
            };
            variableName: {
                propertyType: string;
                type: string;
                child: string;
            };
            value: {
                propertyType: string;
                type: string;
                child: string;
            };
            abortOnEsc: {
                propertyType: string;
                type: string;
                child: string;
            };
            writeOnReturn: {
                propertyType: string;
                type: string;
                child: string;
            };
            selectOnFocus: {
                propertyType: string;
                type: string;
                child: string;
            };
            lostKeyboardFocusBehaviour: {
                propertyType: string;
                type: string;
                child: string;
            };
            limitMin: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            limitMax: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            useVariableLimits: {
                propertyType: string;
                type: string;
                child: string;
            };
            isLimitCheckEnabled: {
                propertyType: string;
                type: string;
                child: string;
            };
            dateTimeMode: {
                propertyType: string;
                type: string;
                child: string;
            };
            formatDate: {
                propertyType: string;
                type: string;
                child: string;
            };
            step: {
                propertyType: string;
                type: string;
                child: string;
            };
            formatTime: {
                propertyType: string;
                type: string;
                child: string;
            };
            userDefinedDate: {
                propertyType: string;
                type: string;
                child: string;
            };
            userDefinedTime: {
                propertyType: string;
                type: string;
                child: string;
            };
            invalidDateErrorText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableInvalidDateErrorText: {
                propertyType: string;
                type: string;
                child: string;
            };
            limitMinErrorText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableLimitMinErrorText: {
                propertyType: string;
                type: string;
                child: string;
            };
            limitMaxErrorText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableLimitMaxErrorText: {
                propertyType: string;
                type: string;
                child: string;
            };
            variableWriteErrorText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableVariableWriteErrorText: {
                propertyType: string;
                type: string;
                child: string;
            };
            watermarkText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableWatermarkText: {
                propertyType: string;
                type: string;
                child: string;
            };
            inputContainerWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputBorderRadius: {
                propertyType: string;
                type: string;
            };
            inputWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputHeight: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            inputMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            inputFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputMode: {
                propertyType: string;
                type: string;
                child: string;
            };
            outlined: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            inputFieldMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelContainerWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showLeadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            leadingIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showFloatingLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            floatingLabelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableFloatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFixed: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            floatingLabelTransition: {
                propertyType: string;
                type: string;
            };
            floatingLabelOutlineWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            floatingLabelOutlineStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showTrailingSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            trailingIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showErrorSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            errorIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showUnderline: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            underlineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            underlineOpacity: {
                propertyType: string;
                type: string;
            };
            focusedUnderlineOpacity: {
                propertyType: string;
                type: string;
            };
            underlineTransition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            underlineTransform: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            focusedUnderlineTransform: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showHelperText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            helperTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableHelperText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            helperTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showErrorText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            errorTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorText: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            localizableErrorText: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
            };
            errorTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            errorTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorMode: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedInputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            underlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedUnderlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            symbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            leadingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedFloatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            trailingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            helperTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            errorColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedInputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelOutlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            caretColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledFloatingLabelOutlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        alignItems: string;
        justifyContent: string;
        variableName: string;
        value: any;
        abortOnEsc: boolean;
        writeOnReturn: boolean;
        selectOnFocus: boolean;
        lostKeyboardFocusBehaviour: string;
        limitMin: string;
        limitMax: string;
        useVariableLimits: boolean;
        dateTimeMode: string;
        formatDate: string;
        formatTime: string;
        userDefinedDate: string;
        userDefinedTime: string;
        invalidDateErrorText: string;
        localizableInvalidDateErrorText: string;
        limitMinErrorText: string;
        localizableLimitMinErrorText: string;
        limitMaxErrorText: string;
        localizableLimitMaxErrorText: string;
        variableWriteErrorText: string;
        localizableVariableWriteErrorText: string;
        watermarkText: string;
        localizableWatermarkText: string;
        inputContainerWidth: string;
        inputContainerHeight: string;
        inputContainerMargin: string;
        inputContainerPadding: string;
        inputBorderWidth: string;
        inputBorderStyle: string;
        inputBorderRadius: string;
        inputWidth: string;
        inputHeight: string;
        inputMargin: string;
        inputPadding: string;
        inputTextAlignment: string;
        inputFontClass: string;
        inputFontSize: string;
        inputFontWeight: string;
        inputLineHeight: string;
        inputTextContrast: number;
        inputMode: string;
        outlined: boolean;
        inputFieldMargin: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        labelContainerWidth: string;
        labelContainerHeight: string;
        labelContainerMargin: string;
        labelContainerPadding: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        useVariableText: boolean;
        labelText: string;
        localizableLabelText: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        showLeadingSymbol: boolean;
        leadingIconFont: string;
        leadingSymbol: string;
        leadingSymbolType: string;
        leadingSymbolSize: string;
        leadingSymbolMargin: string;
        showFloatingLabel: boolean;
        floatingLabelWidth: string;
        floatingLabelHeight: string;
        floatingLabelMargin: string;
        floatingLabelPadding: string;
        floatingLabelText: string;
        localizableFloatingLabelText: string;
        floatingLabelTextAlignment: string;
        floatingLabelLineClamp: number;
        floatingLabelTextWrapping: string;
        floatingLabelTextTrimming: string;
        floatingLabelFontClass: string;
        floatingLabelFontSize: string;
        floatingLabelFontWeight: string;
        floatingLabelLineHeight: string;
        floatingLabelTextContrast: number;
        floatingLabelUppercase: boolean;
        floatingLabelFixed: boolean;
        floatingLabelTransition: string;
        floatingLabelOutlineWidth: string;
        floatingLabelOutlineStyle: string;
        showTrailingSymbol: boolean;
        trailingIconFont: string;
        trailingSymbol: string;
        trailingSymbolType: string;
        trailingSymbolSize: string;
        trailingSymbolMargin: string;
        showErrorSymbol: boolean;
        errorIconFont: string;
        errorSymbol: string;
        errorSymbolType: string;
        errorSymbolSize: string;
        errorSymbolMargin: string;
        showUnderline: boolean;
        underlineHeight: string;
        underlineOpacity: number;
        focusedUnderlineOpacity: number;
        underlineTransition: string;
        underlineTransform: string;
        focusedUnderlineTransform: string;
        showHelperText: boolean;
        helperTextWidth: string;
        helperTextHeight: string;
        helperTextMargin: string;
        helperTextPadding: string;
        helperText: string;
        localizableHelperText: string;
        helperTextAlignment: string;
        helperTextLineClamp: number;
        helperTextWrapping: string;
        helperTextTrimming: string;
        helperTextFontClass: string;
        helperTextFontSize: string;
        helperTextFontWeight: string;
        helperTextLineHeight: string;
        helperTextContrast: number;
        helperTextUppercase: boolean;
        showErrorText: boolean;
        errorTextWidth: string;
        errorTextHeight: string;
        errorTextMargin: string;
        errorTextPadding: string;
        errorText: string;
        errorTextAlignment: string;
        errorTextLineClamp: number;
        errorTextWrapping: string;
        errorTextTrimming: string;
        errorTextFontClass: string;
        errorTextFontSize: string;
        errorTextFontWeight: string;
        errorTextLineHeight: string;
        errorTextContrast: number;
        errorTextUppercase: boolean;
        backgroundColor: string;
        inputBackgroundColor: string;
        hoverInputBackgroundColor: string;
        focusedInputBackgroundColor: string;
        floatingLabelBackgroundColor: string;
        underlineColor: string;
        focusedUnderlineColor: string;
        symbolForegroundColor: string;
        labelForegroundColor: string;
        inputForegroundColor: string;
        hoverInputForegroundColor: string;
        leadingSymbolForegroundColor: string;
        floatingLabelForegroundColor: string;
        focusedFloatingLabelForegroundColor: string;
        trailingSymbolForegroundColor: string;
        helperTextForegroundColor: string;
        errorColor: string;
        borderColor: string;
        inputBorderColor: string;
        hoverInputBorderColor: string;
        focusedInputBorderColor: string;
        floatingLabelOutlineColor: string;
        caretColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        disabledFloatingLabelOutlineColor: string;
        private _labelElement;
        private _inputContainerElement;
        private _inputFieldContainerElement;
        private _inputElement;
        private _leadingSymbolElement;
        private _inputFieldElement;
        private _floatingLabelElement;
        private _trailingSymbolElement;
        private _errorSymbolElement;
        private _underlineElement;
        private _helperTextElement;
        private _errorTextElement;
        private _boundValueChangedHandler;
        private _boundLocalizableErrorTextHandler;
        observe: any;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        beforeInit(): void;
        afterInit(): void;
        valueChangeHandler(args: any): void;
        private localizableErrorTextObject;
        private _localizableErrorTextHandler;
        private _localizableErrorText;
        get localizableErrorText(): string;
        set localizableErrorText(value: string);
        _updateLayout(changes: any): void;
        _updateColors(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IDateTimeVarOut extends IVariableBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class DateTimeVarOut extends VisiWin.UI.VariableBase {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            dateTimeMode: {
                propertyType: string;
                type: string;
                defaultValue: DateTimeModeNames;
            };
            formatDate: {
                propertyType: string;
                type: string;
                defaultValue: DateTimeFormatNames;
            };
            formatTime: {
                propertyType: string;
                type: string;
                defaultValue: DateTimeFormatNames;
            };
            userDefinedDate: {
                propertyType: string;
                type: string;
            };
            userDefinedTime: {
                propertyType: string;
                type: string;
            };
            value: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
            };
            dateWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateMargin: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            datePadding: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            dateUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeMargin: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timePadding: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            timeUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            dateBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            timeBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            dateForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            timeForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            focusedFloatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            leadingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelContainerBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelContainerBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            showLeadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: boolean;
            };
            leadingIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            leadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            leadingSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            leadingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            leadingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            showFloatingLabel: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: boolean;
            };
            floatingLabelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: string;
            };
            localizableFloatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            floatingLabelFixed: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            floatingLabelTransition: {
                propertyType: string;
                type: string;
            };
            labelContainerWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelContainerHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelContainerMargin: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelContainerPadding: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelContainerBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelContainerBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelContainerBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: boolean;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                childOption: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                childOption: string;
            };
            useVariableLabelText: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                childOption: string;
            };
            variableLabelName: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                childOption: string;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        alignItems: string;
        justifyContent: string;
        dateTimeMode: string;
        formatDate: string;
        formatTime: string;
        userDefinedDate: string;
        userDefinedTime: string;
        dateWidth: string;
        dateHeight: string;
        dateMargin: string;
        datePadding: string;
        dateTextAlignment: string;
        dateLineClamp: number;
        dateTextWrapping: string;
        dateTextTrimming: string;
        dateFontClass: string;
        dateFontSize: string;
        dateFontWeight: string;
        dateLineHeight: string;
        dateTextContrast: number;
        dateUppercase: boolean;
        timeWidth: string;
        timeHeight: string;
        timeMargin: string;
        timePadding: string;
        timeTextAlignment: string;
        timeLineClamp: number;
        timeTextWrapping: string;
        timeTextTrimming: string;
        timeFontClass: string;
        timeFontSize: string;
        timeFontWeight: string;
        timeLineHeight: string;
        timeTextContrast: number;
        timeUppercase: boolean;
        backgroundColor: string;
        dateBackgroundColor: string;
        timeBackgroundColor: string;
        dateForegroundColor: string;
        timeForegroundColor: string;
        borderColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        leadingSymbolForegroundColor: string;
        floatingLabelForegroundColor: string;
        floatingLabelBackgroundColor: string;
        focusedFloatingLabelForegroundColor: string;
        labelForegroundColor: string;
        labelContainerBorderColor: string;
        labelContainerBackgroundColor: string;
        showLeadingSymbol: boolean;
        leadingIconFont: string;
        leadingSymbol: string;
        leadingSymbolType: string;
        leadingSymbolSize: string;
        leadingSymbolMargin: string;
        showFloatingLabel: boolean;
        floatingLabelWidth: string;
        floatingLabelHeight: string;
        floatingLabelMargin: string;
        floatingLabelPadding: string;
        floatingLabelText: string;
        localizableFloatingLabelText: string;
        floatingLabelTextAlignment: string;
        floatingLabelLineClamp: number;
        floatingLabelTextWrapping: string;
        floatingLabelTextTrimming: string;
        floatingLabelFontClass: string;
        floatingLabelFontSize: string;
        floatingLabelFontWeight: string;
        floatingLabelLineHeight: string;
        floatingLabelTextContrast: number;
        floatingLabelUppercase: boolean;
        floatingLabelFixed: boolean;
        floatingLabelTransition: string;
        floatingLabelOutlineWidth: string;
        floatingLabelOutlineStyle: string;
        labelContainerWidth: string;
        labelContainerHeight: string;
        labelContainerMargin: string;
        labelContainerPadding: string;
        labelContainerBorderWidth: string;
        labelContainerBorderStyle: string;
        labelContainerBorderRadius: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        useVariableLabelText: string;
        variableLabelName: string;
        get value(): Date;
        set value(value: Date);
        _dateElement: VWElement;
        _timeElement: VWElement;
        _dtcontainer: HTMLElement;
        _outerdiv: HTMLElement;
        _leadingSymbolElement: VWElement;
        _floatingLabelElement: VWElement;
        _labelElement: VWElement;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        afterInit(): void;
        onLanguageChanged(args: any): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _formattingDate(date: any): string;
        _formattingTime(date: any): string;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class Clock extends VisiWin.UI.VariableBase {
        private properties;
        private alignItems;
        private justifyContent;
        private dateTimeMode;
        private formatDate;
        private formatTime;
        private _dateElement;
        private _timeElement;
        private _clock;
        private _interval;
        constructor(element: any, options: any);
        createTemplate(): Promise<any>;
        afterInit(): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        onLanguageChanged(args: any): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _formattingDate(date: any): string;
        _formattingTime(date: any): string;
        clockStart(): void;
        clockEnd(): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IRadialRange extends VisiWin.UI.IControlBase {
        /**
          * constructor: Creates a new RadialRange.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new RadialRange control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialRange control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialRange control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialRange control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialRange control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialRange control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialRange control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialRange control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialRange control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * minValue property / option
         * Get and set the property "minValue".
         * The minValue property defines the minimal value for all range elements.
         * Note: To display the desired range elements, the property minValue must be less than the property maxValue,
         *       otherwise, control will not display ranges.
         * Datatype: number
         * Defaultvalue: 0
         * Valid values: number
        **/
        minValue: number;
        /**
         * maxValue property / option
         * Get and set the property "maxValue".
         * The maxValue property defines the maximal value for all range elements.
         * Note: To display the desired range elements, the property maxValue must be greater than the property minValue,
         *       otherwise, control will not display ranges.
         * Datatype: number
         * Defaultvalue: 100
         * Valid values: number
        **/
        maxValue: number;
        /**
         * startAngle property / option
         * Get and set the property "startAngle".
         * The startAngle property defines start angle for all range elements.
         * Note: Angles are expressed in degrees. The starting point (+/- 0) is located in the north.
         * Datatype: number
         * Defaultvalue: -135
         * Valid values: number
        **/
        startAngle: number;
        /**
         * endAngle property / option
         * Get and set the property "endAngle".
         * The endAngle property defines end angle for all range elements.
         * Note: Angles are expressed in degrees. The ending point (+/- 360) is located in the north.
         * Datatype: number
         * Defaultvalue: 135
         * Valid values: number
        **/
        endAngle: number;
        /**
         * innerRadius property / option
         * Get and set the property "innerRadius".
         * The innerRadius property defines inside radius for all range elements.
         * Note: To display the desired range elements, the property innerRadius must be different than the property outerRadius,
         *       otherwise, control will not display ranges.
         * Datatype: string
         * Defaultvalue: 90%
         * Valid values: | px | % |
        **/
        innerRadius: string;
        /**
         * outerRadius property / option
         * Get and set the property "outerRadius".
         * The outerRadius property defines outside radius for all range elements.
         * Note: To display the desired range elements, the property outerRadius must be different than the property innerRadius,
         *       otherwise, control will not display ranges.
         * Datatype: string
         * Defaultvalue: 100%
         * Valid values: | px | % |
        **/
        outerRadius: string;
        /**
         * ranges property / option
         * Get and set the property "ranges".
         * The ranges property defines range elements.
         * Note: This property can be defined as follows:
         *         ranges:[
         *             {
         *                 min:0,
         *                 max:50,
         *                 color:'red',
         *                 innerRadius:'80%',
         *                 outerRadius:'50%'
         *             },
         *             {
         *                 min:50,
         *                 max:100
         *             } ...
         *         ]
         *
         *     min/max    : For each range object must be defined min and max property, provided that the max must be greater than the min.
         *                  If the value of min is less than the value of "minValue", the value of min is equal to the value of "minValue",
         *                  if the value of max is greater than the value of "maxValue", the value of max is equal to the value of "maxValue".
         *     color      : It is recommended to define, otherwise it takes a random color value.
         *     innerRadius: For each range element it is possible to define separate inside radius.
         *     outerRadius: For each range element it is possible to define separate outside radius.
         *
         * Datatype: any
         * Defaultvalue: null
         * Valid values: object
        **/
        ranges: any;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * color property / option
         * Get and set the property "color" of the corrosponding HTML Element.
         * The color property paints the interior of the SVG path "range".
         * Note: Each range has its own color property. Generally defined property color is valid only for "basic" range.
         *       If there is property "ranges" defined, it is recommended for each range array to define the color property,
         *       otherwise, with each interaction with the Control the range gets random color.
         * Datatype: string
         * Defaultvalue: 'basic' range: 'gray'; other ranges: random color
         * Valid values: color | transparent | inherit | initial
        **/
        color: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class RadialRange extends VisiWin.UI.VariableBase {
        private properties;
        rawLimitMin: number;
        rawLimitMax: number;
        limits: any;
        pLimits: any;
        rawReferenceValue: number;
        startAngle: number;
        endAngle: number;
        centerX: string;
        centerY: string;
        innerRadius: string;
        outerRadius: string;
        showAllRanges: boolean;
        backgroundColor: string;
        disabledBackgroundColor: string;
        disabledIndicatorColor: string;
        private _limitsCollection;
        private indicatorColor;
        private _svgElement;
        private _boundLimitsChangedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        resizeHandler(): void;
        beforeInit(): void;
        registerChild(controlType: string, action: string, limit: VWElement, options: any): any;
        ready(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _drawRadialRanges(): void;
        _limitsChangedHandler(changes: any): void;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class RadialRangeLimit extends VisiWin.UI.ControlBase {
        private properties;
        startValue: number;
        endValue: number;
        innerRadius: string;
        outerRadius: string;
        fillColor: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IRadialScale extends VisiWin.UI.IControlBase {
        /**
          * constructor: Creates a new RadialScale.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new RadialScale control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialScale control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialScale control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialScale control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialScale control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialScale control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialScale control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialScale control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialScale control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * minValue property / option
         * Get and set the property "minValue".
         * The property minValue defines the minimal value for the radial scale element.
         * Note: To display the desired radial scale element, the property minValue must be less than the property maxValue,
         *       otherwise, control will not display radial scale.
         * Datatype: number
         * Defaultvalue: 0
         * Valid values: number
        **/
        minValue: number;
        /**
         * maxValue property / option
         * Get and set the property "maxValue".
         * The property maxValue defines the maximal value for the radial scale element.
         * Note: To display the desired radial scale element, the property maxValue must be greater than the property minValue,
         *       otherwise, control will not display radial scale.
         * Datatype: number
         * Defaultvalue: 100
         * Valid values: number
        **/
        maxValue: number;
        /**
         * startAngle property / option
         * Get and set the property "startAngle".
         * The property startAngle defines start angle for the radial scale element.
         * Note: Angles are expressed in degrees. The starting point (+/- 0) is located in the north.
         * Datatype: number
         * Defaultvalue: -135
         * Valid values: number
        **/
        startAngle: number;
        /**
         * endAngle property / option
         * Get and set the property "endAngle".
         * The property endAngle defines end angle for the radial scale element.
         * Note: Angles are expressed in degrees. The ending point (+/- 360) is located in the north.
         * Datatype: number
         * Defaultvalue: 135
         * Valid values: number
        **/
        endAngle: number;
        /**
         * radius property / option
         * Get and set the property "radius".
         * The property radius defines radius for the radial scale element.
         * Datatype: string
         * Defaultvalue: 100%
         * Valid values: | px | % |
        **/
        radius: string;
        /**
         * scaleOrientation property / option
         * Get and set the property "scaleOrientation".
         * The property scaleOrientation defines the orientation of the scale element.
         * Note: There are two possibilities:
         *       'inside'  : scale is drawn to the inside (starting from the defined radius value).
         *       'outside' : scale is drawn to the outside (starting from the defined radius value).
         * Datatype: enum like string
         * Defaultvalue: 'inside'
         * Valid values: 'inside', 'outside'
        **/
        scaleOrientation: string;
        /**
         * baseLineVisible property / option
         * Get and set the property "baseLineVisible".
         * The property baseLineVisible shows or hides radial scale base line.
         * Note: Base line is 1px width and has color "black".
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        baseLineVisible: boolean;
        /**
         * labelVisible property / option
         * Get and set the property "labelVisible".
         * The property labelVisible shows or hides radial scale label elements.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        labelVisible: boolean;
        /**
         * labelMargin property / option
         * Get and set the property "labelMargin".
         * The property labelMargin defines distance in px between radial scale label element and major tick.
         * Datatype: number
         * Defaultvalue: 5
         * Valid values: number
        **/
        labelMargin: number;
        /**
         * labelFontSize property / option
         * Get and set the property "labelFontSize".
         * The property labelFontSize defines font size of the radial scale label elements.
         * Datatype: number
         * Defaultvalue: 10
         * Valid values: number
        **/
        labelFontSize: number;
        /**
         * labelFormat property / option
         * Get and set the property "labelFormat".
         * Format the label element.
         * Datatype: string
         * Defaultvalue: null
        **/
        labelFormat: string;
        /**
         * majorTicksVisible property / option
         * Get and set the property "majorTicksVisible".
         * The property majorTicksVisible shows or hides radial scale major ticks.
         * Note: If the major ticks are hidden, middle and minor ticks are also hidden.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        majorTicksVisible: boolean;
        /**
         * majorTicks property / option
         * Get and set the property "majorTicks".
         * The property majorTicks sets the number of radial scale major ticks.
         * Datatype: number
         * Defaultvalue: 2
         * Valid values: number
        **/
        majorTicks: number;
        /**
         * majorTicksLength property / option
         * Get and set the property "majorTicksLength".
         * The property majorTicksLength sets the length in px of radial scale major ticks.
         * Datatype: number
         * Defaultvalue: 8
         * Valid values: number
        **/
        majorTicksLength: number;
        /**
         * majorTicksWidth property / option
         * Get and set the property "majorTicksWidth".
         * The property majorTicksWidth sets the width in px of radial scale major ticks.
         * Datatype: number
         * Defaultvalue: 1
         * Valid values: number
        **/
        majorTicksWidth: number;
        /**
         * middleTicksVisible property / option
         * Get and set the property "middleTicksVisible".
         * The property middleTicksVisible shows or hides radial scale middle ticks.
         * Note: If the middle ticks are hidden, minor ticks are also hidden.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        middleTicksVisible: boolean;
        /**
         * middleTicks property / option
         * Get and set the property "middleTicks".
         * The property middleTicks sets the number of radial scale middle ticks.
         * Datatype: number
         * Defaultvalue: 2
         * Valid values: number
        **/
        middleTicks: number;
        /**
         * middleTicksLength property / option
         * Get and set the property "middleTicksLength".
         * The property middleTicksLength sets the length in px of radial scale middle ticks.
         * Datatype: number
         * Defaultvalue: 5
         * Valid values: number
        **/
        middleTicksLength: number;
        /**
         * middleTicksWidth property / option
         * Get and set the property "middleTicksWidth".
         * The property middleTicksWidth sets the width in px of radial scale middle ticks.
         * Datatype: number
         * Defaultvalue: 1
         * Valid values: number
        **/
        middleTicksWidth: number;
        /**
         * minorTicksVisible property / option
         * Get and set the property "minorTicksVisible".
         * The property minorTicksVisible shows or hides radial scale minor ticks.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        minorTicksVisible: boolean;
        /**
         * minorTicks property / option
         * Get and set the property "minorTicks".
         * The property minorTicks sets the number of radial scale minor ticks.
         * Datatype: number
         * Defaultvalue: 2
         * Valid values: number
        **/
        minorTicks: number;
        /**
         * minorTicksLength property / option
         * Get and set the property "minorTicksLength".
         * The property minorTicksLength sets the length in px of radial scale minor ticks.
         * Datatype: number
         * Defaultvalue: 2
         * Valid values: number
        **/
        minorTicksLength: number;
        /**
         * minorTicksWidth property / option
         * Get and set the property "minorTicksWidth".
         * The property minorTicksWidth sets the width in px of radial scale minor ticks.
         * Datatype: number
         * Defaultvalue: 1
         * Valid values: number
        **/
        minorTicksWidth: number;
        /**
         * valueFix property / option
         * Get and set the property "valueFix".
         * The property valueFix converts label values into a string, keeping a specified number of decimals.
         * Note: If the desired number of decimals are higher than the actual value number,
         *       nulls are added to create the desired decimal length.
         * Datatype: number
         * Defaultvalue: 0
         * Valid values: number
        **/
        valueFix: number;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * labelColor property / option
         * Get and set the property "labelColor".
         * The labelColor property defines the radial scale label color.
         * Datatype: string
         * Defaultvalue: 'black'
         * Valid values: color | transparent | inherit | initial
        **/
        labelColor: string;
        /**
         * majorTicksColor property / option
         * Get and set the property "majorTicksColor".
         * The majorTicksColor property defines the radial scale major ticks color.
         * Datatype: string
         * Defaultvalue: 'black'
         * Valid values: color | transparent | inherit | initial
        **/
        majorTicksColor: string;
        /**
         * middleTicksColor property / option
         * Get and set the property "middleTicksColor".
         * The middleTicksColor property defines the radial scale middle ticks color.
         * Datatype: string
         * Defaultvalue: 'black'
         * Valid values: color | transparent | inherit | initial
        **/
        middleTicksColor: string;
        /**
         * minorTicksColor property / option
         * Get and set the property "minorTicksColor".
         * The minorTicksColor property defines the radial scale minor ticks color.
         * Datatype: string
         * Defaultvalue: 'black'
         * Valid values: color | transparent | inherit | initial
        **/
        minorTicksColor: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class RadialScale extends VisiWin.UI.VariableBase {
        private properties;
        rawLimitMin: number;
        rawLimitMax: number;
        mode: string;
        placement: string;
        showBaseLine: boolean;
        limitsVisibility: string;
        startAngle: number;
        endAngle: number;
        centerX: string;
        centerY: string;
        radius: string;
        showMajorTicks: boolean;
        majorStepSize: number;
        majorSteps: number;
        majorTicksLength: number;
        majorTicksWidth: number;
        showMiddleTicks: boolean;
        middleStepSize: number;
        middleSteps: number;
        middleTicksLength: number;
        middleTicksWidth: number;
        showMinorTicks: boolean;
        minorStepSize: number;
        minorSteps: number;
        minorTicksLength: number;
        minorTicksWidth: number;
        showMajorLabels: boolean;
        majorLabelsFontClass: string;
        majorLabelsFontSize: string;
        majorLabelsFontWeight: string;
        majorLabelsLineHeight: string;
        majorLabelsTextContrast: number;
        majorLabelsOffset: number;
        majorLabelsDecimalPlaces: number;
        backgroundColor: string;
        foregroundColor: string;
        majorTicksColor: string;
        middleTicksColor: string;
        minorTicksColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        private _labels;
        private _clientWidth;
        private _clientHeight;
        private resizeObserver;
        private _svgElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        resizeHandler(): void;
        beforeInit(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _drawRadialScale(): void;
        _stepsizeStepsToValues(minValue: number, maxValue: number, steps: number, index: number, minorTicks: boolean): any[];
        _stepsToValues(minValue: number, maxValue: number, steps: number): any[];
        _stepSizeToValues(minValue: any, maxValue: any, stepSize: any): any[];
        _ticksToCoordinates(minValue: any, maxValue: any, centerX: any, centerY: any, startAngle: any, endAngle: any, radius: any, placement: any, ticks: any, ticksLength: any): void;
        _drawTicks(ticks: any, ticksWidth: any, ticksColor: any): void;
        _drawRadialLabelsSVG(centerX: any, centerY: any, radius: any, placement: any, ticks: any, fontClass: any, fontSize: any, fontWeight: any, lineHeight: any, textContrast: any, ticksLength: any, offset: any, decimalPlaces: any): void;
        _drawBaseline(centerX: any, centerY: any, startAngle: any, endAngle: any, radius: any, thickness: any, placement: any, color: any): void;
        dispose(): boolean;
    }
}
declare var Snap: any;
declare namespace VisiWin.UI {
    class RadialIndicator extends VisiWin.UI.VariableBase {
        private properties;
        rawLimitMin: number;
        rawLimitMax: number;
        startAngle: number;
        endAngle: number;
        backgroundColor: string;
        disabledBackgroundColor: string;
        private _svgLoadedFlag;
        private _centerX;
        private _centerY;
        private _svgElement;
        private _svgGroupElement;
        private _svgElementHtml;
        private _clientWidth;
        private _clientHeight;
        indicatorUri: string;
        indicatorSize: string;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        resizeHandler(): void;
        beforeInit(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _drawRadialIndicator(): void;
        _loadSVG(uri: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IRadialInstrument extends VisiWin.UI.IControlBase {
        /**
          * constructor: Creates a new RadialInstrument.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new RadialInstrument control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialInstrument control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialInstrument control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialInstrument control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialInstrument control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialInstrument control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialInstrument control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialInstrument control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadialInstrument control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * minValue property / option
         * Get and set the property "minValue".
         * The property minValue defines minimal value for the radial instrument.
         * Note: To display the desired radial instrument, the property minValue must be less than the property maxValue,
         *       otherwise, control will not display radial instrument.
         * Datatype: number
         * Defaultvalue: 0
         * Valid values: number
        **/
        minValue: number;
        /**
         * maxValue property / option
         * Get and set the property "maxValue".
         * The property maxValue defines maximal value for the radial instrument.
         * Note: To display the desired radial instrument, the property maxValue must be greater than the property minValue,
         *       otherwise, control will not display radial instrument.
         * Datatype: number
         * Defaultvalue: 9
         * Valid values: number
        **/
        maxValue: number;
        /**
         * startAngle property / option
         * Get and set the property "startAngle".
         * The property startAngle defines start angle for the radial instrument.
         * Note: Angles are expressed in degrees. The starting point (+/- 0) is located in the north.
         * Datatype: number
         * Defaultvalue: -135
         * Valid values: number
        **/
        startAngle: number;
        /**
         * endAngle property / option
         * Get and set the property "endAngle".
         * The property endAngle defines end angle for the radial instrument.
         * Note: Angles are expressed in degrees. The ending point (+/- 360) is located in the north.
         * Datatype: number
         * Defaultvalue: 135
         * Valid values: number
        **/
        endAngle: number;
        /**
         * backgroundUri property / option
         * Get and set the property "backgroundUri".
         * The property backgroundUri selects desired svg image for the radial instrument background (e.g. backgroundUri:'/myFolder/mySymbol.svg').
         * Note: SVG image must have defined SVG attribute viewBox and width, height must be 100%,
         *       otherwise, control will not adjust background properly.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: valid svg file
        **/
        backgroundUri: string;
        /**
         * needledUri property / option
         * Get and set the property "needledUri".
         * The property needledUri selects desired svg image for the radial instrument needle (e.g. needledUri:'/myFolder/mySymbol.svg').
         * Note: SVG image must have defined SVG attribute viewBox and width, height must be 100%,
         *       otherwise, control will not adjust needle properly.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: valid svg file
        **/
        needledUri: string;
        /**
         * needleMargin property / option
         * Get and set the property "needleMargin".
         * The property needleMargin sets margin between needle element and main container element.
         * Datatype: number
         * Defaultvalue: 15
         * Valid values: number
        **/
        needleMargin: number;
        /**
         * rangeInnerRadius property / option
         * Get and set the property "rangeInnerRadius".
         * The rangeInnerRadius property defines inside radius for all range elements.
         * Note: To display the desired range elements, the property rangeInnerRadius must be different than the property rangeOuterRadius,
         *       otherwise, control will not display ranges.
         * Datatype: string
         * Defaultvalue: 90%
         * Valid values: | px | % |
        **/
        rangeInnerRadius: string;
        /**
         * rangeOuterRadius property / option
         * Get and set the property "rangeOuterRadius".
         * The rangeOuterRadius property defines outside radius for all range elements.
         * Note: To display the desired range elements, the property rangeOuterRadius must be different than the property rangeInnerRadius,
         *       otherwise, control will not display ranges.
         * Datatype: string
         * Defaultvalue: 100%
         * Valid values: | px | % |
        **/
        rangeOuterRadius: string;
        /**
         * rangeRanges property / option
         * Get and set the property "rangeRanges".
         * The rangeRanges property defines radial scale range elements.
         * Note: This property can be defined as follows:
         *         rangeRanges:[
         *             {
         *                 min:0,
         *                 max:50,
         *                 color:'red',
         *                 innerRadius:'80%',
         *                 outerRadius:'50%'
         *             },
         *             {
         *                 min:50,
         *                 max:100
         *             } ...
         *         ]
         *
         *     min/max    : For each range object must be defined min and max property, provided that the max must be greater than the min.
         *                  If the value of min is less than the value of "minValue", the value of min is equal to the value of "minValue",
         *                  if the value of max is greater than the value of "maxValue", the value of max is equal to the value of "maxValue".
         *     color      : It is recommended to define, otherwise it takes a random color value.
         *     innerRadius: For each range element it is possible to define separate inside radius.
         *     outerRadius: For each range element it is possible to define separate outside radius.
         *
         * Datatype: any
         * Defaultvalue: null
         * Valid values: object
        **/
        rangeRanges: any;
        /**
         * scaleRadius property / option
         * Get and set the property "scaleRadius".
         * The property scaleRadius defines radius for the radial scale element.
         * Datatype: string
         * Defaultvalue: 100%
         * Valid values: | px | % |
        **/
        scaleRadius: string;
        /**
         * scaleOrientation property / option
         * Get and set the property "scaleOrientation".
         * The property scaleOrientation defines the orientation of the scale element.
         * Note: There are two possibilities:
         *       'inside'  : scale is drawn to the inside (starting from the defined radius value).
         *       'outside' : scale is drawn to the outside (starting from the defined radius value).
         * Datatype: enum like string
         * Defaultvalue: 'inside'
         * Valid values: 'inside', 'outside'
        **/
        scaleOrientation: string;
        /**
         * scaleBaseLineVisible property / option
         * Get and set the property "scaleBaseLineVisible".
         * The property scaleBaseLineVisible shows or hides radial scale base line.
         * Note: Base line is 1px width and has color "black".
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        scaleBaseLineVisible: boolean;
        /**
         * scaleLabelVisible property / option
         * Get and set the property "scaleLabelVisible".
         * The property scaleLabelVisible shows or hides radial scale label elements.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        scaleLabelVisible: boolean;
        /**
         * scaleLabelMargin property / option
         * Get and set the property "scaleLabelMargin".
         * The property scaleLabelMargin defines distance in px between radial scale label element and major tick.
         * Datatype: number
         * Defaultvalue: 5
         * Valid values: number
        **/
        scaleLabelMargin: number;
        /**
         * scaleLabelFontSize property / option
         * Get and set the property "scaleLabelFontSize".
         * The property scaleLabelFontSize defines font size of the radial scale label elements.
         * Datatype: number
         * Defaultvalue: 10
         * Valid values: number
        **/
        scaleLabelFontSize: number;
        /**
         * scaleLabelFormat property / option
         * Get and set the property "scaleLabelFormat".
         * Format the label element.
         * Datatype: string
         * Defaultvalue: null
        **/
        scaleLabelFormat: string;
        /**
         * scaleMajorTicksVisible property / option
         * Get and set the property "scaleMajorTicksVisible".
         * The property scaleMajorTicksVisible shows or hides radial scale major ticks.
         * Note: If the major ticks are hidden, middle and minor ticks are also hidden.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        scaleMajorTicksVisible: boolean;
        /**
         * scaleMajorTicks property / option
         * Get and set the property "scaleMajorTicks".
         * The property scaleMajorTicks sets the number of radial scale major ticks.
         * Datatype: number
         * Defaultvalue: 2
         * Valid values: number
        **/
        scaleMajorTicks: number;
        /**
         * scaleMajorTicksLength property / option
         * Get and set the property "scaleMajorTicksLength".
         * The property scaleMajorTicksLength sets the length in px of radial scale major ticks.
         * Datatype: number
         * Defaultvalue: 8
         * Valid values: number
        **/
        scaleMajorTicksLength: number;
        /**
         * scaleMajorTicksWidth property / option
         * Get and set the property "scaleMajorTicksWidth".
         * The property scaleMajorTicksWidth sets the width in px of radial scale major ticks.
         * Datatype: number
         * Defaultvalue: 1
         * Valid values: number
        **/
        scaleMajorTicksWidth: number;
        /**
         * scaleMiddleTicksVisible property / option
         * Get and set the property "scaleMiddleTicksVisible".
         * The property scaleMiddleTicksVisible shows or hides radial scale middle ticks.
         * Note: If the middle ticks are hidden, minor ticks are also hidden.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        scaleMiddleTicksVisible: boolean;
        /**
         * scaleMiddleTicks property / option
         * Get and set the property "scaleMiddleTicks".
         * The property scaleMiddleTicks sets the number of radial scale middle ticks.
         * Datatype: number
         * Defaultvalue: 2
         * Valid values: number
        **/
        scaleMiddleTicks: number;
        /**
         * scaleMiddleTicksLength property / option
         * Get and set the property "scaleMiddleTicksLength".
         * The property scaleMiddleTicksLength sets the length in px of radial scale middle ticks.
         * Datatype: number
         * Defaultvalue: 5
         * Valid values: number
        **/
        scaleMiddleTicksLength: number;
        /**
         * scaleMiddleTicksWidth property / option
         * Get and set the property "scaleMiddleTicksWidth".
         * The property scaleMiddleTicksWidth sets the width in px of radial scale middle ticks.
         * Datatype: number
         * Defaultvalue: 1
         * Valid values: number
        **/
        scaleMiddleTicksWidth: number;
        /**
         * scaleMinorTicksVisible property / option
         * Get and set the property "scaleMinorTicksVisible".
         * The property scaleMinorTicksVisible shows or hides radial scale minor ticks.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        scaleMinorTicksVisible: boolean;
        /**
         * scaleMinorTicks property / option
         * Get and set the property "scaleMinorTicks".
         * The property scaleMinorTicks sets the number of radial scale minor ticks.
         * Datatype: number
         * Defaultvalue: 2
         * Valid values: number
        **/
        scaleMinorTicks: number;
        /**
         * scaleMinorTicksLength property / option
         * Get and set the property "scaleMinorTicksLength".
         * The property scaleMinorTicksLength sets the length in px of radial scale minor ticks.
         * Datatype: number
         * Defaultvalue: 2
         * Valid values: number
        **/
        scaleMinorTicksLength: number;
        /**
         * scaleMinorTicksWidth property / option
         * Get and set the property "scaleMinorTicksWidth".
         * The property scaleMinorTicksWidth sets the width in px of radial scale minor ticks.
         * Datatype: number
         * Defaultvalue: 1
         * Valid values: number
        **/
        scaleMinorTicksWidth: number;
        /**
         * scaleValueFix property / option
         * Get and set the property "scaleValueFix".
         * The property scaleValueFix converts radial scale label values into a string, keeping a specified number of decimals.
         * Note: If the desired number of decimals are higher than the actual value number,
         *       nulls are added to create the desired decimal length.
         * Datatype: number
         * Defaultvalue: 0
         * Valid values: number
        **/
        scaleValueFix: number;
        /**
         * variableName property / option
         * Get and set the property "variableName".
         * Legt die VisiWin Variable Fest die angemeldet werden soll.
         * War zuvor eine Varable angemeldet, so wird diese zuvor detach und abgemeldet.
         * Intern wird ein Event Handler auf Veränderungen der Variable angemeldet.
         * Dadurch werden einige Properties des VariablenMixin automatisch verändert:
         *      value, bitValue
         * Soll die Variable abgemeldet und keine neue angemeldet werden, so muss 'null'
         * als Parameter übergeben werden.
         * Datatype: string
         * Defaultvalue: null
        **/
        variableName: string;
        /**
         * value property / option
         * Get and set the property "value".
         * Der Wert von value wird automatisch einer angemeldeten Variablen nachgeführt.
         * In Ihr wird der Einheiten Umgerechnete Wert durch den Variablen Event Handler eingetragen.
         * Zusätzlich wird der option angegebene formatString zur darstellung ausgewertet.
         * Ein aufruf des Setters von value beschreibt NICHT automatisch die VisiWin Variable.
         * Je nach Datentype der Variabe kann sich der Datentype von value ändern.
         * Datatype: any
         * Defaultvalue: null
        **/
        value: any;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * scaleLabelColor property / option
         * Get and set the property "scaleLabelColor".
         * The scaleLabelColor property defines the radial scale label color.
         * Datatype: string
         * Defaultvalue: 'black'
         * Valid values: color | transparent | inherit | initial
        **/
        scaleLabelColor: string;
        /**
         * scaleMajorTicksColor property / option
         * Get and set the property "scaleMajorTicksColor".
         * The scaleMajorTicksColor property defines the radial scale major ticks color.
         * Datatype: string
         * Defaultvalue: 'black'
         * Valid values: color | transparent | inherit | initial
        **/
        scaleMajorTicksColor: string;
        /**
         * scaleMiddleTicksColor property / option
         * Get and set the property "scaleMiddleTicksColor".
         * The scaleMiddleTicksColor property defines the radial scale middle ticks color.
         * Datatype: string
         * Defaultvalue: 'black'
         * Valid values: color | transparent | inherit | initial
        **/
        scaleMiddleTicksColor: string;
        /**
         * scaleMinorTicksColor property / option
         * Get and set the property "scaleMinorTicksColor".
         * The scaleMinorTicksColor property defines the radial scale minor ticks color.
         * Datatype: string
         * Defaultvalue: 'black'
         * Valid values: color | transparent | inherit | initial
        **/
        scaleMinorTicksColor: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class RadialInstrument extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        private properties;
        variableName: string;
        value: number;
        useRawValue: boolean;
        rawLimitMin: number;
        rawLimitMax: number;
        useVariableLimits: boolean;
        limits: any;
        rawReferenceValue: number;
        startAngle: number;
        endAngle: number;
        rangeInnerRadius: string;
        rangeOuterRadius: string;
        showAllRanges: boolean;
        scaleMode: string;
        scalePlacement: string;
        showScaleBaseLine: boolean;
        scaleLimitsVisibility: string;
        scaleRadius: string;
        showMajorTicks: boolean;
        majorStepSize: number;
        majorSteps: number;
        majorTicksLength: number;
        majorTicksWidth: number;
        showMiddleTicks: boolean;
        middleStepSize: number;
        middleSteps: number;
        middleTicksLength: number;
        middleTicksWidth: number;
        showMinorTicks: boolean;
        minorStepSize: number;
        minorSteps: number;
        minorTicksLength: number;
        minorTicksWidth: number;
        showMajorLabels: boolean;
        majorLabelsFontClass: string;
        majorLabelsFontSize: string;
        majorLabelsFontWeight: string;
        majorLabelsLineHeight: string;
        majorLabelsTextContrast: number;
        majorLabelsOffset: number;
        majorLabelsDecimalPlaces: number;
        indicatorUri: string;
        indicatorSize: string;
        backgroundColor: string;
        foregroundColor: string;
        rangeBackgroundColor: string;
        scaleBackgroundColor: string;
        disabledBackgroundColor: string;
        disabledRangeBackgroundColor: string;
        disabledScaleBackgroundColor: string;
        scaleForegroundColor: string;
        majorTicksColor: string;
        middleTicksColor: string;
        minorTicksColor: string;
        disabledForegroundColor: string;
        indicatorBackgroundColor: string;
        disabledIndicatorBackgroundColor: string;
        private _rangeElement;
        private _scaleElement;
        private _indicatorElement;
        private _limitsCollection;
        private _boundLimitsChangedHandler;
        backgroundUri: string;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _limitsChangedHandler(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IRadioButton extends VisiWin.UI.IRadioButtonBase {
        /**
          * constructor: Creates a new RadioButton.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new RadioButton control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadioButton control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadioButton control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadioButton control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadioButton control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadioButton control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadioButton control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadioButton control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new RadioButton control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * fontClass property / option
         * Get and set the fontClass of the control.
         * If set, the corrosponding Css fontclass will be set to the HTML Element.
         * In this Css Class is define the:
         *   font-family, font-size, font-weight, text-transform, line-height, letter-spacing, and opacity
         * Note: if the Application.Settings["HighContrastText"] is true, the opacity will be set always to "1.0"
         * Datatype: enum as string
         * Defaultvalue: null
         * Valid values:
         *      "display 4", "display 3", "display 2", "display 1", "headline", "title", "subheading",
         *      "subheading 2", "body 2", "body 1", "caption", "menu", "button", "button (all caps)", "label", "label1"
        **/
        fontClass: any;
        /**
         * borderWidth property / option
         * Get and set the css style property "borderWidth" of the corrosponding HTML Element.
         * The border-width property sets the width of an element's four borders. This property can have from one to four values.
         * Note: Always declare the border-style property before the border-width property. An element must have borders before you can set the width.
         * Datatype: string
         * Defaultvalue: medium
         * Valid values: medium | thin | thick | length | initial | inherit
        **/
        borderWidth: string;
        /**
         * disabled property / option
         * Get and set the property "disabled".
         * If this property is set, the control will be display greyed, shadowed. Click and touch events will be blocked.
         * Changes for this property will be call the disabledCahnge eventhandler and the notifyPropertyChanged eventhandler.
         * Addition the Css Class disabled will be set when the control has the focus.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        disabled: boolean;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        checked: boolean;
        /**
         * variableName property / option
         * Get and set the property "variableName".
         * Legt die VisiWin Variable Fest die angemeldet werden soll.
         * War zuvor eine Varable angemeldet, so wird diese zuvor detach und abgemeldet.
         * Intern wird ein Event Handler auf Veränderungen der Variable angemeldet.
         * Dadurch werden einige Properties des VariablenMixin automatisch verändert:
         *      value, bitValue
         * Soll die Variable abgemeldet und keine neue angemeldet werden, so muss 'null'
         * als Parameter übergeben werden.
         * Datatype: string
         * Defaultvalue: null
        **/
        variableName: string;
        /**
         * bitNumber property / option
         * Get and set the property "bitNumber".
         * Ist dieser Wert gesetzt, so wird im value nur der direkte Wert aus der Steuerung
         * dargestellt. Die Unitumrechnung und der FormatString wird nicht angewendet.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        bitNumber: number;
        /**
         * useVariableText property / option
         * Get and set the property "useVariableText".
         * Ist dieses Property gesetzt, so wird der Text der Variablen
         * direkt der Varablen entnommen und in der Property text geschrieben.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        useVariableText: boolean;
        /**
         * showText property / option
         * Get and set the property "showText".
         * The property showText shows or hides the Text element.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        showText: boolean;
        /**
         * text property / option
         * Get and set the property "text".
         * Enthält den Text der dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
        **/
        text: string;
        /**
         * locText property / option
         * Get and set the property "locText".
         * Enthält die TextID die dargestellt werden soll.
         * Das Property "text" wird mit der aufgelösten TextID überschrieben.
         * Die TextID ist sprachabhängig und wird über einen internen Eventhandler beim Aufruf der
         * Sprachumschaltung aufgerufen, so das das Property "text" automatisch ersetzt wird.
         * Datatype: string
         * Defaultvalue: null
        **/
        locText: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
         * pressedColor property / option
         * Get and set the Property "pressedColor" of the corrosponding HTML Element.
         * The pressedColor property sets the css style property border-color of an element when the element is pressed.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        pressedColor: string;
        /**
         * checkedColor property / option
         * Get and set the Property "checkedColor" of the corrosponding HTML Element.
         * The checkedColor property sets the css style properties: background-color and border-color of an element when the element is checked.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        checkedColor: string;
        /**
         * disabledColor property / option
         * Get and set the Property "disabledColor" of the corrosponding HTML Element.
         * The disabledColor property sets the css style properties: color and border-color of an element when the element is disabled.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        disabledColor: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class RadioButton extends VisiWin.UI.RadioButtonBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            rippleTarget: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            outerCircleBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            outerCircleBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            outerCircleBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            outerCircleWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            outerCircleHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            outerCircleMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            outerCirclePadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            innerCircleBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            innerCircleBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            innerCircleBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            innerCircleWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            innerCircleHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            innerCircleMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            innerCirclePadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
                cloneProperty: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
                cloneProperty: string;
            };
            labelTextOn: {
                propertyType: string;
                type: string;
                cloneProperty: string;
            };
            localizableLabelTextOn: {
                propertyType: string;
                type: string;
                cloneProperty: string;
            };
            labelTextOff: {
                propertyType: string;
                type: string;
                cloneProperty: string;
            };
            localizableLabelTextOff: {
                propertyType: string;
                type: string;
                cloneProperty: string;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            outerCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverOuterCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedOuterCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedOuterCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverOuterCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedOuterCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledOuterCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledCheckedOuterCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            outerCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverOuterCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedOuterCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedOuterCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverOuterCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedOuterCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledOuterCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledCheckedOuterCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            innerCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInnerCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedInnerCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedInnerCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverInnerCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedInnerCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledInnerCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledCheckedInnerCircleBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            innerCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInnerCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedInnerCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedInnerCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverInnerCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedInnerCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledInnerCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledCheckedInnerCircleBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        outerCircleBorderWidth: string;
        outerCircleBorderStyle: string;
        outerCircleBorderRadius: string;
        outerCircleWidth: string;
        outerCircleHeight: string;
        outerCircleMargin: string;
        outerCirclePadding: string;
        innerCircleBorderWidth: string;
        innerCircleBorderStyle: string;
        innerCircleBorderRadius: string;
        innerCircleWidth: string;
        innerCircleHeight: string;
        innerCircleMargin: string;
        innerCirclePadding: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        backgroundColor: string;
        hoverBackgroundColor: string;
        pressedBackgroundColor: string;
        checkedBackgroundColor: string;
        checkedHoverBackgroundColor: string;
        checkedPressedBackgroundColor: string;
        disabledBackgroundColor: string;
        foregroundColor: string;
        hoverForegroundColor: string;
        pressedForegroundColor: string;
        checkedForegroundColor: string;
        checkedHoverForegroundColor: string;
        checkedPressedForegroundColor: string;
        disabledForegroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        checkedBorderColor: string;
        checkedHoverBorderColor: string;
        disabledBorderColor: string;
        outerCircleBackgroundColor: string;
        hoverOuterCircleBackgroundColor: string;
        pressedOuterCircleBackgroundColor: string;
        checkedOuterCircleBackgroundColor: string;
        checkedHoverOuterCircleBackgroundColor: string;
        checkedPressedOuterCircleBackgroundColor: string;
        disabledOuterCircleBackgroundColor: string;
        disabledCheckedOuterCircleBackgroundColor: string;
        outerCircleBorderColor: string;
        hoverOuterCircleBorderColor: string;
        pressedOuterCircleBorderColor: string;
        checkedOuterCircleBorderColor: string;
        checkedHoverOuterCircleBorderColor: string;
        checkedPressedOuterCircleBorderColor: string;
        disabledOuterCircleBorderColor: string;
        disabledCheckedOuterCircleBorderColor: string;
        innerCircleBackgroundColor: string;
        hoverInnerCircleBackgroundColor: string;
        pressedInnerCircleBackgroundColor: string;
        checkedInnerCircleBackgroundColor: string;
        checkedHoverInnerCircleBackgroundColor: string;
        checkedPressedInnerCircleBackgroundColor: string;
        disabledInnerCircleBackgroundColor: string;
        disabledCheckedInnerCircleBackgroundColor: string;
        innerCircleBorderColor: string;
        hoverInnerCircleBorderColor: string;
        pressedInnerCircleBorderColor: string;
        checkedInnerCircleBorderColor: string;
        checkedHoverInnerCircleBorderColor: string;
        checkedPressedInnerCircleBorderColor: string;
        disabledInnerCircleBorderColor: string;
        disabledCheckedInnerCircleBorderColor: string;
        private _containerElement;
        private _outerCircleElement;
        private _innerCircleElement;
        private _labelElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IGroup extends VisiWin.UI.IControlBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Group extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            orientation: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            wrap: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            showTitle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            titleWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titlePadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableTitleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            titleFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showSubtitle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            subtitleWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitlePadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableSubtitleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            subtitleFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            titleForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            subtitleForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledTitleForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledSubtitleForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        orientation: string;
        alignItems: string;
        justifyContent: string;
        alignContent: string;
        wrap: boolean;
        showTitle: boolean;
        titleWidth: string;
        titleHeight: string;
        titleMargin: string;
        titlePadding: string;
        titleText: string;
        localizableTitleText: string;
        titleTextAlignment: string;
        titleLineClamp: number;
        titleTextWrapping: string;
        titleTextTrimming: string;
        titleFontClass: string;
        titleFontSize: string;
        titleFontWeight: string;
        titleLineHeight: string;
        titleTextContrast: number;
        titleUppercase: boolean;
        showSubtitle: boolean;
        subtitleWidth: string;
        subtitleHeight: string;
        subtitleMargin: string;
        subtitlePadding: string;
        subtitleText: string;
        localizableSubtitleText: string;
        subtitleTextAlignment: string;
        subtitleLineClamp: number;
        subtitleTextWrapping: string;
        subtitleTextTrimming: string;
        subtitleFontClass: string;
        subtitleFontSize: string;
        subtitleFontWeight: string;
        subtitleLineHeight: string;
        subtitleTextContrast: number;
        subtitleUppercase: boolean;
        backgroundColor: string;
        borderColor: string;
        titleForegroundColor: string;
        subtitleForegroundColor: string;
        disabledBackgroundColor: string;
        disabledBorderColor: string;
        disabledTitleForegroundColor: string;
        disabledSubtitleForegroundColor: string;
        private _containerElement;
        private _titleElement;
        private _subtitleElement;
        constructor(element: any, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ISlider extends VisiWin.UI.IControlBase {
        /**
          * constructor: Creates a new Slider.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new Slider control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Slider control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Slider control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Slider control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Slider control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Slider control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Slider control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Slider control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Slider control.
        **/
        ready(element: HTMLElement, options: any): void;
        minValue: number;
        maxValue: number;
        step: number;
        directWrite: boolean;
        /**
         * disabled property / option
         * Get and set the property "disabled".
         * If this property is set, the control will be display greyed, shadowed. Click and touch events will be blocked.
         * Changes for this property will be call the disabledCahnge eventhandler and the notifyPropertyChanged eventhandler.
         * Addition the Css Class disabled will be set when the control has the focus.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        disabled: boolean;
        subType: string;
        /**
         * variableName property / option
         * Get and set the property "variableName".
         * Legt die VisiWin Variable Fest die angemeldet werden soll.
         * War zuvor eine Varable angemeldet, so wird diese zuvor detach und abgemeldet.
         * Intern wird ein Event Handler auf Veränderungen der Variable angemeldet.
         * Dadurch werden einige Properties des VariablenMixin automatisch verändert:
         *      value, bitValue
         * Soll die Variable abgemeldet und keine neue angemeldet werden, so muss 'null'
         * als Parameter übergeben werden.
         * Datatype: string
         * Defaultvalue: null
        **/
        variableName: string;
        /**
         * value property / option
         * Get and set the property "value".
         * Der Wert von value wird automatisch einer angemeldeten Variablen nachgeführt.
         * In Ihr wird der Einheiten Umgerechnete Wert durch den Variablen Event Handler eingetragen.
         * Zusätzlich wird der option angegebene formatString zur darstellung ausgewertet.
         * Ein aufruf des Setters von value beschreibt NICHT automatisch die VisiWin Variable.
         * Je nach Datentype der Variabe kann sich der Datentype von value ändern.
         * Datatype: any
         * Defaultvalue: null
        **/
        value: any;
        formatString: string;
        locFormatString: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * id property / option
         * Gets the id of the control.
         * The controlID is the HTML id from the corrosponding HTML Element.
         * Datatype: string as enum
         * Defaultvalue: null
        **/
        id: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Slider extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            thumbPositionChanged: {
                propertyType: string;
                group: string;
            };
            pressed: {
                propertyType: string;
                type: string;
                child: string;
            };
            variableName: {
                propertyType: string;
                type: string;
                child: string;
            };
            decimalPlaces: {
                propertyType: string;
                type: string;
                child: string;
            };
            useRawValue: {
                propertyType: string;
                type: string;
                child: string;
            };
            rawLimitMin: {
                propertyType: string;
                type: string;
                child: string;
            };
            rawLimitMax: {
                propertyType: string;
                type: string;
                child: string;
            };
            useVariableLimits: {
                propertyType: string;
                type: string;
                child: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            step: {
                propertyType: string;
                type: string;
                child: string;
            };
            immediate: {
                propertyType: string;
                type: string;
                child: string;
            };
            orientation: {
                propertyType: string;
                type: string;
                child: string;
            };
            orientationReversed: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackThickness: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            trackBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
            };
            sliderContainerWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            sliderContainerHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            sliderContainerMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            sliderContainerPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            minValue: {
                propertyType: string;
                type: string;
                child: string;
            };
            maxValue: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbPadding: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbShadow: {
                propertyType: string;
                type: string;
            };
            minMaxLabelThickness: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            minMaxLabelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            minMaxLabelAlignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            minMaxLabelJustifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showMinLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            minLabelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            minLabelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            minLabelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showMaxLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            maxLabelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            maxLabelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            maxLabelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showValueLabel: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            valueLabelBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueLabelBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueLabelBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            valueLabelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueLabelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueLabelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueLabelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueLabelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showValue: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: boolean;
            };
            valueWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            valuePadding: {
                propertyType: string;
                type: string;
                child: string;
            };
            value: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            valueLineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueFontClass: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            valueFontSize: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            valueFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            valueLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            valueTextContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            showUnit: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: boolean;
            };
            unitWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitPadding: {
                propertyType: string;
                type: string;
                child: string;
            };
            useVariableUnitText: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitText: {
                propertyType: string;
                type: string;
                child: string;
            };
            localizableUnitText: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitLineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitFontClass: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitFontSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitFontWeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitLineHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitTextContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitPosition: {
                propertyType: string;
                type: string;
                child: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            valueLabelBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            valueBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            unitBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            valueForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            unitForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            minLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            maxLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            valueLabelBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            activeTrackColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            hoverActiveTrackColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            pressedActiveTrackColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledActiveTrackColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            hoverTrackColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            pressedTrackColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledTrackColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            hoverThumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            pressedThumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledThumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            hoverThumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            pressedThumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledThumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
        };
        pressed: boolean;
        variableName: string;
        decimalPlaces: number;
        useRawValue: boolean;
        rawLimitMin: number;
        rawLimitMax: number;
        useVariableLimits: boolean;
        alignItems: string;
        justifyContent: string;
        step: number;
        immediate: boolean;
        orientation: string;
        orientationReversed: boolean;
        trackThickness: string;
        trackBorderRadius: string;
        sliderContainerWidth: string;
        sliderContainerHeight: string;
        sliderContainerMargin: string;
        sliderContainerPadding: string;
        minValue: number;
        maxValue: number;
        thumbBorderWidth: string;
        thumbBorderStyle: string;
        thumbBorderRadius: string;
        thumbWidth: string;
        thumbHeight: string;
        thumbMargin: string;
        thumbPadding: string;
        thumbShadow: string;
        minMaxLabelThickness: string;
        minMaxLabelPosition: string;
        minMaxLabelAlignItems: string;
        minMaxLabelJustifyContent: string;
        showMinLabel: boolean;
        minLabelWidth: string;
        minLabelHeight: string;
        minLabelMargin: string;
        minLabelPadding: string;
        minLabelTextAlignment: string;
        minLabelLineClamp: number;
        minLabelTextWrapping: string;
        minLabelTextTrimming: string;
        minLabelFontClass: string;
        minLabelFontSize: string;
        minLabelFontWeight: string;
        minLabelLineHeight: string;
        minLabelTextContrast: number;
        showMaxLabel: boolean;
        maxLabelWidth: string;
        maxLabelHeight: string;
        maxLabelMargin: string;
        maxLabelPadding: string;
        maxLabelTextAlignment: string;
        maxLabelLineClamp: number;
        maxLabelTextWrapping: string;
        maxLabelTextTrimming: string;
        maxLabelFontClass: string;
        maxLabelFontSize: string;
        maxLabelFontWeight: string;
        maxLabelLineHeight: string;
        maxLabelTextContrast: number;
        showValueLabel: string;
        valueLabelBorderWidth: string;
        valueLabelBorderStyle: string;
        valueLabelBorderRadius: string;
        valueLabelWidth: string;
        valueLabelHeight: string;
        valueLabelMargin: string;
        valueLabelPadding: string;
        valueLabelPosition: string;
        showValue: boolean;
        valueWidth: string;
        valueHeight: string;
        valueMargin: string;
        valuePadding: string;
        value: number;
        valueTextAlignment: string;
        valueLineClamp: number;
        valueTextWrapping: string;
        valueTextTrimming: string;
        valueFontClass: string;
        valueFontSize: string;
        valueFontWeight: string;
        valueLineHeight: string;
        valueTextContrast: number;
        showUnit: boolean;
        unitWidth: string;
        unitHeight: string;
        unitMargin: string;
        unitPadding: string;
        useVariableUnitText: boolean;
        unitText: string;
        localizableUnitText: string;
        unitTextAlignment: string;
        unitLineClamp: number;
        unitTextWrapping: string;
        unitTextTrimming: string;
        unitFontClass: string;
        unitFontSize: string;
        unitFontWeight: string;
        unitLineHeight: string;
        unitTextContrast: number;
        unitPosition: string;
        backgroundColor: string;
        valueLabelBackgroundColor: string;
        valueBackgroundColor: string;
        unitBackgroundColor: string;
        disabledBackgroundColor: string;
        valueForegroundColor: string;
        unitForegroundColor: string;
        minLabelForegroundColor: string;
        maxLabelForegroundColor: string;
        disabledForegroundColor: string;
        borderColor: string;
        valueLabelBorderColor: string;
        disabledBorderColor: string;
        activeTrackColor: string;
        hoverActiveTrackColor: string;
        pressedActiveTrackColor: string;
        disabledActiveTrackColor: string;
        trackColor: string;
        hoverTrackColor: string;
        pressedTrackColor: string;
        disabledTrackColor: string;
        thumbBackgroundColor: string;
        hoverThumbBackgroundColor: string;
        pressedThumbBackgroundColor: string;
        disabledThumbBackgroundColor: string;
        thumbBorderColor: string;
        hoverThumbBorderColor: string;
        pressedThumbBorderColor: string;
        disabledThumbBorderColor: string;
        _valueLabelElement: any;
        _containerElement: any;
        _minMaxContainerElement: any;
        _minLabelElement: any;
        _minMaxSpacerElement: any;
        _maxLabelElement: any;
        _sliderCoreContainerElement: any;
        _sliderCoreElement: any;
        _minMaxDividerElement: any;
        private _boundThumbPositionChangedHandler;
        observe: any;
        constructor(element: any, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        onLanguageChanged(args: any): void;
        afterInit(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _thumbPositionChangedHandler(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ISwitch {
        /**
          * constructor: Creates a new Switch.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new Switch control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Switch control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Switch control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Switch control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Switch control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Switch control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Switch control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Switch control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Switch control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * fontClass property / option
         * Get and set the fontClass of the control.
         * If set, the corrosponding Css fontclass will be set to the HTML Element.
         * In this Css Class is define the:
         *   font-family, font-size, font-weight, text-transform, line-height, letter-spacing, and opacity
         * Note: if the Application.Settings["HighContrastText"] is true, the opacity will be set always to "1.0"
         * Datatype: enum as string
         * Defaultvalue: null
         * Valid values:
         *      "display 4", "display 3", "display 2", "display 1", "headline", "title", "subheading",
         *      "subheading 2", "body 2", "body 1", "caption", "menu", "button", "button (all caps)", "label", "label1"
        **/
        fontClass: any;
        /**
         * borderWidth property / option
         * Get and set the css style property "borderWidth" of the corrosponding HTML Element.
         * The border-width property sets the width of an element's four borders. This property can have from one to four values.
         * Note: Always declare the border-style property before the border-width property. An element must have borders before you can set the width.
         * Datatype: string
         * Defaultvalue: medium
         * Valid values: medium | thin | thick | length | initial | inherit
        **/
        borderWidth: string;
        /**
         * disabled property / option
         * Get and set the property "disabled".
         * If this property is set, the control will be display greyed, shadowed. Click and touch events will be blocked.
         * Changes for this property will be call the disabledCahnge eventhandler and the notifyPropertyChanged eventhandler.
         * Addition the Css Class disabled will be set when the control has the focus.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        disabled: boolean;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        checked: boolean;
        /**
         * variableName property / option
         * Get and set the property "variableName".
         * Legt die VisiWin Variable Fest die angemeldet werden soll.
         * War zuvor eine Varable angemeldet, so wird diese zuvor detach und abgemeldet.
         * Intern wird ein Event Handler auf Veränderungen der Variable angemeldet.
         * Dadurch werden einige Properties des VariablenMixin automatisch verändert:
         *      value, bitValue
         * Soll die Variable abgemeldet und keine neue angemeldet werden, so muss 'null'
         * als Parameter übergeben werden.
         * Datatype: string
         * Defaultvalue: null
        **/
        variableName: string;
        /**
         * bitNumber property / option
         * Get and set the property "bitNumber".
         * Ist dieser Wert gesetzt, so wird im value nur der direkte Wert aus der Steuerung
         * dargestellt. Die Unitumrechnung und der FormatString wird nicht angewendet.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        bitNumber: number;
        labelText: string;
        locLabelText: string;
        labelAlignment: string;
        /**
         * useVariableText property / option
         * Get and set the property "useVariableText".
         * Ist dieses Property gesetzt, so wird der Text der Variablen
         * direkt der Varablen entnommen und in der Property text geschrieben.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        useVariableText: boolean;
        /**
         * textOn property / option
         * Get and set the property "textOn".
         * Darzustellender Text im Button wenn dieser checked ist / aktive ist.
         * Bei dem Wert null wird kein Tekst dargestellt.
         * Datatype: string
         * Defaultvalue: null
        **/
        textOn: string;
        /**
         * locTextOn property / option
         * Get and set the property "locTextOn".
         * Darzustellender lokalisierter Text für den onText. Der Text wird über eine TextID ausgewählt. Diese muss als Server- oder ClientText hinterlegt sein.
         * Ist eine gültige Text ID eingetragen, so wird mit dem ermitteltelten lokalisierten Text das Property "text" überschrieben.
         * Intern im Control wird ein Handler angelegt der das property "text" erneut überschreibt wenn sich der lokalisierte Text ändert.
         * Bei dem Wert null wird kein Tekst dargestellt.
         * Datatype: string
         * Defaultvalue: null
        **/
        locTextOn: string;
        /**
         * textOff property / option
         * Get and set the property "textOff".
         * Darzustellender Text im Button wenn dieser checked ist / aktive ist.
         * Bei dem Wert null wird kein Tekst dargestellt.
         * Datatype: string
         * Defaultvalue: null
        **/
        textOff: string;
        /**
         * locTextOff property / option
         * Darzustellender lokalisierter Text für den offText. Der Text wird über eine TextID ausgewählt. Diese muss als Server- oder ClientText hinterlegt sein.
         * Ist eine gültige Text ID eingetragen, so wird mit dem ermitteltelten lokalisierten Text das Property "text" überschrieben.
         * Intern im Control wird ein Handler angelegt der das property "text" erneut überschreibt wenn sich der lokalisierte Text ändert.
         * Bei dem Wert null wird kein Tekst dargestellt.
         * Datatype: string
         * Defaultvalue: null
        **/
        locTextOff: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
         * hoverColor property / option
         * Get and set the Property "hoverColor" of the corrosponding HTML Element.
         * The hoverColor property sets the css style properties: background-color and color of an element when the pointer hovers over element.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        hoverColor: string;
        /**
         * pressedColor property / option
         * Get and set the Property "pressedColor" of the corrosponding HTML Element.
         * The pressedColor property sets the css style property background-color of an element when the element is pressed.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        pressedColor: string;
        /**
         * checkedColor property / option
         * Get and set the Property "checkedColor" of the corrosponding HTML Element.
         * The checkedColor property sets the css style properties: background-color and border-color of an element when the element is checked.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        checkedColor: string;
        /**
         * disabledColor property / option
         * Get and set the Property "disabledColor" of the corrosponding HTML Element.
         * The disabledColor property sets the css style properties: background-color, border-color and color of an element when the element is disabled.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        disabledColor: string;
        disabledTrackColor: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Switch extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            pressedChanged: {
                propertyType: string;
                group: string;
                triggerDataName: string;
            };
            draggingChanged: {
                propertyType: string;
                group: string;
                triggerDataName: string;
            };
            checkedChanged: {
                propertyType: string;
                group: string;
                triggerDataName: string;
            };
            pressed: {
                propertyType: string;
                type: string;
                child: string;
            };
            dragging: {
                propertyType: string;
                type: string;
                child: string;
            };
            checked: {
                propertyType: string;
                type: string;
                child: string;
            };
            variableName: {
                propertyType: string;
                type: string;
                child: string;
            };
            value: {
                propertyType: string;
                type: string;
                child: string;
            };
            bitNumber: {
                propertyType: string;
                type: string;
                child: string;
            };
            canRecipeEdit: {
                propertyType: string;
                type: string;
                child: string;
            };
            touchRippleEnabled: {
                propertyType: string;
                type: string;
                child: string;
            };
            rippleElement: {
                propertyType: string;
                type: string;
                child: string;
            };
            rippleTarget: {
                propertyType: string;
                type: string;
                child: string;
            };
            rippleTargetAsParent: {
                propertyType: string;
                type: string;
                child: string;
            };
            rippleRadius: {
                propertyType: string;
                type: string;
                child: string;
            };
            rippleSpeedAmount: {
                propertyType: string;
                type: string;
                child: string;
            };
            rippleCentered: {
                propertyType: string;
                type: string;
                child: string;
            };
            rippleUnbounded: {
                propertyType: string;
                type: string;
                child: string;
            };
            ripplePersistent: {
                propertyType: string;
                type: string;
                child: string;
            };
            rippleFadeInDuration: {
                propertyType: string;
                type: string;
                child: string;
            };
            rippleFadeOutDuration: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackPadding: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackTransition: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackShadow: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbPadding: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTransition: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbShadow: {
                propertyType: string;
                type: string;
                child: string;
            };
            showThumbText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: boolean;
            };
            thumbTextWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextPadding: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbText: {
                propertyType: string;
                type: string;
                child: string;
            };
            localizableThumbText: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextOn: {
                propertyType: string;
                type: string;
                child: string;
            };
            localizableThumbTextOn: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextOff: {
                propertyType: string;
                type: string;
                child: string;
            };
            localizableThumbTextOff: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            textWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textOnOff: {
                propertyType: string;
                type: string;
                child: string;
            };
            localizableTextOnOff: {
                propertyType: string;
                type: string;
                child: string;
            };
            textOn: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableTextOn: {
                propertyType: string;
                type: string;
                child: string;
            };
            textOff: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            localizableTextOff: {
                propertyType: string;
                type: string;
                child: string;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            lineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            textWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            textTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontClass: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontWeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            lineHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            textContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            uppercase: {
                propertyType: string;
                type: string;
                child: string;
            };
            textPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            textForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            thumbTextForegroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            hoverThumbTextForegroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            pressedThumbTextForegroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedThumbTextForegroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedHoverThumbTextForegroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedPressedThumbTextForegroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            rippleColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            hoverTrackBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            pressedTrackBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedTrackBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedHoverTrackBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedPressedTrackBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledTrackBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledCheckedTrackBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            trackBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            hoverTrackBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            pressedTrackBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedTrackBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedHoverTrackBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedPressedTrackBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledTrackBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledCheckedTrackBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            hoverThumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            pressedThumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedThumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedHoverThumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedPressedThumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledThumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledCheckedThumbBackgroundColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            thumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            hoverThumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            pressedThumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedThumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedHoverThumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            checkedPressedThumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledThumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
            disabledCheckedThumbBorderColor: {
                propertyType: string;
                type: string;
                child: string;
            };
        };
        pressed: boolean;
        dragging: boolean;
        checked: boolean;
        variableName: string;
        value: number;
        bitNumber: number;
        touchRippleEnabled: boolean;
        rippleElement: string;
        rippleTarget: string;
        rippleTargetAsParent: boolean;
        rippleRadius: number;
        rippleSpeedAmount: number;
        rippleCentered: boolean;
        rippleUnbounded: boolean;
        ripplePersistent: boolean;
        rippleFadeInDuration: number;
        rippleFadeOutDuration: number;
        trackBorderWidth: string;
        trackBorderStyle: string;
        trackBorderRadius: string;
        trackWidth: string;
        trackHeight: string;
        trackMargin: string;
        trackPadding: string;
        trackTransition: string;
        trackShadow: string;
        thumbBorderWidth: string;
        thumbBorderStyle: string;
        thumbBorderRadius: string;
        thumbWidth: string;
        thumbHeight: string;
        thumbMargin: string;
        thumbPadding: string;
        thumbTransition: string;
        thumbShadow: string;
        showThumbText: boolean;
        thumbTextWidth: string;
        thumbTextHeight: string;
        thumbTextMargin: string;
        thumbTextPadding: string;
        thumbText: string;
        localizableThumbText: string;
        thumbTextOn: string;
        localizableThumbTextOn: string;
        thumbTextOff: string;
        localizableThumbTextOff: string;
        thumbTextAlignment: string;
        thumbTextLineClamp: number;
        thumbTextWrapping: string;
        thumbTextTrimming: string;
        thumbTextFontClass: string;
        thumbTextFontSize: string;
        thumbTextFontWeight: string;
        thumbTextLineHeight: string;
        thumbTextContrast: number;
        thumbTextUppercase: boolean;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        useVariableText: boolean;
        labelText: string;
        localizableLabelText: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        showText: boolean;
        textWidth: string;
        textHeight: string;
        textMargin: string;
        textPadding: string;
        text: string;
        localizableText: string;
        textOn: string;
        localizableTextOn: string;
        textOff: string;
        localizableTextOff: string;
        textAlignment: string;
        lineClamp: number;
        textWrapping: string;
        textTrimming: string;
        fontClass: string;
        fontSize: string;
        fontWeight: string;
        lineHeight: string;
        textContrast: number;
        uppercase: boolean;
        textPosition: string;
        backgroundColor: string;
        hoverBackgroundColor: string;
        pressedBackgroundColor: string;
        checkedBackgroundColor: string;
        checkedHoverBackgroundColor: string;
        checkedPressedBackgroundColor: string;
        disabledBackgroundColor: string;
        labelForegroundColor: string;
        hoverLabelForegroundColor: string;
        pressedLabelForegroundColor: string;
        checkedLabelForegroundColor: string;
        checkedHoverLabelForegroundColor: string;
        checkedPressedLabelForegroundColor: string;
        textForegroundColor: string;
        pressedTextForegroundColor: string;
        checkedTextForegroundColor: string;
        checkedPressedTextForegroundColor: string;
        thumbTextForegroundColor: string;
        pressedThumbTextForegroundColor: string;
        checkedThumbTextForegroundColor: string;
        checkedHoverThumbTextForegroundColor: string;
        checkedPressedThumbTextForegroundColor: string;
        disabledForegroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        checkedBorderColor: string;
        checkedHoverBorderColor: string;
        disabledBorderColor: string;
        trackBackgroundColor: string;
        hoverTrackBackgroundColor: string;
        pressedTrackBackgroundColor: string;
        checkedTrackBackgroundColor: string;
        checkedHoverTrackBackgroundColor: string;
        checkedPressedTrackBackgroundColor: string;
        disabledTrackBackgroundColor: string;
        disabledCheckedTrackBackgroundColor: string;
        trackBorderColor: string;
        hoverTrackBorderColor: string;
        pressedTrackBorderColor: string;
        checkedTrackBorderColor: string;
        checkedHoverTrackBorderColor: string;
        checkedPressedTrackBorderColor: string;
        disabledTrackBorderColor: string;
        disabledCheckedTrackBorderColor: string;
        thumbBackgroundColor: string;
        hoverThumbBackgroundColor: string;
        pressedThumbBackgroundColor: string;
        checkedThumbBackgroundColor: string;
        checkedHoverThumbBackgroundColor: string;
        checkedPressedThumbBackgroundColor: string;
        disabledThumbBackgroundColor: string;
        disabledCheckedThumbBackgroundColor: string;
        thumbBorderColor: string;
        hoverThumbBorderColor: string;
        pressedThumbBorderColor: string;
        checkedThumbBorderColor: string;
        checkedHoverThumbBorderColor: string;
        checkedPressedThumbBorderColor: string;
        disabledThumbBorderColor: string;
        disabledCheckedThumbBorderColor: string;
        private _containerElement;
        private _switchCoreElement;
        private _labelTextContainerElement;
        private _labelElement;
        private _textElement;
        observe: any;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        afterInit(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ITabButton extends ITabButtonBase {
        /**
          * constructor: Creates a new TabButton.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new TabButton control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new TabButton control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new TabButton control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new TabButton control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new TabButton control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new TabButton control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new TabButton control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new TabButton control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new TabButton control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * fontClass property / option
         * Get and set the fontClass of the control.
         * If set, the corrosponding Css fontclass will be set to the HTML Element.
         * In this Css Class is define the:
         *   font-family, font-size, font-weight, text-transform, line-height, letter-spacing, and opacity
         * Note: if the Application.Settings["HighContrastText"] is true, the opacity will be set always to "1.0"
         * Datatype: enum as string
         * Defaultvalue: null
         * Valid values:
         *      "display 4", "display 3", "display 2", "display 1", "headline", "title", "subheading",
         *      "subheading 2", "body 2", "body 1", "caption", "menu", "button", "button (all caps)", "label", "label1"
        **/
        fontClass: any;
        /**
         * borderWidth property / option
         * Get and set the css style property "borderWidth" of the corrosponding HTML Element.
         * The border-width property sets the width of an element's four borders. This property can have from one to four values.
         * Note: Always declare the border-style property before the border-width property. An element must have borders before you can set the width.
         * Datatype: string
         * Defaultvalue: medium
         * Valid values: medium | thin | thick | length | initial | inherit
        **/
        borderWidth: string;
        /**
         * disabled property / option
         * Get and set the property "disabled".
         * If this property is set, the control will be display greyed, shadowed. Click and touch events will be blocked.
         * Changes for this property will be call the disabledCahnge eventhandler and the notifyPropertyChanged eventhandler.
         * Addition the Css Class disabled will be set when the control has the focus.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        disabled: boolean;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        checked: boolean;
        /**
         * pageName property / option
         * Get and set the property "pageName".
         * Soll in der main action eine Navigation ausgeführt werden so muß in pageName das Ziel angegeben werden
         * mit regionId und target Propertie kann die Navigation beeinflusst werden.
         * Ist der wert null oder undefined so nicht navigiert.
         * Datatype: string
         * Defaultvalue: null
        **/
        pageName: string;
        /**
         * pageOptions property / option
         * Get and set the property "pageOptions".
         * Diess Object wird dem pageControls als option mitgegeben wenn zu einer neuen Seite navigiert wird.
         * So kann abhängig von den pageOptions die neue Seite beeinflusst werden.
         * Datatype: object
         * Defaultvalue: {}, leeres Object
        **/
        pageOptions: any;
        /**
         * regionId property / option
         * Get and set the property "regionId".
         * Ist das property regionId gesetzt, so wird anstatt der default Navigation mit Navigator.navigate
         * das uri Property des angegebenen Controls gesetzt
         * Datatype: object
         * Defaultvalue: {}, leeres Object
        **/
        regionId: string;
        /**
         * showText property / option
         * Get and set the property "showText".
         * The property showText shows or hides the Text element.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        showText: boolean;
        /**
         * text property / option
         * Get and set the property "text".
         * Enthält den Text der dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
        **/
        text: string;
        /**
         * locText property / option
         * Get and set the property "locText".
         * Enthält die TextID die dargestellt werden soll.
         * Das Property "text" wird mit der aufgelösten TextID überschrieben.
         * Die TextID ist sprachabhängig und wird über einen internen Eventhandler beim Aufruf der
         * Sprachumschaltung aufgerufen, so das das Property "text" automatisch ersetzt wird.
         * Datatype: string
         * Defaultvalue: null
        **/
        locText: string;
        /**
         * textAlignment property / option
         * Get and set the property "textAlignment".
         * Mit diesem Property kann die Ausrichtung des Textes angepasst werden.
         * Zur Verfügung stehen:
         *     left     Der Text wird linksbündig, vertikal mittig ausgegeben
         *     center   Der Text wird horizontal und vertikal mittig ausgegeben
         *     right    Der Text wird rechtsbündig, vertikal mittig ausgegeben
         *     top      Der Text wird am oberen Rand, horizontal mittig ausgegeben
         *     bottom   Der Text wird am unteren Rand, horizontal mittig ausgebenen
         * Datatype: enum als string
         * Defaultvalue: "center"
         * Valid values: "left", "center" "right", "top", "bottom"
        **/
        textAlignment: string;
        /**
         * textMargin property / option
         * Get and set the property "textMargin".
         * The property textMargin sets the margin just from one side of an Text element.
         * Note: From which side is margin selected, depends on the property "textAlignment".
         *       e.g. textAlignment:'left',   Text element has css "margin-left" property,
         *            textAlignment:'top',    Text element has css "margin-top" property,
         *            textAlignment:'right',  Text element has css "margin-right" property,
         *            textAlignment:'bottom', Text element has css "margin-bottom" property,
         *            textAlignment:'center'  Text element is always centred.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: auto | length | % | inherit
        **/
        textMargin: string;
        /**
         * lineClamp property / option
         * Get and set the property "lineClamp".
         * Der gesetzte Wert gibt an wie viele Zeilen der angegebene Text maximal einnehmen kann.
         * Der Wert ist nur relevant wenn das Property lineBreak gesetzt ist.
         * Datatype: number
         * Defaultvalue: null
         * Valid values: positive number
        **/
        lineClamp: number;
        /**
         * lineBreak property / option
         * Get and set the property "lineBreak".
         * Ist dieser boolean Wert gesetzt so wird der angegebene Text in weiteren Zeilen umgebrochen
         * sofern er nicht in einer Zeile dargestellt werden kann.
         * Datatype: boolean
         * Defaultvalue: false
         * Valid values: true | false
        **/
        lineBreak: boolean;
        /**
         * showSymbol property / option
         * Get and set the property "showSymbol".
         * The property showSymbol shows or hides the Symbol element.
         * Datatype: boolean
         * Defaultvalue: false
         * Valid values: true | false
        **/
        showSymbol: boolean;
        /**
         * iconFont property / option
         * Get and set the property "iconFont".
         * Wird verwendet wenn der iconType == "icon" ist.
         * Zeilt an als welcher Fontklasse das Icon verwendet wird.
         * Datatype: string
         * Defaultvalue: "material-icons"
         * Valid values: In der VisiWin Lib: "material-icons" und "winjs-icons"
        **/
        iconFont: string;
        /**
         * symbol property / option
         * Get and set the property "symbol".
         * Legt des Quelle des Symbols fest, bei
         *  "icon"        : der Name des Icons im Font.
         *  "image", "svg": der Name der Datei die dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: Iconname aus Font oder Path auf eine gültuge Image oder Svg Datei
        **/
        symbol: string;
        /**
         * symbolType property / option
         * Get and set the property "symbolType".
         * Es gibt drei gültige Werte:
         *  "icon" : Ein Zeichen aus einem Iconfont dargestellt. Es wird ein <I> Tag verwebdet.
         *  "image": Eine Bitmap Grafig in dem Format "PNG" oder "JPG" wird ausgegeben. Es wird ein "IMG" Tag verwendet.
         *  "svg"  : Eine SVF Grafig wird ausgegeben. Es wird ein <IMG> Tag verwendet.
         * Datatype: string
         * Defaultvalue: "icon"
         * Valid values: "icon", "image", svg"
        **/
        symbolType: string;
        /**
         * symbolAlignment property / option
         * Get and set the property "symbolAlignment".
         * The property symbolAlignment align Symbol element within Container element. There are five valid values:
         *   "top"    : Aligns the symbol element to the top.
         *   "right"  : Aligns the symbol element to the right.
         *   "bottom" : Aligns the symbol element to the bottom.
         *   "left"   : Aligns the symbol element to the left.
         *   "center" : Aligns the symbol element center.
         * Datatype: string
         * Defaultvalue: "left"
         * Valid values: "top", "right", "bottom", "left", "center"
        **/
        symbolAlignment: string;
        /**
         * symbolSize property / option
         * Get and set the property "symbolSize".
         * Größe des dargestellten Symbols.
         * Dieses Property muss immer in Zusammenhang mit den den Style Propertys "with" und "height" gesehen werden.
         * Der Wert auto besagt, die größe wird über die "width" und "height" Properties festgelegt.
         * Ist ein Wert angegeben, so wird damit die Breite und Höhe des Symbols angegeben. Sind die "width" und height"
         * Properties nicht auf "auto" eingestellt, sie wird hierdurch die größe des umgebenden Containers eingestellt,
         * andernfalls wird der Container an die größe des Symbols angepasst.
         * Datatype: string
         * Defaultvalue: "auto" -  symbolType="image" and symbolType="svg"
         *               "24px" -  symbolType="icon"
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        symbolSize: string;
        /**
         * symbolMargin property / option
         * Get and set the property "symbolMargin".
         * The property symbolMargin sets the margin just from one side of an Symbol element.
         * Note: From which side is margin selected, depends on the property "symbolAlignment".
         *       e.g. If symbolAlignment:'left',  Symbol element has css "margin-left" property,
         *            If symbolAlignment:'top', Symbol element has css "margin-top" property ...
         * Datatype: string
         * Defaultvalue: null
         * Valid values: auto | length | % | inherit
        **/
        symbolMargin: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
         * hoverBackgroundColor property / option
         * Get and set the Property "hoverBackgroundColor" of the corrosponding HTML Element.
         * The hoverBackgroundColor property sets the css style property background-color of an element when the pointer hovers over element.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        hoverBackgroundColor: string;
        /**
         * hoverBorderColor property / option
         * Get and set the Property "hoverBorderColor" of the corrosponding HTML Element.
         * The hoverBorderColor property sets the css style property border-color of an element when the pointer hovers over element.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        hoverBorderColor: string;
        /**
         * pressedColor property / option
         * Get and set the Property "pressedColor" of the corrosponding HTML Element.
         * The pressedColor property sets the css style property background-color of an element when the element is pressed.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        pressedColor: string;
        /**
         * checkedColor property / option
         * Get and set the Property "checkedColor" of the corrosponding HTML Element.
         * The checkedColor property sets the css style properties: background-color and border-color of an element when the element is checked.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        checkedColor: string;
        /**
         * disabledBackgroundColor property / option
         * Get and set the Property "disabledBackgroundColor" of the corrosponding HTML Element.
         * The disabledBackgroundColor property sets the css style property background-color of an element when the element is disabled.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        disabledBackgroundColor: string;
        /**
         * disabledForegroundColor property / option
         * Get and set the Property "disabledForegroundColor" of the corrosponding HTML Element.
         * The disabledForegroundColor property sets the css style property color of an element when the element is disabled.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        disabledForegroundColor: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class TabButton extends VisiWin.UI.TabButtonBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            padding: {
                propertyType: string;
                type: string;
                element: string;
                forceOverwrite: boolean;
            };
            transition: {
                propertyType: string;
                type: string;
            };
            containerBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerTransition: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolOn: {
                propertyType: string;
                type: string;
            };
            symbolOff: {
                propertyType: string;
                type: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            textWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
            };
            text: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            localizableText: {
                propertyType: string;
                type: string;
            };
            textOn: {
                propertyType: string;
                type: string;
            };
            localizableTextOn: {
                propertyType: string;
                type: string;
            };
            textOff: {
                propertyType: string;
                type: string;
            };
            localizableTextOff: {
                propertyType: string;
                type: string;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            lineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            textWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            textTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontClass: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                defaultValue: string;
            };
            fontSize: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            fontWeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            lineHeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            textContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            uppercase: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: boolean;
            };
            textPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        padding: string;
        transition: string;
        containerBorderWidth: string;
        containerBorderStyle: string;
        containerBorderRadius: string;
        containerTransition: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolOn: string;
        symbolOff: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        showText: boolean;
        textWidth: string;
        textHeight: string;
        textMargin: string;
        textPadding: string;
        textAlignment: string;
        lineClamp: number;
        textWrapping: string;
        textTrimming: string;
        fontSize: string;
        lineHeight: string;
        textContrast: number;
        uppercase: boolean;
        textPosition: string;
        backgroundColor: string;
        hoverBackgroundColor: string;
        pressedBackgroundColor: string;
        checkedBackgroundColor: string;
        checkedHoverBackgroundColor: string;
        checkedPressedBackgroundColor: string;
        disabledBackgroundColor: string;
        foregroundColor: string;
        hoverForegroundColor: string;
        pressedForegroundColor: string;
        checkedForegroundColor: string;
        checkedHoverForegroundColor: string;
        checkedPressedForegroundColor: string;
        disabledForegroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        checkedBorderColor: string;
        checkedHoverBorderColor: string;
        disabledBorderColor: string;
        private _containerElement;
        private _contentElement;
        private _symbolElement;
        private _textElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IToggleButton extends VisiWin.UI.IToggleButtonBase {
        /**
          * constructor: Creates a new ToggleButton.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new ToggleButton control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new ToggleButton control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new ToggleButton control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new ToggleButton control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new ToggleButton control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new ToggleButton control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new ToggleButton control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new ToggleButton control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new ToggleButton control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * fontClass property / option
         * Get and set the fontClass of the control.
         * If set, the corrosponding Css fontclass will be set to the HTML Element.
         * In this Css Class is define the:
         *   font-family, font-size, font-weight, text-transform, line-height, letter-spacing, and opacity
         * Note: if the Application.Settings["HighContrastText"] is true, the opacity will be set always to "1.0"
         * Datatype: enum as string
         * Defaultvalue: null
         * Valid values:
         *      "display 4", "display 3", "display 2", "display 1", "headline", "title", "subheading",
         *      "subheading 2", "body 2", "body 1", "caption", "menu", "button", "button (all caps)", "label", "label1"
        **/
        fontClass: any;
        /**
         * borderWidth property / option
         * Get and set the css style property "borderWidth" of the corrosponding HTML Element.
         * The border-width property sets the width of an element's four borders. This property can have from one to four values.
         * Note: Always declare the border-style property before the border-width property. An element must have borders before you can set the width.
         * Datatype: string
         * Defaultvalue: medium
         * Valid values: medium | thin | thick | length | initial | inherit
        **/
        borderWidth: string;
        /**
         * disabled property / option
         * Get and set the property "disabled".
         * If this property is set, the control will be display greyed, shadowed. Click and touch events will be blocked.
         * Changes for this property will be call the disabledCahnge eventhandler and the notifyPropertyChanged eventhandler.
         * Addition the Css Class disabled will be set when the control has the focus.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        disabled: boolean;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * checked property / option
         * Gets or set the "checked" property.
         * If the control a toggleButton, checked shows if the button activ / on.
         * A css class "checked" will be set to the control element when if it set.
         * The event "checkedCahnge" will be trigger when the value of checked will change.
         * The event "notifyPropertyChanged" will also triggert.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        checked: boolean;
        /**
         * variableName property / option
         * Get and set the property "variableName".
         * Legt die VisiWin Variable Fest die angemeldet werden soll.
         * War zuvor eine Varable angemeldet, so wird diese zuvor detach und abgemeldet.
         * Intern wird ein Event Handler auf Veränderungen der Variable angemeldet.
         * Dadurch werden einige Properties des VariablenMixin automatisch verändert:
         *      value, bitValue
         * Soll die Variable abgemeldet und keine neue angemeldet werden, so muss 'null'
         * als Parameter übergeben werden.
         * Datatype: string
         * Defaultvalue: null
        **/
        variableName: string;
        /**
         * bitNumber property / option
         * Get and set the property "bitNumber".
         * Ist dieser Wert gesetzt, so wird im value nur der direkte Wert aus der Steuerung
         * dargestellt. Die Unitumrechnung und der FormatString wird nicht angewendet.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        bitNumber: number;
        /**
         * useVariableText property / option
         * Get and set the property "useVariableText".
         * Ist dieses Property gesetzt, so wird der Text der Variablen
         * direkt der Varablen entnommen und in der Property text geschrieben.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        useVariableText: boolean;
        /**
         * showText property / option
         * Get and set the property "showText".
         * The property showText shows or hides the Text element.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        showText: boolean;
        /**
         * text property / option
         * Get and set the property "text".
         * Enthält den Text der dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
        **/
        text: string;
        /**
         * locText property / option
         * Get and set the property "locText".
         * Enthält die TextID die dargestellt werden soll.
         * Das Property "text" wird mit der aufgelösten TextID überschrieben.
         * Die TextID ist sprachabhängig und wird über einen internen Eventhandler beim Aufruf der
         * Sprachumschaltung aufgerufen, so das das Property "text" automatisch ersetzt wird.
         * Datatype: string
         * Defaultvalue: null
        **/
        locText: string;
        /**
         * textAlignment property / option
         * Get and set the property "textAlignment".
         * Mit diesem Property kann die Ausrichtung des Textes angepasst werden.
         * Zur Verfügung stehen:
         *     left     Der Text wird linksbündig, vertikal mittig ausgegeben
         *     center   Der Text wird horizontal und vertikal mittig ausgegeben
         *     right    Der Text wird rechtsbündig, vertikal mittig ausgegeben
         *     top      Der Text wird am oberen Rand, horizontal mittig ausgegeben
         *     bottom   Der Text wird am unteren Rand, horizontal mittig ausgebenen
         * Datatype: enum als string
         * Defaultvalue: "center"
         * Valid values: "left", "center" "right", "top", "bottom"
        **/
        textAlignment: string;
        /**
         * textMargin property / option
         * Get and set the property "textMargin".
         * The property textMargin sets the margin just from one side of an Text element.
         * Note: From which side is margin selected, depends on the property "textAlignment".
         *       e.g. textAlignment:'left',   Text element has css "margin-left" property,
         *            textAlignment:'top',    Text element has css "margin-top" property,
         *            textAlignment:'right',  Text element has css "margin-right" property,
         *            textAlignment:'bottom', Text element has css "margin-bottom" property,
         *            textAlignment:'center'  Text element is always centred.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: auto | length | % | inherit
        **/
        textMargin: string;
        /**
         * lineClamp property / option
         * Get and set the property "lineClamp".
         * Der gesetzte Wert gibt an wie viele Zeilen der angegebene Text maximal einnehmen kann.
         * Der Wert ist nur relevant wenn das Property lineBreak gesetzt ist.
         * Datatype: number
         * Defaultvalue: null
         * Valid values: positive number
        **/
        lineClamp: number;
        /**
         * lineBreak property / option
         * Get and set the property "lineBreak".
         * Ist dieser boolean Wert gesetzt so wird der angegebene Text in weiteren Zeilen umgebrochen
         * sofern er nicht in einer Zeile dargestellt werden kann.
         * Datatype: boolean
         * Defaultvalue: false
         * Valid values: true | false
        **/
        lineBreak: boolean;
        /**
         * showSymbol property / option
         * Get and set the property "showSymbol".
         * The property showSymbol shows or hides the Symbol element.
         * Datatype: boolean
         * Defaultvalue: false
         * Valid values: true | false
        **/
        showSymbol: boolean;
        /**
         * iconFont property / option
         * Get and set the property "iconFont".
         * Wird verwendet wenn der iconType == "icon" ist.
         * Zeilt an als welcher Fontklasse das Icon verwendet wird.
         * Datatype: string
         * Defaultvalue: "material-icons"
         * Valid values: In der VisiWin Lib: "material-icons" und "winjs-icons"
        **/
        iconFont: string;
        /**
         * symbol property / option
         * Get and set the property "symbol".
         * Legt des Quelle des Symbols fest, bei
         *  "icon"        : der Name des Icons im Font.
         *  "image", "svg": der Name der Datei die dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: Iconname aus Font oder Path auf eine gültuge Image oder Svg Datei
        **/
        symbol: string;
        /**
         * symbolType property / option
         * Get and set the property "symbolType".
         * Es gibt drei gültige Werte:
         *  "icon" : Ein Zeichen aus einem Iconfont dargestellt. Es wird ein <I> Tag verwebdet.
         *  "image": Eine Bitmap Grafig in dem Format "PNG" oder "JPG" wird ausgegeben. Es wird ein "IMG" Tag verwendet.
         *  "svg"  : Eine SVF Grafig wird ausgegeben. Es wird ein <IMG> Tag verwendet.
         * Datatype: string
         * Defaultvalue: "icon"
         * Valid values: "icon", "image", svg"
        **/
        symbolType: string;
        /**
         * symbolAlignment property / option
         * Get and set the property "symbolAlignment".
         * The property symbolAlignment align Symbol element within Container element. There are five valid values:
         *   "top"    : Aligns the symbol element to the top.
         *   "right"  : Aligns the symbol element to the right.
         *   "bottom" : Aligns the symbol element to the bottom.
         *   "left"   : Aligns the symbol element to the left.
         *   "center" : Aligns the symbol element center.
         * Datatype: string
         * Defaultvalue: "left"
         * Valid values: "top", "right", "bottom", "left", "center"
        **/
        symbolAlignment: string;
        /**
         * symbolSize property / option
         * Get and set the property "symbolSize".
         * Größe des dargestellten Symbols.
         * Dieses Property muss immer in Zusammenhang mit den den Style Propertys "with" und "height" gesehen werden.
         * Der Wert auto besagt, die größe wird über die "width" und "height" Properties festgelegt.
         * Ist ein Wert angegeben, so wird damit die Breite und Höhe des Symbols angegeben. Sind die "width" und height"
         * Properties nicht auf "auto" eingestellt, sie wird hierdurch die größe des umgebenden Containers eingestellt,
         * andernfalls wird der Container an die größe des Symbols angepasst.
         * Datatype: string
         * Defaultvalue: "auto" -  symbolType="image" and symbolType="svg"
         *               "24px" -  symbolType="icon"
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        symbolSize: string;
        /**
         * symbolMargin property / option
         * Get and set the property "symbolMargin".
         * The property symbolMargin sets the margin just from one side of an Symbol element.
         * Note: From which side is margin selected, depends on the property "symbolAlignment".
         *       e.g. If symbolAlignment:'left',  Symbol element has css "margin-left" property,
         *            If symbolAlignment:'top', Symbol element has css "margin-top" property ...
         * Datatype: string
         * Defaultvalue: null
         * Valid values: auto | length | % | inherit
        **/
        symbolMargin: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
         * hoverColor property / option
         * Get and set the Property "hoverColor" of the corrosponding HTML Element.
         * The hoverColor property sets the css style property border-color of an element when the pointer hovers over element.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        hoverColor: string;
        /**
         * pressedColor property / option
         * Get and set the Property "pressedColor" of the corrosponding HTML Element.
         * The pressedColor property sets the css style property background-color of an element when the element is pressed.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        pressedColor: string;
        /**
         * checkedColor property / option
         * Get and set the Property "checkedColor" of the corrosponding HTML Element.
         * The checkedColor property sets the css style property background-color of an element when the element is checked.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        checkedColor: string;
        /**
         * disabledColor property / option
         * Get and set the Property "disabledColor" of the corrosponding HTML Element.
         * The disabledColor property sets the css style property color of an element when the element is disabled.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        disabledColor: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ToggleButton extends VisiWin.UI.ToggleButtonBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            padding: {
                propertyType: string;
                type: string;
                element: string;
                forceOverwrite: boolean;
            };
            transition: {
                propertyType: string;
                type: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                forceOverwrite: boolean;
            };
            pressedShadow: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            checkedShadow: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            checkedPressedShadow: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            containerBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerTransition: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolOn: {
                propertyType: string;
                type: string;
            };
            symbolOff: {
                propertyType: string;
                type: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            textWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
            };
            text: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            localizableText: {
                propertyType: string;
                type: string;
            };
            textOn: {
                propertyType: string;
                type: string;
            };
            localizableTextOn: {
                propertyType: string;
                type: string;
            };
            textOff: {
                propertyType: string;
                type: string;
            };
            localizableTextOff: {
                propertyType: string;
                type: string;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            lineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            textWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            textTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontClass: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                defaultValue: string;
            };
            fontSize: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            fontWeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            lineHeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            textContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            uppercase: {
                propertyType: string;
                type: string;
                child: string;
            };
            textPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        padding: string;
        transition: string;
        shadow: string;
        pressedShadow: string;
        checkedShadow: string;
        checkedPressedShadow: string;
        containerBorderWidth: string;
        containerBorderStyle: string;
        containerBorderRadius: string;
        containerTransition: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolOn: string;
        symbolOff: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        showText: boolean;
        textWidth: string;
        textHeight: string;
        textMargin: string;
        textPadding: string;
        textAlignment: string;
        lineClamp: number;
        textWrapping: string;
        textTrimming: string;
        fontSize: string;
        lineHeight: string;
        textContrast: number;
        uppercase: boolean;
        textPosition: string;
        backgroundColor: string;
        hoverBackgroundColor: string;
        pressedBackgroundColor: string;
        checkedBackgroundColor: string;
        checkedHoverBackgroundColor: string;
        checkedPressedBackgroundColor: string;
        disabledBackgroundColor: string;
        foregroundColor: string;
        hoverForegroundColor: string;
        pressedForegroundColor: string;
        checkedForegroundColor: string;
        checkedHoverForegroundColor: string;
        checkedPressedForegroundColor: string;
        disabledForegroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        checkedBorderColor: string;
        checkedHoverBorderColor: string;
        disabledBorderColor: string;
        private _containerElement;
        private _symbolElement;
        private _textElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        ready(): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IDropDownBox extends VisiWin.UI.IDropDownBoxBase {
        /**
          * constructor: Creates a new DropDownBox.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new DropDownBox control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBox control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBox control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBox control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBox control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBox control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBox control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBox control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBox control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * fontClass property / option
         * Get and set the fontClass of the control.
         * If set, the corrosponding Css fontclass will be set to the HTML Element.
         * In this Css Class is define the:
         *   font-family, font-size, font-weight, text-transform, line-height, letter-spacing, and opacity
         * Note: if the Application.Settings["HighContrastText"] is true, the opacity will be set always to "1.0"
         * Datatype: enum as string
         * Defaultvalue: null
         * Valid values:
         *      "display 4", "display 3", "display 2", "display 1", "headline", "title", "subheading",
         *      "subheading 2", "body 2", "body 1", "caption", "menu", "button", "button (all caps)", "label", "label1"
        **/
        fontClass: any;
        /**
         * borderWidth property / option
         * Get and set the css style property "borderWidth" of the corrosponding HTML Element.
         * The border-width property sets the width of an element's four borders. This property can have from one to four values.
         * Note: Always declare the border-style property before the border-width property. An element must have borders before you can set the width.
         * Datatype: string
         * Valid values: medium | thin | thick | length | initial | inherit
        **/
        borderWidth: string;
        textMargin: string;
        selectedIndex: number;
        selectedItem: any;
        /**
         * disabled property / option
         * Get and set the property "disabled".
         * If this property is set, the control will be display greyed, shadowed. Click and touch events will be blocked.
         * Changes for this property will be call the disabledCahnge eventhandler and the notifyPropertyChanged eventhandler.
         * Addition the Css Class disabled will be set when the control has the focus.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        disabled: boolean;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        menuAlignment: string;
        menuPlacement: string;
        colorAssignment: string;
        /**
         * variableName property / option
         * Get and set the property "variableName".
         * Legt die VisiWin Variable Fest die angemeldet werden soll.
         * War zuvor eine Varable angemeldet, so wird diese zuvor detach und abgemeldet.
         * Intern wird ein Event Handler auf Veränderungen der Variable angemeldet.
         * Dadurch werden einige Properties des VariablenMixin automatisch verändert:
         *      value, bitValue
         * Soll die Variable abgemeldet und keine neue angemeldet werden, so muss 'null'
         * als Parameter übergeben werden.
         * Datatype: string
         * Defaultvalue: null
        **/
        variableName: string;
        /**
         * showSymbol property / option
         * Get and set the property "showSymbol".
         * The property showSymbol shows or hides the Symbol element.
         * Datatype: boolean
         * Defaultvalue: false
         * Valid values: true | false
        **/
        showSymbol: boolean;
        /**
         * symbol property / option
         * Get and set the property "symbol".
         * Legt des Quelle des Symbols fest, bei
         *  "icon"        : der Name des Icons im Font.
         *  "image", "svg": der Name der Datei die dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: Iconname aus Font oder Path auf eine gültuge Image oder Svg Datei
        **/
        symbol: string;
        /**
         * symbolType property / option
         * Get and set the property "symbolType".
         * Es gibt drei gültige Werte:
         *  "icon" : Ein Zeichen aus einem Iconfont dargestellt. Es wird ein <I> Tag verwebdet.
         *  "image": Eine Bitmap Grafig in dem Format "PNG" oder "JPG" wird ausgegeben. Es wird ein "IMG" Tag verwendet.
         *  "svg"  : Eine SVF Grafig wird ausgegeben. Es wird ein <IMG> Tag verwendet.
         * Datatype: string
         * Defaultvalue: "icon"
         * Valid values: "icon", "image", svg"
        **/
        symbolType: string;
        /**
         * symbolSize property / option
         * Get and set the property "symbolSize".
         * Größe des dargestellten Symbols.
         * Dieses Property muss immer in Zusammenhang mit den den Style Propertys "with" und "height" gesehen werden.
         * Der Wert auto besagt, die größe wird über die "width" und "height" Properties festgelegt.
         * Ist ein Wert angegeben, so wird damit die Breite und Höhe des Symbols angegeben. Sind die "width" und height"
         * Properties nicht auf "auto" eingestellt, sie wird hierdurch die größe des umgebenden Containers eingestellt,
         * andernfalls wird der Container an die größe des Symbols angepasst.
         * Datatype: string
         * Defaultvalue: "auto" -  symbolType="image" and symbolType="svg"
         *               "24px" -  symbolType="icon"
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        symbolSize: string;
        /**
         * showItemSymbol property / option
         * Get and set the property "showItemSymbol".
         * The property showItemSymbol shows or hides the DropDownBoxItem Symbol element.
         * Datatype: boolean
         * Defaultvalue: false
         * Valid values: true | false
        **/
        showItemSymbol: boolean;
        /**
          * color property / option
          * Get and set the css style Property "color" of the corrosponding HTML Element.
          * The color property specifies the color of text.
          * Tip: Use a background color and a text color that makes the text easy to read.
          * Datatype: string
          * Defaultvalue: none
          * Valid values: color | auto | inherit | initial
         **/
        color: string;
        /**
          * foregroundColor property / option
          * Get and set the css style Property "color" of the corrosponding HTML Element.
          * The color property specifies the color of text.
          * Tip: Use a background color and a text color that makes the text easy to read.
          * Datatype: string
          * Defaultvalue: none
          * Valid values: color | auto | inherit | initial
         **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
         * hoverColor property / option
         * Get and set the Property "hoverColor" of the corrosponding HTML Element.
         * The hoverColor property sets the css style property border-color of an element when the pointer hovers over element.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        hoverColor: string;
        /**
         * focusedColor property / option
         * Get and set the Property "focusedColor" of the corrosponding HTML Element.
         * The focusedColor property sets the css style property background-color of an element when the element gets focus.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        focusedColor: string;
        /**
         * pressedColor property / option
         * Get and set the Property "pressedColor" of the corrosponding HTML Element.
         * The pressedColor property sets the css style property background-color of an element when the element is pressed.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        pressedColor: string;
        /**
         * disabledColor property / option
         * Get and set the Property "disabledColor" of the corrosponding HTML Element.
         * The disabledColor property sets the css style property color of an element when the element is disabled.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        disabledColor: string;
        /**
          * width property / option
          * Get and set the css style Property "width" of the corrosponding HTML Element.
          * The width property specifies the content width of boxes.
          * Datatype: string
          * Defaultvalue: auto
          * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class DropDownBox extends VisiWin.UI.VariableBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            selectedIndexChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            checkedChanged: {
                propertyType: string;
                triggerDataName: string;
            };
            checked: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            open: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            menuItems: {
                propertyType: string;
                type: string;
                child: string;
            };
            menuWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            menuHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            menuMargin: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            menuPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            menuBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            menuBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            menuBorderRadius: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            menuShadow: {
                propertyType: string;
                type: string;
            };
            menuPlacement: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            selectedIndex: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: number;
            };
            popoverId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            inputContainerWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputContainerPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputBorderRadius: {
                propertyType: string;
                type: string;
            };
            inputWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputHeight: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            inputMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            inputText: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            localizableInputText: {
                propertyType: string;
                type: string;
            };
            inputTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            inputUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            outlined: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            inputFieldMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbol: {
                propertyType: string;
                type: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelContainerWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                childProperty: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                childProperty: string;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showLeadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            leadingIconFont: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            leadingSymbol: {
                propertyType: string;
                type: string;
            };
            leadingSymbolType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            leadingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showFloatingLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            floatingLabelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableFloatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFixed: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            floatingLabelTransition: {
                propertyType: string;
                type: string;
            };
            floatingLabelOutlineWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            floatingLabelOutlineStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showTrailingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            trailingIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            trailingSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            trailingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showUnderline: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            underlineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            underlineOpacity: {
                propertyType: string;
                type: string;
            };
            checkedUnderlineOpacity: {
                propertyType: string;
                type: string;
            };
            underlineTransition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            underlineTransform: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            checkedUnderlineTransform: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            menuBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            menuBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedInputBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            underlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedUnderlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            symbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            leadingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedFloatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            trailingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            inputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverInputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedInputBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelOutlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledFloatingLabelOutlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        alignItems: string;
        justifyContent: string;
        menuItems: string;
        menuWidth: string;
        menuHeight: string;
        menuMargin: string;
        menuPadding: string;
        menuBorderWidth: string;
        menuBorderStyle: string;
        menuBorderRadius: string;
        menuShadow: string;
        menuPlacement: string;
        selectedIndex: number;
        popoverId: string;
        inputContainerWidth: string;
        inputContainerHeight: string;
        inputContainerMargin: string;
        inputContainerPadding: string;
        inputBorderWidth: string;
        inputBorderStyle: string;
        inputBorderRadius: string;
        inputWidth: string;
        inputHeight: string;
        inputMargin: string;
        inputPadding: string;
        inputText: string;
        localizableInputText: string;
        inputTextAlignment: string;
        inputLineClamp: number;
        inputTextWrapping: string;
        inputTextTrimming: string;
        inputFontClass: string;
        inputFontSize: string;
        inputFontWeight: string;
        inputLineHeight: string;
        inputTextContrast: number;
        inputUppercase: boolean;
        outlined: boolean;
        inputFieldMargin: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        labelContainerWidth: string;
        labelContainerHeight: string;
        labelContainerMargin: string;
        labelContainerPadding: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        showLeadingSymbol: boolean;
        leadingIconFont: string;
        leadingSymbol: string;
        leadingSymbolType: string;
        leadingSymbolSize: string;
        leadingSymbolMargin: string;
        showFloatingLabel: boolean;
        floatingLabelWidth: string;
        floatingLabelHeight: string;
        floatingLabelMargin: string;
        floatingLabelPadding: string;
        floatingLabelText: string;
        localizableFloatingLabelText: string;
        floatingLabelTextAlignment: string;
        floatingLabelLineClamp: number;
        floatingLabelTextWrapping: string;
        floatingLabelTextTrimming: string;
        floatingLabelFontClass: string;
        floatingLabelFontSize: string;
        floatingLabelFontWeight: string;
        floatingLabelLineHeight: string;
        floatingLabelTextContrast: number;
        floatingLabelUppercase: boolean;
        floatingLabelFixed: boolean;
        floatingLabelTransition: string;
        floatingLabelOutlineWidth: string;
        floatingLabelOutlineStyle: string;
        showTrailingSymbol: boolean;
        trailingIconFont: string;
        trailingSymbol: string;
        trailingSymbolType: string;
        trailingSymbolSize: string;
        trailingSymbolMargin: string;
        showUnderline: boolean;
        underlineHeight: string;
        underlineOpacity: number;
        checkedUnderlineOpacity: number;
        underlineTransition: string;
        underlineTransform: string;
        checkedUnderlineTransform: string;
        menuBackgroundColor: string;
        menuBorderColor: string;
        backgroundColor: string;
        inputBackgroundColor: string;
        hoverInputBackgroundColor: string;
        checkedInputBackgroundColor: string;
        floatingLabelBackgroundColor: string;
        underlineColor: string;
        checkedUnderlineColor: string;
        symbolForegroundColor: string;
        labelForegroundColor: string;
        inputForegroundColor: string;
        hoverInputForegroundColor: string;
        leadingSymbolForegroundColor: string;
        floatingLabelForegroundColor: string;
        checkedFloatingLabelForegroundColor: string;
        trailingSymbolForegroundColor: string;
        borderColor: string;
        inputBorderColor: string;
        hoverInputBorderColor: string;
        checkedInputBorderColor: string;
        floatingLabelOutlineColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        disabledFloatingLabelOutlineColor: string;
        private _labelElement;
        private _inputContainerElement;
        private _inputFieldContainerElement;
        private _inputElement;
        private _inputTextElement;
        private _leadingSymbolElement;
        private _inputFieldElement;
        private _floatingLabelElement;
        private _trailingSymbolElement;
        private _underlineElement;
        private _menuElement;
        private _popoverElement;
        private _boundPopoverHandler;
        private _boundHoverInHandler;
        private _boundHoverOutHandler;
        private _boundBeforeShowChangedHandler;
        private _boundBeforeHideChangedHandler;
        observe: any;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        afterInit(): void;
        private _checked;
        get checked(): boolean;
        set checked(value: boolean);
        set open(value: boolean);
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _popoverHandler(args: any): void;
        _hoverInHandler(args: any): void;
        _hoverOutHandler(args: any): void;
        _beforeShowChangedHandler(args: any): void;
        _beforeHideChangedHandler(args: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IDropDownBoxItem extends VisiWin.UI.IDropDownBoxItemBase {
        /**
          * constructor: Creates a new DropDownBoxItem.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new DropDownBoxItem control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBoxItem control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBoxItem control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBoxItem control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBoxItem control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBoxItem control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBoxItem control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBoxItem control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new DropDownBoxItem control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * value property / option
         * Get and set the property "value".
         * Der Wert von value wird automatisch einer angemeldeten Variablen nachgeführt.
         * In Ihr wird der Einheiten Umgerechnete Wert durch den Variablen Event Handler eingetragen.
         * Zusätzlich wird der option angegebene formatString zur darstellung ausgewertet.
         * Ein aufruf des Setters von value beschreibt NICHT automatisch die VisiWin Variable.
         * Je nach Datentype der Variabe kann sich der Datentype von value ändern.
         * Datatype: any
         * Defaultvalue: null
        **/
        value: any;
        /**
         * fontClass property / option
         * Get and set the fontClass of the control.
         * If set, the corrosponding Css fontclass will be set to the HTML Element.
         * In this Css Class is define the:
         *   font-family, font-size, font-weight, text-transform, line-height, letter-spacing, and opacity
         * Note: if the Application.Settings["HighContrastText"] is true, the opacity will be set always to "1.0"
         * Datatype: enum as string
         * Defaultvalue: null
         * Valid values:
         *      "display 4", "display 3", "display 2", "display 1", "headline", "title", "subheading",
         *      "subheading 2", "body 2", "body 1", "caption", "menu", "button", "button (all caps)", "label", "label1"
        **/
        fontClass: any;
        /**
         * borderWidth property / option
         * Get and set the css style property "borderWidth" of the corrosponding HTML Element.
         * The border-width property sets the width of an element's four borders. This property can have from one to four values.
         * Note: Always declare the border-style property before the border-width property. An element must have borders before you can set the width.
         * Datatype: string
         * Defaultvalue: medium
         * Valid values: medium | thin | thick | length | initial | inherit
        **/
        borderWidth: string;
        /**
         * disabled property / option
         * Get and set the property "disabled".
         * If this property is set, the control will be display greyed, shadowed. Click and touch events will be blocked.
         * Changes for this property will be call the disabledCahnge eventhandler and the notifyPropertyChanged eventhandler.
         * Addition the Css Class disabled will be set when the control has the focus.
         * Datatype: boolean
         * Defaultvalue: false
        **/
        disabled: boolean;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * text property / option
         * Get and set the property "text".
         * Enthält den Text der dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
        **/
        text: string;
        /**
         * locText property / option
         * Get and set the property "locText".
         * Enthält die TextID die dargestellt werden soll.
         * Das Property "text" wird mit der aufgelösten TextID überschrieben.
         * Die TextID ist sprachabhängig und wird über einen internen Eventhandler beim Aufruf der
         * Sprachumschaltung aufgerufen, so das das Property "text" automatisch ersetzt wird.
         * Datatype: string
         * Defaultvalue: null
        **/
        locText: string;
        /**
         * textAlignment property / option
         * Get and set the property "textAlignment".
         * Mit diesem Property kann die Ausrichtung des Textes angepasst werden.
         * Zur Verfügung stehen:
         *     left     Der Text wird linksbündig, vertikal mittig ausgegeben
         *     center   Der Text wird horizontal und vertikal mittig ausgegeben
         *     right    Der Text wird rechtsbündig, vertikal mittig ausgegeben
         *     top      Der Text wird am oberen Rand, horizontal mittig ausgegeben
         *     bottom   Der Text wird am unteren Rand, horizontal mittig ausgebenen
         * Datatype: enum als string
         * Defaultvalue: "center"
         * Valid values: "left", "center" "right", "top", "bottom"
        **/
        textAlignment: string;
        /**
         * textMargin property / option
         * Get and set the property "textMargin".
         * The property textMargin sets the margin just from one side of an Text element.
         * Note: From which side is margin selected, depends on the property "textAlignment".
         *       e.g. textAlignment:'left',   Text element has css "margin-left" property,
         *            textAlignment:'top',    Text element has css "margin-top" property,
         *            textAlignment:'right',  Text element has css "margin-right" property,
         *            textAlignment:'bottom', Text element has css "margin-bottom" property,
         *            textAlignment:'center'  Text element is always centred.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: auto | length | % | inherit
        **/
        textMargin: string;
        /**
         * showSymbol property / option
         * Get and set the property "showSymbol".
         * The property showSymbol shows or hides the Symbol element.
         * Datatype: boolean
         * Defaultvalue: false
         * Valid values: true | false
        **/
        showSymbol: boolean;
        /**
         * symbol property / option
         * Get and set the property "symbol".
         * Legt des Quelle des Symbols fest, bei
         *  "icon"        : der Name des Icons im Font.
         *  "image", "svg": der Name der Datei die dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: Iconname aus Font oder Path auf eine gültuge Image oder Svg Datei
        **/
        symbol: string;
        /**
         * symbolType property / option
         * Get and set the property "symbolType".
         * Es gibt drei gültige Werte:
         *  "icon" : Ein Zeichen aus einem Iconfont dargestellt. Es wird ein <I> Tag verwebdet.
         *  "image": Eine Bitmap Grafig in dem Format "PNG" oder "JPG" wird ausgegeben. Es wird ein "IMG" Tag verwendet.
         *  "svg"  : Eine SVF Grafig wird ausgegeben. Es wird ein <IMG> Tag verwendet.
         * Datatype: string
         * Defaultvalue: "icon"
         * Valid values: "icon", "image", svg"
        **/
        symbolType: string;
        /**
         * symbolSize property / option
         * Get and set the property "symbolSize".
         * Größe des dargestellten Symbols.
         * Dieses Property muss immer in Zusammenhang mit den den Style Propertys "with" und "height" gesehen werden.
         * Der Wert auto besagt, die größe wird über die "width" und "height" Properties festgelegt.
         * Ist ein Wert angegeben, so wird damit die Breite und Höhe des Symbols angegeben. Sind die "width" und height"
         * Properties nicht auf "auto" eingestellt, sie wird hierdurch die größe des umgebenden Containers eingestellt,
         * andernfalls wird der Container an die größe des Symbols angepasst.
         * Datatype: string
         * Defaultvalue: "auto" -  symbolType="image" and symbolType="svg"
         *               "24px" -  symbolType="icon"
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        symbolSize: string;
        /**
         * symbolMargin property / option
         * Get and set the property "symbolMargin".
         * The property symbolMargin sets the margin just from one side of an Symbol element.
         * Note: From which side is margin selected, depends on the property "symbolAlignment".
         *       e.g. If symbolAlignment:'left',  Symbol element has css "margin-left" property,
         *            If symbolAlignment:'top', Symbol element has css "margin-top" property ...
         * Datatype: string
         * Defaultvalue: null
         * Valid values: auto | length | % | inherit
        **/
        symbolMargin: string;
        /**
          * foregroundColor property / option
          * Get and set the css style Property "color" of the corrosponding HTML Element.
          * The color property specifies the color of text.
          * Tip: Use a background color and a text color that makes the text easy to read.
          * Datatype: string
          * Defaultvalue: none
          * Valid values: color | auto | inherit | initial
         **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
         * hoverColor property / option
         * Get and set the Property "hoverColor" of the corrosponding HTML Element.
         * The hoverColor property sets the css style property background-color of an element when the pointer hovers over element.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        hoverColor: string;
        /**
         * pressedColor property / option
         * Get and set the Property "pressedColor" of the corrosponding HTML Element.
         * The pressedColor property sets the css style property background-color of an element when the element is pressed.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        pressedColor: string;
        /**
         * checkedColor property / option
         * Get and set the Property "checkedColor" of the corrosponding HTML Element.
         * The checkedColor property sets the css style property background-color of an element when the element is checked.
         * Note: checkedColor property only works under "DropDownBox".
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        checkedColor: string;
        /**
         * disabledColor property / option
         * Get and set the Property "disabledColor" of the corrosponding HTML Element.
         * The disabledColor property sets the css style property color of an element when the element is disabled.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        disabledColor: string;
        /**
          * width property / option
          * Get and set the css style Property "width" of the corrosponding HTML Element.
          * The width property specifies the content width of boxes.
          * Datatype: string
          * Defaultvalue: auto
          * Valid values: <length> | <percentage> | auto | inherit
         **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class DropDownBoxItem extends VisiWin.UI.ToggleButtonBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            padding: {
                propertyType: string;
                type: string;
                element: string;
                forceOverwrite: boolean;
            };
            transition: {
                propertyType: string;
                type: string;
            };
            containerBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerTransition: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            textWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            text: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                defaultValue: string;
            };
            localizableText: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            lineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            textWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            textTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontClass: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            fontSize: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            fontWeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            lineHeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            textContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            uppercase: {
                propertyType: string;
                type: string;
                child: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        padding: string;
        transition: string;
        containerBorderWidth: string;
        containerBorderStyle: string;
        containerBorderRadius: string;
        containerTransition: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        showText: boolean;
        textWidth: string;
        textHeight: string;
        textMargin: string;
        textPadding: string;
        fontSize: string;
        textAlignment: string;
        lineClamp: number;
        textWrapping: string;
        textTrimming: string;
        lineHeight: string;
        textContrast: number;
        uppercase: boolean;
        backgroundColor: string;
        hoverBackgroundColor: string;
        hoverForegroundColor: string;
        pressedBackgroundColor: string;
        checkedBackgroundColor: string;
        checkedHoverBackgroundColor: string;
        checkedHoverForegroundColor: string;
        checkedPressedBackgroundColor: string;
        disabledBackgroundColor: string;
        foregroundColor: string;
        pressedForegroundColor: string;
        checkedForegroundColor: string;
        checkedPressedForegroundColor: string;
        disabledForegroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        checkedBorderColor: string;
        checkedHoverBorderColor: string;
        disabledBorderColor: string;
        private _containerElement;
        private _symbolElement;
        private _textElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        attach(): any;
        detach(): Promise<any>;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAlarmItem extends VisiWin.UI.IControlBase {
        /**
         * constructor: Creates a new AlarmItem.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
           * width property / option
           * Get and set the css style Property "width" of the corrosponding HTML Element.
           * The width property specifies the content width of boxes.
           * Datatype: string
           * Defaultvalue: auto
           * Valid values: <length> | <percentage> | auto | inherit
          **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AlarmItem extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        ready(element: VWElement): void;
        _setWinInteractiveClass(element: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IHistoricalAlarmItem extends VisiWin.UI.IControlBase {
        /**
         * constructor: Creates a new AlarmItem.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
           * width property / option
           * Get and set the css style Property "width" of the corrosponding HTML Element.
           * The width property specifies the content width of boxes.
           * Datatype: string
           * Defaultvalue: auto
           * Valid values: <length> | <percentage> | auto | inherit
          **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class HistoricalAlarmItem extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        ready(element: VWElement): void;
        _setWinInteractiveClass(element: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAlarmListView extends IControlBase {
        /**
         * constructor: Creates a new AlarmItem.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
           * width property / option
           * Get and set the css style Property "width" of the corrosponding HTML Element.
           * The width property specifies the content width of boxes.
           * Datatype: string
           * Defaultvalue: auto
           * Valid values: <length> | <percentage> | auto | inherit
          **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IAlarmLine extends IControlBase {
        /**
         * constructor: Creates a new AlarmItem.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class AlarmLine extends VisiWin.UI.ControlBase {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            width: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            height: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            background: {
                propertyType: string;
                type: string;
            };
            borderWidth: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            borderStyle: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            borderRadius: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            opacity: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            visibility: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbolWidth: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            symbolHeight: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            symbolSize: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            defaultAlarmSymbolIconFont: {
                propertyType: string;
                child: string;
                type: string;
                childOption: string;
            };
            defaultAlarmSymbol: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            defaultAlarmSymbolType: {
                propertyType: string;
                child: string;
                type: string;
                childOption: string;
            };
            symbolMargin: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            showAlarmSymbol: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: boolean;
            };
            showDefaultAlarmSymbol: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: boolean;
            };
            alignItems: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
            };
            dateTimeWidth: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            dateTimeHeight: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            alarmDateTimeMargin: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            alarmDateTimePadding: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            dateFontClass: {
                propertyType: string;
                child: string;
                type: string;
            };
            dateFontSize: {
                propertyType: string;
                child: string;
                type: string;
            };
            dateFontWeight: {
                propertyType: string;
                child: string;
                type: string;
            };
            timeFontClass: {
                propertyType: string;
                child: string;
                type: string;
            };
            timeFontSize: {
                propertyType: string;
                child: string;
                type: string;
            };
            timeFontWeight: {
                propertyType: string;
                child: string;
                type: string;
            };
            showAlarmDateTime: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: boolean;
            };
            dateTextContrast: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: number;
            };
            dateUppercase: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: boolean;
            };
            timeTextContrast: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: number;
            };
            timeUppercase: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: boolean;
            };
            dateTimeMode: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
            };
            formatDate: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
            };
            formatTime: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
            };
            alarmGroupWidth: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            alarmGroupAlignment: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            alarmGroupFontClass: {
                propertyType: string;
                child: string;
                type: string;
                childOption: string;
            };
            alarmGroupFontSize: {
                propertyType: string;
                child: string;
                type: string;
                childOption: string;
            };
            alarmGroupFontWeight: {
                propertyType: string;
                child: string;
                type: string;
                childOption: string;
            };
            alarmGroupMargin: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            showAlarmGroup: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: boolean;
            };
            alarmTextWidth: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            alarmTextHeight: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            alarmTextAlignment: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            alarmTextLineClamp: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            alarmTextWrapping: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            alarmTextFontClass: {
                propertyType: string;
                child: string;
                type: string;
                childOption: string;
            };
            alarmTextFontSize: {
                propertyType: string;
                child: string;
                type: string;
                childOption: string;
            };
            alarmTextFontWeight: {
                propertyType: string;
                child: string;
                type: string;
                childOption: string;
            };
            alarmTextMargin: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            defaultAlarmLocalizableText: {
                propertyType: string;
                type: string;
            };
            defaultAlarmText: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            showAlarmText: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: boolean;
            };
            showDefaultAlarmText: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: boolean;
            };
            acknowledgeButtonWidth: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            acknowledgeButtonSymbolSize: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            acknowledgeButtonSymbol: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            acknowledgeButtonIconFont: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            acknowledgeButtonSymbolType: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            acknowledgeButtonMargin: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            acknowledgeButtonPadding: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            showAcknowledgeButton: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: boolean;
            };
            desiredClasses: {
                propertyType: string;
                type: string;
            };
            desiredGroups: {
                propertyType: string;
                type: string;
            };
            desiredStates: {
                propertyType: string;
                type: string;
            };
            maxPriority: {
                propertyType: string;
                type: string;
            };
            minPriority: {
                propertyType: string;
                type: string;
            };
            alarmSortMode: {
                type: StringConstructor;
                defaultValue: string;
            };
            acknowledgeButtonDisabledForegroundColor: {
                propertyType: string;
                child: string;
                type: string;
                defaultValue: string;
                childOption: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            defaultSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            toggleAlarms: {
                propertyType: string;
                type: string;
            };
            toggleTime: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
        };
        cssStyles: {
            css: string;
        };
        private myAlarmService;
        private myCurrentAlarmsFilter;
        private myCurrentAlarms;
        symbolWidth: string;
        symbolHeight: string;
        symbolSize: string;
        defaultAlarmSymbolIconFont: string;
        defaultAlarmSymbol: string;
        defaultAlarmSymbolType: string;
        symbolMargin: string;
        showAlarmSymbol: boolean;
        showDefaultAlarmSymbol: boolean;
        dateTimeMode: string;
        formatDate: string;
        formatTime: string;
        dateFontClass: string;
        dateFontSize: string;
        dateFontWeight: string;
        alarmDateTimeMargin: string;
        alarmDateTimePadding: string;
        timeFontClass: string;
        timeFontSize: string;
        timeFontWeight: string;
        showAlarmDateTime: boolean;
        alarmGroupFontClass: string;
        alarmGroupFontSize: string;
        alarmGroupFontWeight: string;
        alarmGroupMargin: string;
        showAlarmGroup: boolean;
        alarmTextFontClass: string;
        alarmTextFontSize: string;
        alarmTextFontWeight: string;
        alarmTextMargin: string;
        alarmTextWidth: string;
        alarmTextHeight: string;
        alarmTextAlignment: string;
        alarmTextLineClamp: number;
        alarmTextWrapping: string;
        showAlarmText: boolean;
        showDefaultAlarmText: boolean;
        defaultAlarmText: string;
        acknowledgeButtonSymbolSize: string;
        acknowledgeButtonSymbol: string;
        acknowledgeButtonIconFont: string;
        acknowledgeButtonSymbolType: string;
        acknowledgeButtonMargin: string;
        acknowledgeButtonPadding: string;
        showAcknowledgeButton: boolean;
        desiredClasses: string;
        desiredGroups: string;
        desiredStates: VisiWin.System.Alarm.AlarmState[];
        maxPriority: number;
        minPriority: number;
        alarmSortMode: string;
        private _alarmSortModeEnum;
        defaultAlarmLocalizableText: string;
        backgroundColor: string;
        foregroundColor: string;
        borderColor: string;
        defaultSymbolForegroundColor: string;
        private toggleAlarms;
        private toggleTime;
        private mainContainerElement;
        private alarmSymbolElement;
        private alarmTimeElement;
        private alarmGroupElement;
        private alarmGroupAndTextSeparator;
        private alarmTextElement;
        private alarmAcknowledgeButtonElement;
        private noAlarmTextElement;
        private hightestPrio;
        private highestPrioElement;
        private highestPrioAlarms;
        private prioAlarms;
        private currentAlarms;
        private currentAlarmProvider;
        private myUserManagementService;
        private rights;
        private intervalId;
        private toggleAlarmGroup;
        private toggleAlarmName;
        private _buttonClickHandler;
        private _alarmStateChange;
        private alarmChangeHandler;
        private alarmNewHandler;
        private alarmClearHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        createHandler(): void;
        removeHandler(): void;
        _updateLayout(change: VisiWin.UI.IUpdateLayout): void;
        alarmHandlers(): void;
        attach(): Promise<any> | null;
        detach(): Promise<any> | null;
        _setElementsColor(): void;
        _updateColors(changes: any): void;
        private _handlesMainContainerElement;
        private _handlesAlarmDateAndTimeElement;
        private _handlesAlarmGroupAndTextElementFonts;
        private _handlesSymbol;
        private _handlesAckBtnSymbol;
        private myAuthorizationRightChanged;
        private _noAlarms;
        private _ifAlarmsSetsVisibility;
        private elementColorsWhenAuthorized;
        private elementColorsWhenNotAuthorized;
        private _updateElementColors;
        private _updateSymbol;
        _initAlarmService(): void;
        private _toggleAlarmState;
        private _highestPriorityAlarm;
        private _updateAlarms;
        _alarmItemStateChanged(e: VisiWin.System.Alarm.IAlarmItem): void;
        _alarmNewHandler(e: VisiWin.System.Alarm.IAlarmItem): void;
        _alarmClearHandler(e: VisiWin.System.Alarm.IAlarmItem): void;
        _alarmChangeHandler(e: VisiWin.System.Alarm.IAlarmItem): void;
        _clickHandler(e: any): void;
    }
}
declare module VisiWin.UI {
    class HistoricalAlarmList extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            desiredClasses: {
                propertyType: string;
                type: string;
                child: string;
            };
            desiredGroups: {
                propertyType: string;
                type: string;
                child: string;
            };
            desiredStates: {
                propertyType: string;
                type: string;
                child: string;
            };
            maxPriority: {
                propertyType: string;
                type: string;
                child: string;
            };
            minPriority: {
                propertyType: string;
                type: string;
                child: string;
            };
            minDate: {
                propertyType: string;
                type: string;
                child: string;
            };
            maxDate: {
                propertyType: string;
                type: string;
                child: string;
            };
            period: {
                propertyType: string;
                type: string;
                child: string;
            };
            sampleData: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            template: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        template: string;
        backgroundColor: string;
        private _listViewElement;
        private _listViewControl;
        private _alarmItemTemplateElement;
        private _historicalAlarmsProvider;
        private _isListViewLoaded;
        private _isSampleDataLoaded;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        afterInit(): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        _initListView(): void;
        _onSampleDataLoaded(): void;
        _listViewChangeHandler(args: any, e: any): void;
        updateAlarmList(args?: any): void;
        dispose(): any;
    }
}
declare namespace VisiWin.UI {
    class Label extends VisiWin.UI.VariableBase {
        private properties;
        private cssStyles;
        labelForegroundColor: string;
        symbolForegroundColor: string;
        disabledForegroundColor: string;
        show: boolean;
        symbolPosition: string;
        private _symbolControl;
        private _textControl;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
    }
}
declare module VisiWin.UI {
    interface ISpacer extends VisiWin.UI.IControlBase {
        /**
          * constructor: Creates a new Tile.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new Tile control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile control.
         **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
         * width property / option
         * Get and set the css style Property "width" of the corrosponding HTML Element.
         * The width property specifies the content width of boxes.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Spacer extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Card extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            deviceType: {
                propertyType: string;
                type: string;
            };
            columnsPhone: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            columnsTablet: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            columnsDesktop: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            columnsLargeDesktop: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            orderPhone: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            orderTablet: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            orderDesktop: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            orderLargeDesktop: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            alignPhone: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignTablet: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignDesktop: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignLargeDesktop: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        deviceType: string;
        columnsPhone: number;
        columnsTablet: number;
        columnsDesktop: number;
        columnsLargeDesktop: number;
        orderPhone: number;
        orderTablet: number;
        orderDesktop: number;
        orderLargeDesktop: number;
        alignPhone: string;
        alignTablet: string;
        alignDesktop: string;
        alignLargeDesktop: string;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ICardHeader extends VisiWin.UI.IControlBase {
        /**
          * constructor: Creates a new Tile_Title.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new Tile_Title control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Title control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Title control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Title control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Title control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Title control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Title control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Title control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Title control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * borderWidth property / option
         * Get and set the css style property "borderWidth" of the corrosponding HTML Element.
         * The border-width property sets the width of an element's four borders. This property can have from one to four values.
         * Note: Always declare the border-style property before the border-width property. An element must have borders before you can set the width.
         * Datatype: string
         * Defaultvalue: medium
         * Valid values: medium | thin | thick | length | initial | inherit
        **/
        borderWidth: string;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
          * width property / option
          * Get and set the css style Property "width" of the corrosponding HTML Element.
          * The width property specifies the content width of boxes.
          * Datatype: string
          * Defaultvalue: auto
          * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class CardHeader extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showTitle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            titleWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titlePadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableTitleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            titleFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showSubtitle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            subtitleWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitlePadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableSubtitleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            subtitleFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            titleForegroundColor: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            subtitleForegroundColor: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
        };
        showTitle: boolean;
        titleWidth: string;
        titleHeight: string;
        titleMargin: string;
        titlePadding: string;
        titleText: string;
        localizableTitleText: string;
        titleTextAlignment: string;
        titleLineClamp: number;
        titleTextWrapping: string;
        titleTextTrimming: string;
        titleFontClass: string;
        titleFontSize: string;
        titleFontWeight: string;
        titleLineHeight: string;
        titleTextContrast: number;
        titleUppercase: boolean;
        showSubtitle: boolean;
        subtitleWidth: string;
        subtitleHeight: string;
        subtitleMargin: string;
        subtitlePadding: string;
        subtitleText: string;
        localizableSubtitleText: string;
        subtitleTextAlignment: string;
        subtitleLineClamp: number;
        subtitleTextWrapping: string;
        subtitleTextTrimming: string;
        subtitleFontClass: string;
        subtitleFontSize: string;
        subtitleFontWeight: string;
        subtitleLineHeight: string;
        subtitleTextContrast: number;
        subtitleUppercase: boolean;
        backgroundColor: string;
        borderColor: string;
        titleForegroundColor: string;
        subtitleForegroundColor: string;
        private _titleElement;
        private _subtitleElement;
        constructor(element: any, options: any);
        createTemplate(): any;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ICardContent extends VisiWin.UI.IControlBase {
        /**
          * constructor: Creates a new Tile_Content.
          * @constructor
          * @param element The DOM element that will host the control.
          * @param options The set of properties and values to apply to the new Tile_Content control.
         **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Content control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Content control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Content control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Content control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Content control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Content control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Content control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new Tile_Content control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * borderWidth property / option
         * Get and set the css style property "borderWidth" of the corrosponding HTML Element.
         * The border-width property sets the width of an element's four borders. This property can have from one to four values.
         * Note: Always declare the border-style property before the border-width property. An element must have borders before you can set the width.
         * Datatype: string
         * Defaultvalue: medium
         * Valid values: medium | thin | thick | length | initial | inherit
        **/
        borderWidth: string;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
         * borderColor property / option
         * Get and set the css style Property "borderColor" of the corrosponding HTML Element.
         * The border-color property sets the color of an element's four borders.
         * This property can have from one to four values.
         * Note: Always declare the border-style property before the border-color property. An element must have borders before you can change the color.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        borderColor: string;
        /**
          * width property / option
          * Get and set the css style Property "width" of the corrosponding HTML Element.
          * The width property specifies the content width of boxes.
          * Datatype: string
          * Defaultvalue: auto
          * Valid values: <length> | <percentage> | auto | inherit
        **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class CardContent extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            orientation: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            wrap: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        overflow: string;
        orientation: string;
        alignItems: string;
        justifyContent: string;
        alignContent: string;
        wrap: boolean;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    /**
    * @class
    * @name VisiWin.UI.Series
    * @description Class The series obtains its data from the VisiWin system module Trends.
    * @memberof VisiWin.UI
    */
    interface ISeries extends VisiWin.UI.IProviderBase {
        /**
        * archiveName
        * Required property.
        * Specifies the name of an archive definition.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } archiveName
        **/
        archiveName: string;
        /**
        * trendName
        * Required property.
        * Specifies the name of a trend definition.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } trendName
        **/
        trendName: string;
        /**
        * yaxisNumber
        * The yaxisNumber specifies the order of the line and its scale.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } yaxisNumber
        **/
        yaxisNumber: number;
        /**
        * rawLimitMin
        * Specifies the minimum value of the Y-axis.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } rawLimitMin
        **/
        rawLimitMin: number;
        /**
        * rawLimitMax
        * Specifies the maximum value of the Y-axis.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } rawLimitMax
        **/
        rawLimitMax: number;
        /**
        * showLine
        * Specifies whether the line is drawn.
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } showLine
        **/
        showLine: boolean;
        /**
        * lineWidth
        * Specifies the line width.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } lineWidth
        **/
        lineWidth: number;
        /**
        * lineFill
        * Specifies whether the area below the line is filled with the LineFillColor.
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } lineFill
        **/
        lineFill: boolean;
        /**
        * lineColor
        * Specifies the LineColor.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } lineColor
        **/
        lineColor: string;
        /**
        * lineFillColor
        * Specifies the LineFillColor for the area below the line.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } lineFillColor
        **/
        lineFillColor: string;
        /**
        * position
        * Specifies the Position of the Y-axis(Left/Right).
        * default YAxisPosition.Left
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } position
        **/
        position: string;
        /**
        * number
        * Specifies the division of the scale.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } number
        **/
        ticks: number;
        /**
        * labelWidth
        * Specifies the width of the Y-axis.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } labelWidth
        **/
        labelWidth: number;
        /**
        * tickLength
        * Specifies the length of the scale tick.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } tickLength
        **/
        tickLength: number;
        /**
        * tickDecimals
        * Specifies the decimals of the scale ticks.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } tickDecimals
        **/
        tickDecimals: number;
        /**
        * yaxisColor
        * Specifies the color of the Y-axis.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } yaxisColor
        **/
        yaxisColor: string;
    }
}
declare namespace VisiWin.UI {
    const YAxisPosition: {
        Left: string;
    };
    class Series extends VisiWin.UI.ProviderBase implements VisiWin.UI.ISeries {
        static namespace: string;
        static controlName: string;
        static propertyList: {
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            designTimeData: {};
            archiveName: {};
            trendName: {};
            yaxisNumber: {
                type: string;
                defaultValue: number;
            };
            showLine: {
                type: string;
                defaultValue: boolean;
            };
            lineWidth: {
                type: string;
                defaultValue: number;
            };
            lineFill: {
                type: string;
                defaultValue: boolean;
            };
            lineColor: {
                type: string;
                defaultValue: string;
            };
            lineFillColor: {
                type: string;
                defaultValue: string;
            };
            lineSteps: {
                type: string;
                defaultValue: boolean;
            };
            lineZero: {
                type: string;
                defaultValue: boolean;
            };
            showAxis: {
                type: string;
                defaultValue: boolean;
            };
            position: {
                type: string;
                defaultValue: string;
            };
            rawLimitMin: {
                type: string;
                defaultValue: number;
            };
            rawLimitMax: {
                type: string;
                defaultValue: number;
            };
            ticks: {
                type: string;
                defaultValue: number;
            };
            labelWidth: {
                type: string;
                defaultValue: number;
            };
            tickLength: {
                type: string;
                defaultValue: number;
            };
            tickDecimals: {
                type: string;
                defaultValue: number;
            };
            yaxisColor: {
                type: string;
                defaultValue: string;
            };
        };
        showAxis: boolean;
        rawLimitMin: number;
        rawLimitMax: number;
        position: string;
        ticks: number;
        labelWidth: number;
        tickLength: number;
        tickDecimals: number;
        yaxisColor: string;
        archiveName: string;
        trendName: string;
        yaxisNumber: number;
        showLine: boolean;
        lineWidth: number;
        lineFill: boolean;
        lineColor: string;
        lineFillColor: string;
        designTimeData: any;
        lineSteps: boolean;
        lineZero: boolean;
        constructor(element: VWElement, options: any);
    }
}
declare namespace VisiWin.UI {
    /**
    * @class
    * @name VisiWin.UI.TrendChartController
    * @description Class The class creates a simple wrapper for the TrendChartControllerTemplate.
    * @memberof VisiWin.UI
    */
    interface ITrendChartController extends VisiWin.UI.IControlBase {
        /**
        * trendChartId
        * Specifies the associated trend chart element.(Required)
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } trendChartId
        **/
        trendChartId: string;
        /**
        * template
        * Specifies the tamplete for the controller element.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } template
        **/
        template: string;
    }
}
declare module VisiWin.UI {
    class TrendChartController extends VisiWin.UI.ControlBase implements VisiWin.UI.ITrendChartController {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            designTimeWarning: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            trendChartId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            template: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            disableControlsDuringRequest: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disableControlsOnDataRequest: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        private cssStyles;
        backgroundColor: string;
        private _containerElement;
        disableControlsOnDataRequest: boolean;
        trendChartId: string;
        designTimeWarning: boolean;
        template: string;
        private _hasTriggerIds;
        private _trendChart;
        private _toggleButton;
        private _trendDataRequestStarted;
        private _trendDataRequestStartedHandler;
        private _trendDataRequestCompleted;
        private _trendDataRequestCompletedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        private _boundDataTemplateReady;
        dataTemplateReady(dataTemp: any): Promise<void>;
        private _updateIdForTriggers;
        private _tryUpdateToggleState;
        private _tryGetOrCreateId;
        private _tryFindTrendChart;
        ready(): Promise<null>;
        attach(): Promise<any>;
        detach(): Promise<any>;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI.Trend.Controller {
    const fastBackwardButton = "<div data-win-control=\"VisiWin.UI.Button\" data-win-options='{\"style\":\"Plain.Icon\",\"margin\":\"0px\",\"symbol\":\"fast_rewind\",\"symbolSize\":\"32px\"}'\ndata-win-actions='{\"triggers\":[{\"type\":\"VisiWin.Triggers.ControlEventTrigger\",\"eventName\":\"onButtonclick\",\"triggeredActions\":[{\"type\":\"VisiWin.Actions.TrendChartFastBackwardAction\"}]}]}'>\n</div>";
    const backwardButton = "<div data-win-control=\"VisiWin.UI.Button\" data-win-options='{\"style\":\"Plain.Icon\",\"margin\":\"0px\",\"symbol\":\"skip_previous\",\"symbolSize\":\"32px\"}'\ndata-win-actions='{\"triggers\":[{\"type\":\"VisiWin.Triggers.ControlEventTrigger\",\"eventName\":\"onButtonclick\",\"triggeredActions\":[{\"type\":\"VisiWin.Actions.TrendChartBackwardAction\"}]}]}'>\n</div>\n";
    const toggledButton = "<div data-win-control=\"VisiWin.UI.ToggleButton\" data-win-options='{\"style\":\"Plain.Icon\",\"margin\": \"0px\",\"padding\": \"0px\",\"symbolSize\": \"40px\",\"symbolOn\": \"play_arrow\",\"symbolOff\": \"pause\"}'\ndata-win-actions='{\"triggers\":[{\"type\":\"VisiWin.Triggers.ControlEventTrigger\",\"eventName\":\"onCheckedChanged\",\"sourcePropertyValueName\":\"checked\",\"triggeredActions\":[\n{\"type\":\"VisiWin.Actions.SetPropertyAction\",\"propertyName\":\"symbol\",\"propertyValueIfTrue\":\"play_arrow\",\"propertyValueIfFalse\":\"pause\",\"operand1\":\"value\",\"operator\":\"==\",\"operand2\":\"true\"},\n{\"type\":\"VisiWin.Actions.TrendChartToggleOnlineAction\"}]}]}'>\n</div>\n";
    const forwardButton = "<div data-win-control=\"VisiWin.UI.Button\"\ndata-win-options='{\"style\":\"Plain.Icon\",\"margin\":\"0px\",\"symbol\":\"skip_next\",\"symbolSize\":\"32px\"}'\ndata-win-actions='{\"triggers\":[{\"type\":\"VisiWin.Triggers.ControlEventTrigger\",\"eventName\":\"onButtonclick\",\"triggeredActions\":[{\"type\":\"VisiWin.Actions.TrendChartForwardAction\"}]}]}'>\n</div>\n";
    const fastForwarddButton = "<div data-win-control=\"VisiWin.UI.Button\"\ndata-win-options='{\"style\":\"Plain.Icon\",\"margin\":\"0px\",\"symbol\":\"fast_forward\",\"symbolSize\":\"32px\"}'\ndata-win-actions='{\"triggers\":[{\"type\":\"VisiWin.Triggers.ControlEventTrigger\",\"eventName\":\"onButtonclick\",\"triggeredActions\":[{\"type\":\"VisiWin.Actions.TrendChartFastForwardAction\"}]}]}'>\n</div>";
    const refreshButton = "<div data-win-control=\"VisiWin.UI.Button\"\ndata-win-options='{\"style\":\"Plain.Icon\",\"margin\":\"0px\",\"symbol\":\"refresh\",\"symbolSize\":\"32px\"}'\ndata-win-actions='{\"triggers\":[{\"type\":\"VisiWin.Triggers.ControlEventTrigger\",\"eventName\":\"onButtonclick\",\"triggeredActions\":[{\"type\":\"VisiWin.Actions.TrendChartRefreshAction\"}]}]}'>\n</div>\n";
    const timespanDropDown = "<div data-win-control=\"VisiWin.UI.DropDownBox\"\ndata-win-options='{\"style\":\"Plain.Default\",\"width\":\"112px\",\"margin\":\"0px\",\"menuPlacement\":\"Top\",\"showFloatingLabel\":false,\"selectedIndex\":0}'\ndata-win-actions='{\"triggers\":[{\"type\":\"VisiWin.Triggers.ControlEventTrigger\",\"eventName\":\"onSelectedIndexChanged\",\"triggeredActions\":[{\"type\":\"VisiWin.Actions.TrendChartTimeSpanAction\",\"timeSpanIfTrue\":\"value\"}]}]}'>\n<div data-win-control=\"VisiWin.UI.DropDownBoxItem\" data-win-options='{\"style\":\"Plain.Default\",\"value\":\"2\",  \"text\":\"00:02:00\",\"textAlignment\":\"Center\"}'></div>\n<div data-win-control=\"VisiWin.UI.DropDownBoxItem\" data-win-options='{\"style\":\"Plain.Default\",\"value\":\"10\", \"text\":\"00:10:00\",\"textAlignment\":\"Center\"}'></div>\n<div data-win-control=\"VisiWin.UI.DropDownBoxItem\" data-win-options='{\"style\":\"Plain.Default\",\"value\":\"15\", \"text\":\"00:15:00\",\"textAlignment\":\"Center\"}'></div>\n<div data-win-control=\"VisiWin.UI.DropDownBoxItem\" data-win-options='{\"style\":\"Plain.Default\",\"value\":\"30\", \"text\":\"00:30:00\",\"textAlignment\":\"Center\"}'></div>\n<div data-win-control=\"VisiWin.UI.DropDownBoxItem\" data-win-options='{\"style\":\"Plain.Default\",\"value\":\"60\", \"text\":\"01:00:00\",\"textAlignment\":\"Center\"}'></div>\n<div data-win-control=\"VisiWin.UI.DropDownBoxItem\" data-win-options='{\"style\":\"Plain.Default\",\"value\":\"300\",\"text\":\"05:00:00\",\"textAlignment\":\"Center\"}'></div>\n</div>";
}
declare namespace VisiWin.UI {
    /**
    * @class
    * @name VisiWin.UI.TrendChart
    * @description Class The class creates a simple trend chart.
    * @memberof VisiWin.UI
    */
    interface ITrendChart extends VisiWin.UI.IControlBase {
        /**
        * series
        * The series obtains its data from the VisiWin system module Trends
        * @member VisiWin.UI.Series[]  series
        **/
        series: VisiWin.UI.Series[];
        /**
        * trendChartID
        * For the trend chart controller to identify the unique chart id.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } trendChartID
        **/
        trendChartID: string;
        /**
        * maxSamples
        * Specifies the maxSamples used in the trend chart.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } maxSamples
        **/
        maxSamples: number;
        /**
        * timeSpan
        * Specifies the timeSpan in minutes
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } timeSpan
        **/
        timeSpan: number;
        /**
        * trendOnline
        * Specifies whether the trend is online.
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } trendOnline
        **/
        trendOnline: boolean;
        /**
        * xaxisShow
        *  Specifies whether the x-axis is displayed
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } xaxisShow
        **/
        showXAxis: boolean;
        /**
        * xaxisPosition
        * Specifies the position of the x-axis(top/bottom).
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } xaxisPosition
        **/
        xaxisPosition: string;
        /**
        * xaxisFontSize
        * Specifies the size of the font on the x-axis(px).
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } xaxisFontSize
        **/
        xaxisFontSize: string;
        /**
        * xaxisFontWeight
        * Specifies the font weight on the x-axis.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } xaxisFontWeight
        **/
        xaxisFontWeight: string;
        /**
        * xaxisFontColor
        * Specifies the font color on the x-axis.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } xaxisFontColor
        **/
        xaxisFontColor: string;
        /**
        * xaxisTickColor
        * Specifies the tick color on the x-axis.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } xaxisTickColor
        **/
        xaxisTickColor: string;
        /**
        * xaxisLabelWidth
        * Specifies the label width for the x-axis.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } xaxisLabelWidth
        **/
        xaxisLabelWidth: number;
        /**
        * xaxisLabelHeight
        * Specifies the label height for the x-axis.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } xaxisLabelHeight
        **/
        xaxisLabelHeight: number;
        /**
        * xaxisTickLength
        * Specifies the length of the x-axis tick.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } xaxisTickLength
        **/
        xaxisTickLength: number;
        /**
        * xaxisShowMinMax
        * Specifies whether the minimum and maximum values are displayed on the x-axis
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } xaxisShowMinMax
        **/
        showXAxisMinMax: boolean;
        /**
        * showGrid
        * Turn off the whole grid including tick labels by setting ShowGrid to false.
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } showGrid
        **/
        showGrid: boolean;
        /**
        * gridAboveData
        * AboveData determines whether the grid is drawn above the data or below (below is default).
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } gridAboveData
        **/
        gridAboveData: boolean;
        /**
        * gridMargin
        * Specifies the grid margin
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } gridMargin
        **/
        gridMargin: string;
        /**
        * axisValueMargin
        * Specifies the label margin as the space in pixels between tick labels and axis line.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } axisValueMargin
        **/
        axisValueMargin: number;
        /**
        * yAxisMargin
        * Specifies the grid axis margin is the space in pixels between axes when there are two next to each other.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } yAxisMargin
        **/
        yAxisMargin: number;
        /**
        * gridBorderWidth
        * Specifies the grid border width.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } gridBorderWidth
        **/
        gridBorderWidth: number;
        /**
        * gridMinorTicks
        * Specifies the grid minor ticks.
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } gridMinorTicks
        **/
        gridMinorTicks: number;
        /**
        * gridMinorTicksWidth
        * Specifies the grid minor ticks width .
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } gridMinorTicksWidth
        **/
        gridMinorTicksWidth: number;
        /**
        * gridColor
        * Specifies the grid tick color.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } gridColor
        **/
        gridColor: string;
        /**
        * gridBackgroundColor
        * Specifies the grid background color.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } gridBackgroundColor
        **/
        gridBackgroundColor: string;
        /**
        * gridBorderColor
        * Specifies the grid border color.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } gridBorderColor
        **/
        gridBorderColor: string;
        /**
        * backgroundColor
        * Specifies the trend chart background color.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } backgroundColor
        **/
        backgroundColor: string;
        ChartDataRequestStarted: VisiWin.Internal.System.Events.IEventArgs<Trend.ITrendOptions[]>;
        ChartDataRequestCompleted: VisiWin.Internal.System.Events.IEventArgs<Trend.ITrendOptions[]>;
    }
}
declare namespace VisiWin.UI.Trend {
    /** @ignore */
    export type LegendDataContent = {
        label: string;
        color: string;
    };
    /** @ignore */
    export const XAxisPosition: {
        Bottom: string;
        Top: string;
    };
    /** @ignore */
    export interface ArchiveTrendProvider extends VisiWin.Internal.System.BaseClass {
        Name: string;
        TrendNames: string[];
        LocalizableText: string;
        TrendDataRecorded: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.ITrendDataRecordedEventArgs>;
        TrendsDataRecorded: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.ITrendsDataRecordedEventArgs>;
        GetTrendDataCompleted: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.IGetTrendDataCompletedEventArgs>;
        GetTrendsDataCompleted: VisiWin.Internal.System.Events.IEventArgs<VisiWin.System.Trend.IGetTrendsDataCompletedEventArgs>;
        GetTrend(trendName: string): VisiWin.System.Trend.ITrend;
        GetTrendData(requestID: string, minTime: Date, maxTime: Date, trendName: string, maxSamples: number): Promise<VisiWin.System.Trend.ITrendDataPromise>;
        GetTrendsData(requestID: string, minTime: Date, maxTime: Date, trendNames: string[], maxSamples: number): Promise<VisiWin.System.Trend.ITrendDataPromise>;
        GetTrendDataAsync(requestID: string, minTime: Date, maxTime: Date, trendNames: string[], maxSamples: number): Promise<VisiWin.IGuid>;
        GetTrendData2(requestID: string, minTime: Date, maxTime: Date, trendNames: string[], maxSamples: number): Promise<VisiWin.IGuid>;
        SetTrendOnlineState(requestID: string, state: VisiWin.System.Trend.SetTrendOnlineState): Promise<VisiWin.System.Trend.ISetTrendOnlineStatePromise>;
        InitializeTrends(trendNames: string[]): Promise<VisiWin.System.Trend.IInitializeTrendsPromise>;
    }
    /** @ignore */
    export interface IInitTrend {
        DateMax: Date;
        TimeSpan: number;
        TrendOnline: boolean;
        MaxSamples: number;
    }
    /** @ignore */
    export interface ITrendOptions {
        ArchiveName: string;
        TrendNames: string[];
        DateMax: Date;
        TimeSpan: number;
        TrendOnline: boolean;
        MaxSamples: number;
    }
    /** @ignore */
    export interface TrendProvider {
        Archive: ArchiveTrendProvider;
        ArchiveName: string;
        Trends: VisiWin.System.Trend.ITrend[];
        TrendNames: string[];
        MaxDate: Date;
        MinDate: Date;
        TimeSpan: number;
        TrendOnline: boolean;
        MaxSamples: number;
        DataSamplesUpdate: VisiWin.Internal.System.Events.IMessageEvent;
        OnTrendProviderError: VisiWin.Internal.System.Events.IMessageEvent;
        SetMaxTime(e: Date): void;
        SetTimeSpan(timeSpan: number): void;
        TrendOnlineState(online: boolean): void;
        _updateChartData(): void;
        _getTrendDatafromArchive(): void;
        _handleSampleArray(e: VisiWin.System.Trend.IGetTrendsDataCompletedEventArgs): any[];
        _onNewDataSample(e: any): void;
        _handleSampleSingle(e: any): any[];
        init(): void;
        detach(): void;
        dispose(): void;
        unload(): void;
        TrendDataRequestCompleted: VisiWin.Internal.System.Events.IMessageEvent;
        TrendDataRequestStarted: VisiWin.Internal.System.Events.IMessageEvent;
    }
    /** @ignore */
    /** @ignore */
    export type TrendChartDataset = {
        data?: any;
        color?: string;
        yaxis?: number;
        label?: string;
        lines?: Line;
        archiveName: string;
        trendName: string;
        points?: {
            radius?: number | undefined;
            symbol?: any;
            show?: boolean | undefined;
            lineWidth?: number | undefined;
            fill?: any;
            fillColor?: any;
        } | undefined;
    };
    /** @ignore */
    /** @ignore */
    type Line = {
        show?: boolean;
        lineWidth?: string;
        fill?: string;
        zero?: number;
        steps?: number;
        color?: string;
        fillColor?: string;
    };
    export {};
}
/** @ignore */
declare namespace VisiWin.UI {
    class TrendChart extends VisiWin.UI.ControlBase implements VisiWin.UI.ITrendChart {
        private properties;
        private cssStyles;
        series: VisiWin.UI.Series[];
        stopTrendOnPan: boolean;
        stopTrendOnZoom: boolean;
        zoomTimeOnly: boolean;
        showLoadingSymbolDuringRequest: boolean;
        trendChartID: string;
        maxSamples: any;
        timeSpan: number;
        private _trendOnline;
        get trendOnline(): boolean;
        set trendOnline(value: boolean);
        ChartDataRequestStarted: VisiWin.Internal.System.Events.IEventArgs<Trend.ITrendOptions[]>;
        ChartDataRequestCompleted: VisiWin.Internal.System.Events.IEventArgs<Trend.ITrendOptions[]>;
        private _requestCounter;
        _createProviderOptionsEventArgs(provider: Trend.TrendProvider): Trend.ITrendOptions;
        _trendDataRequestStarted(e: Trend.ITrendOptions): void;
        private _trendDataRequestStartedHandler;
        _trendDataRequestCompleted(e: Trend.ITrendOptions): Promise<void>;
        private _trendDataRequestCompletedHandler;
        showXAxis: boolean;
        xaxisPosition: string;
        xaxisFontSize: string;
        xaxisFontWeight: string;
        xaxisAutoscaleMargin: number;
        xaxisTicks: number;
        xaxisLabelWidth: number;
        xaxisLabelHeight: number;
        xaxisTickLength: number;
        showXAxisMinMax: boolean;
        dateTimeMode: string;
        formatDate: string;
        formatTime: string;
        private _xaxisTimeFormat;
        get xaxisTimeFormat(): string;
        set xaxisTimeFormat(value: string);
        showGrid: boolean;
        showMinorTicks: boolean;
        gridAboveData: boolean;
        gridMargin: string;
        /**
        * @deprecated do not use
        * use axisValueMargin
        * @ignore
        */
        private gridLabelMargin;
        axisValueMargin: number;
        /**
        * @deprecated do not use
        * use yAxisMargin
        * @ignore
        */
        private gridAxisMargin;
        yAxisMargin: number;
        gridBorderWidth: number;
        gridMinBorderMargin: number;
        gridMinorTicks: number;
        gridMinorTicksWidth: number;
        private panInteractive;
        private zoomInteractive;
        private panCursor;
        private pinchAmount;
        backgroundColor: string;
        xaxisFontColor: string;
        xaxisTickColor: string;
        yaxisTickColor: string;
        gridColor: string;
        gridBackgroundColor: string;
        gridBorderColor: string;
        gridMarkingsColor: string;
        gridMinorTicksColor: string;
        private _trendChart;
        private _trendChartOptions;
        private _trendChartDataset;
        private _dateMax;
        private _trendProviders;
        private _trendProviderOptions;
        private _trendProviderTimeout;
        private _refreshRate;
        private _xaxis;
        private _yaxes;
        private _grid;
        private refreshRate;
        private _intervalID;
        private _refreshRateTimeout;
        private _showOnlineOnce;
        private _showOfflineOnce;
        private coreElement;
        private _boundSeriesChanged;
        private TrendChartPlugins;
        private disableControlsOnDataRequest;
        private showLoadingSymbolOnDataRequest;
        private loadingOverlaySymbol;
        private loadingOverlayBackgroundColor;
        private loadingOverlayForegroundColor;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        private _onSeriesChanged;
        private _areSeriesValid;
        private _validateSeries;
        private _createChartCoreElement;
        private _pandragEvent;
        private _pinchdragEvent;
        private _doubletapEvent;
        private _dblclickEvent;
        private _wheelEvent;
        private _dragstartEvent;
        _handleTimeOnlyZoom(): void;
        _addPlugInEventHandler(): void;
        _removePlugInEventHandler(): void;
        private findDateFormat;
        private _setChartOptions;
        private _setXAxisOptions;
        private _setYAxesOptions;
        private _setLineOptions;
        private _gridMinorTicksMarkings;
        private _setGridOptions;
        private _validateProperty;
        private _validateColorProperty;
        private _validateStringProperty;
        private _validateMarginProperty;
        private _validateFontProperty;
        private _drawTrendChart;
        private _getDesignTimeData;
        private _boundDataSamplesAllproviders;
        private _onDataSamplesAllproviders;
        private _updateTrendChart;
        private _drawWithUpdateInterval;
        private _calculateRefreshRate;
        private _setTrendProviderOptions;
        private _updateTrendProvider;
        private _refreshTrendProvider;
        private _setTouchHandler;
        private _removeTouchHandler;
        _moveFromAction(args: {
            type: any;
            pointerType: any;
            left: string | number;
            top: string | number;
        }): void;
        moveForward(): void;
        moveFastForward(): void;
        moveBackward(): void;
        moveFastBackward(): void;
        refresh(): void;
        setTimespan(timeSpan: string | number): void;
        registerChild(controlType: string, action: string, propertyElement: VWElement): any;
        createHandler(): void;
        removeHandler(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        onLanguageChanged(args: any): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI.Trend {
    /** @ignore */
    type JQuery = any;
    /** @ignore */
    type JQueryCoordinates = any;
    /** @ignore */
    export interface Plugin {
        init(options: ITrendChartCorePlotOptions): any;
        options?: any;
        name?: string | undefined;
        version?: string | undefined;
    }
    /** @ignore */
    interface point {
        x: number;
        y: number;
    }
    /** @ignore */
    interface hooks {
        processOptions?: {
            (plot: ITrendChartCorePlot, options: ITrendChartCorePlotOptions): void;
        }[] | undefined;
        processRawData?: {
            (plot: ITrendChartCorePlot, series: DataSeries, data: any[], datapoints: number[]): void;
        }[] | undefined;
        processDatapoints?: {
            (plot: ITrendChartCorePlot, series: DataSeries, datapoints: number[]): void;
        }[] | undefined;
        processOffset?: {
            (plot: ITrendChartCorePlot, offset: canvasPoint): void;
        }[] | undefined;
        drawBackground?: {
            (plot: ITrendChartCorePlot, context: CanvasRenderingContext2D): void;
        }[] | undefined;
        drawSeries?: {
            (plot: ITrendChartCorePlot, context: CanvasRenderingContext2D, series: DataSeries): void;
        }[] | undefined;
        draw?: {
            (plot: ITrendChartCorePlot, context: CanvasRenderingContext2D): void;
        }[] | undefined;
        bindEvents?: {
            (plot: ITrendChartCorePlot, eventHolder: JQuery): void;
        }[] | undefined;
        drawOverlay?: {
            (plot: ITrendChartCorePlot, context: CanvasRenderingContext2D): void;
        }[] | undefined;
        shutdown?: {
            (plot: ITrendChartCorePlot, eventHolder: JQuery): void;
        }[] | undefined;
    }
    /** @ignore */
    interface interaction {
        redrawOverlayInterval?: number | undefined;
    }
    /** @ignore */
    interface legendOptions {
        show?: boolean | undefined;
        labelFormatter?: ((label: string, series: any) => string) | undefined;
        labelBoxBorderColor?: any;
        noColumns?: number | undefined;
        position?: string | undefined;
        margin?: any;
        backgroundColor?: any;
        backgroundOpacity?: number | undefined;
        container?: JQuery | undefined;
        sorted?: any;
    }
    /** @ignore */
    interface SeriesTypeBase {
        show?: boolean | undefined;
        lineWidth?: number | undefined;
        fill?: any;
        fillColor?: any;
    }
    /** @ignore */
    interface PointsOptions extends SeriesTypeBase {
        radius?: number | undefined;
        symbol?: any;
    }
    /** @ignore */
    interface canvasPoint {
        top: number;
        left: number;
        bottom?: number | undefined;
        right?: number | undefined;
    }
    /** @ignore */
    interface SeriesOptions {
        color?: any;
        label?: string | undefined;
        lines?: any | undefined;
        bars?: any | undefined;
        points?: PointsOptions | undefined;
        xaxis?: number | undefined;
        yaxis?: number | undefined;
        clickable?: boolean | undefined;
        hoverable?: boolean | undefined;
        shadowSize?: number | undefined;
        highlightColor?: any;
    }
    /** @ignore */
    interface Item {
        datapoint: number[];
        dataIndex: number;
        series: DataSeries;
        seriesIndex: number;
        pageX: number;
        pageY: number;
    }
    /** @ignore */
    interface Offset {
        left: number;
        top: number;
    }
    /** @ignore */
    interface Axes {
        xaxis: Axis;
        yaxis: Axis;
        x2axis?: Axis | undefined;
        y2axis?: Axis | undefined;
        min: number;
        max: number;
    }
    /** @ignore */
    interface Axis extends ITrendChartCoreAxisOptions {
        options: ITrendChartCoreAxisOptions;
        p2c(point: any): any;
        c2p(canvasPoint: any): any;
    }
    /** @ignore */
    export interface DataSeries extends SeriesOptions {
        data: any[];
    }
    /** @ignore */
    export interface ITrendChartCorePlot {
        highlight(series: DataSeries, datapoint: Item): void;
        unhighlight(): void;
        unhighlight(series: DataSeries, datapoint: Item): void;
        setData(data: any): void;
        setupGrid(autoScale?: any): void;
        draw(): void;
        triggerRedrawOverlay(): void;
        width(): number;
        height(): number;
        offset(): JQueryCoordinates;
        pointOffset(point: point): Offset;
        resize(): void;
        shutdown(): void;
        getData(): DataSeries[];
        getAxes(): Axes;
        getXAxes(): Axis[];
        getYAxes(): Axis[];
        getPlaceholder(): JQuery;
        getCanvas(): HTMLCanvasElement;
        getSurface(): any;
        getEventHolder(): HTMLCanvasElement;
        getPlotOffset(): any;
        getOptions(): ITrendChartCorePlotOptions;
        destroy(): any;
        onSizeChanged(width: string, height: string): any;
    }
    /** @ignore */
    export interface ITrendChartCoreAxisOptions {
        show?: boolean | undefined;
        position?: string | undefined;
        mode?: string | undefined;
        monthNames?: string[] | undefined;
        color?: any;
        tickColor?: any;
        font?: any;
        min?: number | undefined;
        max?: number | undefined;
        autoscaleMargin?: number | undefined;
        autoScaleMargin?: number | undefined;
        autoScale?: string;
        windowSize?: number;
        growOnly?: any;
        showTickLabels?: string;
        showMinorTicks?: boolean;
        showTicks?: boolean;
        gridLines?: boolean;
        offset?: any;
        boxPosition?: any;
        transform?: ((v: number) => number) | undefined;
        inverseTransform?: ((v: number) => number) | undefined;
        noTicks?: any;
        ticks?: any;
        tickSize?: any;
        minTickSize?: any;
        tickFormatter?: ((t: number, a?: Axis) => string) | undefined;
        tickDecimals?: number | undefined;
        labelWidth?: number | undefined;
        labelHeight?: number | undefined;
        reserveSpace?: boolean | undefined;
        tickLength?: number | undefined;
        alignTicksWithAxis?: number | undefined;
        timezone?: string | undefined;
        timeformat?: string | undefined;
        twelveHourClock?: boolean | undefined;
        zoomRange?: any;
        panRange?: any;
    }
    /** @ignore */
    export interface ITrendChartCorePlotOptions {
        colors?: any[] | undefined;
        series?: SeriesOptions | undefined;
        legend?: legendOptions | undefined;
        xaxis?: ITrendChartCoreAxisOptions | undefined;
        yaxis?: ITrendChartCoreAxisOptions | undefined;
        xaxes?: ITrendChartCoreAxisOptions[] | undefined;
        yaxes?: ITrendChartCoreAxisOptions[] | undefined;
        grid?: ITrendChartCoreGridOptions | undefined;
        pinch?: any;
        interaction?: interaction | undefined;
        hooks?: hooks | undefined;
    }
    /** @ignore */
    export interface ITrendChartCoreGridOptions {
        show?: boolean | undefined;
        aboveData?: boolean | undefined;
        color?: any;
        backgroundColor?: any;
        margin?: any;
        labelMargin?: number | undefined;
        axisMargin?: number | undefined;
        markings?: any;
        borderWidth?: any;
        borderColor?: any;
        minBorderMargin?: number | undefined;
        clickable?: boolean | undefined;
        hoverable?: boolean | undefined;
        autoHighlight?: boolean | undefined;
        mouseActiveRadius?: number | undefined;
        tickColor?: any;
        markingsColor?: any;
        markingsLineWidth?: number | undefined;
        minorTicks?: any;
        minorTicksColor?: any;
    }
    export {};
}
declare namespace VisiWin.UI.TrendHelper {
    class TrendChartCore extends VisiWin.UI.ControlBase {
        properties: {
            designerType: {
                propertyType: string;
                defaultValue: string;
            };
        };
        cssStyles: {
            coreStyle: boolean;
            css: string;
        };
        constructor(element: any, options: any);
        init(placeholder: any, data: any, options: any, plugins: any): Flot;
    }
}
declare namespace VisiWin.UI.TrendHelper {
    var Plot: any;
    class Flot {
        constructor(placeholder: any, data: any, options: any, plugins: any);
        static Canvas: typeof Canvas;
        static defaultTickGenerator(axis: any): any[];
        static defaultTickFormatter(value: any, axis: any, precision: any): string;
        static expRepTickFormatter(value: any, axis: any, precision: any): string;
        static recomputePrecision(num: any, precision: any): number;
        Plot(placeholder: any, data_: any, options_: any, plugins: any): void;
    }
    interface Plot {
        [index: string]: any;
    }
}
declare namespace VisiWin.UI.TrendHelper {
    function Canvas(this: any, cls: any, container: any): void;
}
declare namespace VisiWin.UI.TrendHelper {
    let PlotPlugIns: any[];
    function deepExtend(out: any, ...arguments_: any[]): any;
    function addEventListener(el: any, eventName: any, eventHandler: any, selector: any): (e: any) => void;
    function extend(this: any, args1?: any, args2?: any, args3?: any, args4?: any): any;
    function each(obj: any, callback: any, args?: any): any;
    function grep(elems: any[], callback: any, inv?: any): any[];
    function bodyOffset(element: HTMLElement): {
        top: number;
        left: number;
    };
    function offset(element: any): {
        top: number;
        left: number;
    };
}
declare namespace VisiWin.UI.TrendHelper.ColorHelper {
    const color: any;
}
declare namespace VisiWin.UI.TrendHelper {
    class Saturated {
        constructor();
        static saturated: {
            saturate: (a: any) => any;
            delta: (min: any, max: any, noTicks: any) => number;
            multiply: (a: any, b: any) => any;
            multiplyAdd: (a: any, bInt: any, c: any) => any;
            floorInBase: (n: any, base: any) => number;
        };
    }
}
declare namespace VisiWin.UI.TrendHelper {
}
declare namespace VisiWin.UI.TrendHelper.Browser {
    let browser: {
        getPageXY: (e: any) => {
            X: number;
            Y: number;
        };
        getPixelRatio: (context: any) => number;
    };
}
declare namespace VisiWin.UI.TrendHelper {
    class DrawSeries {
        constructor();
        plotLine(datapoints: any, xoffset: any, yoffset: any, axisx: any, axisy: any, ctx: any, steps: any): void;
        plotLineArea(datapoints: any, axisx: any, axisy: any, fillTowards: any, ctx: any, steps: any): void;
        drawSeriesLines(series: any, ctx: any, plotOffset: any, plotWidth: any, plotHeight: any, drawSymbol: any, getColorOrGradient: any): void;
        drawSeriesPoints(series: any, ctx: any, plotOffset: any, plotWidth: any, plotHeight: any, drawSymbol: any, getColorOrGradient: any): void;
        drawBar(x: any, y: any, b: any, barLeft: any, barRight: any, fillStyleCallback: any, axisx: any, axisy: any, c: any, horizontal: any, lineWidth: any): void;
        drawSeriesBars(series: any, ctx: any, plotOffset: any, plotWidth: any, plotHeight: any, drawSymbol: any, getColorOrGradient: any): void;
        getFillStyle(filloptions: any, seriesColor: any, bottom: any, top: any, getColorOrGradient: any): any;
    }
}
/**
## jquery.flot.navigate.js

This flot plugin is used for adding the ability to pan and zoom the plot.
A higher level overview is available at [interactions](interactions.md) documentation.

The default behaviour is scrollwheel up/down to zoom in, drag
to pan. The plugin defines plot.zoom({ center }), plot.zoomOut() and
plot.pan( offset ) so you easily can add custom controls. It also fires
"plotpan" and "plotzoom" events, useful for synchronizing plots.

The plugin supports these options:
```js
    zoom: {
        interactive: false,
        active: false,
        amount: 1.5         // 2 = 200% (zoom in), 0.5 = 50% (zoom out)
    }

    pan: {
        interactive: false,
        active: false,
        cursor: "move",     // CSS mouse cursor value used when dragging, e.g. "pointer"
        frameRate: 60,
        mode: "smart"       // enable smart pan mode
    }

    xaxis: {
        axisZoom: true, //zoom axis when mouse over it is allowed
        plotZoom: true, //zoom axis is allowed for plot zoom
        axisPan: true, //pan axis when mouse over it is allowed
        plotPan: true, //pan axis is allowed for plot pan
        panRange: [undefined, undefined], // no limit on pan range, or [min, max] in axis units
        zoomRange: [undefined, undefined], // no limit on zoom range, or [closest zoom, furthest zoom] in axis units
    }

    yaxis: {
        axisZoom: true, //zoom axis when mouse over it is allowed
        plotZoom: true, //zoom axis is allowed for plot zoom
        axisPan: true, //pan axis when mouse over it is allowed
        plotPan: true //pan axis is allowed for plot pan
        panRange: [undefined, undefined], // no limit on pan range, or [min, max] in axis units
        zoomRange: [undefined, undefined], // no limit on zoom range, or [closest zoom, furthest zoom] in axis units
    }
```
**interactive** enables the built-in drag/click behaviour. If you enable
interactive for pan, then you'll have a basic plot that supports moving
around; the same for zoom.

**active** is true after a touch tap on plot. This enables plot navigation.
Once activated, zoom and pan cannot be deactivated. When the plot becomes active,
"plotactivated" event is triggered.

**amount** specifies the default amount to zoom in (so 1.5 = 150%) relative to
the current viewport.

**cursor** is a standard CSS mouse cursor string used for visual feedback to the
user when dragging.

**frameRate** specifies the maximum number of times per second the plot will
update itself while the user is panning around on it (set to null to disable
intermediate pans, the plot will then not update until the mouse button is
released).

**mode** a string specifies the pan mode for mouse interaction. Accepted values:
'manual': no pan hint or direction snapping;
'smart': The graph shows pan hint bar and the pan movement will snap
to one direction when the drag direction is close to it;
'smartLock'. The graph shows pan hint bar and the pan movement will always
snap to a direction that the drag diorection started with.

Example API usage:
```js
    plot = $.plot(...);

    // zoom default amount in on the pixel ( 10, 20 )
    plot.zoom({ center: { left: 10, top: 20 } });

    // zoom out again
    plot.zoomOut({ center: { left: 10, top: 20 } });

    // zoom 200% in on the pixel (10, 20)
    plot.zoom({ amount: 2, center: { left: 10, top: 20 } });

    // pan 100 pixels to the left (changing x-range in a positive way) and 20 down
    plot.pan({ left: -100, top: 20 })
```

Here, "center" specifies where the center of the zooming should happen. Note
that this is defined in pixel space, not the space of the data points (you can
use the p2c helpers on the axes in Flot to help you convert between these).

**amount** is the amount to zoom the viewport relative to the current range, so
1 is 100% (i.e. no change), 1.5 is 150% (zoom in), 0.7 is 70% (zoom out). You
can set the default in the options.
*/
declare namespace VisiWin.UI.TrendHelper.navigate {
    var options: {
        zoom: {
            interactive: boolean;
            active: boolean;
            amount: number;
        };
        pan: {
            interactive: boolean;
            active: boolean;
            cursor: string;
            frameRate: number;
            mode: string;
        };
        recenter: {
            interactive: boolean;
        };
        xaxis: {
            axisZoom: boolean;
            plotZoom: boolean;
            axisPan: boolean;
            plotPan: boolean;
            panRange: any[];
            zoomRange: any[];
        };
        yaxis: {
            axisZoom: boolean;
            plotZoom: boolean;
            axisPan: boolean;
            plotPan: boolean;
            panRange: any[];
            zoomRange: any[];
        };
    };
    function init(plot: any): void;
}
declare namespace VisiWin.UI.TrendHelper.Time {
    var options: {
        xaxis: {
            timezone: any;
            timeformat: any;
            twelveHourClock: boolean;
            monthNames: any;
            timeBase: string;
        };
        yaxis: {
            timeBase: string;
        };
    };
    function formatDate(d: any, fmt: any, monthNames: any, dayNames: any): any;
    function makeUtcWrapper(d: any): {
        date: any;
    };
    function dateGenerator(ts: any, opts: any): any;
    function dateTickGenerator(axis: any): any[];
    function init(plot: any): void;
}
declare namespace VisiWin.UI.TrendHelper.navigateTouch {
    var options: {
        propagateSupportedGesture: boolean;
    };
    function init(plot: any): void;
}
declare namespace VisiWin.UI.TrendHelper.navigateTouch2 {
    var options: {
        zoom: {
            enableTouch: boolean;
        };
        pan: {
            enableTouch: boolean;
            touchMode: string;
        };
        recenter: {
            enableTouch: boolean;
        };
    };
    function init(plot: any): void;
}
declare namespace VisiWin.UI.TrendHelper.loadingOverlay {
    let options: {
        loadingOverlay: {
            show: boolean;
            backgroundColor: string;
            foregroundColor: string;
            loadingSpinner: string;
        };
    };
    function show(plot: any): void;
    function hide(plot: any): void;
    function init(plot: any): void;
}
declare module VisiWin.UI {
    interface IList extends VisiWin.UI.IControlBase {
        /**
         * constructor: Creates a new AlarmItem.
         * @constructor
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        constructor(element: HTMLElement, options: any): any;
        /**
         * constructorMethod: createControl
         * @createcontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        createControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeControl
         * @removecontrol
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        removeControl(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: createHandler
         * @createhandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        createHandler(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: removeHandler
         * @removehandler
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        removeHandler(): void;
        /**
         * constructorMethod: observe
         * @observe
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        observe(): void;
        /**
         * constructorMethod: preSetOptions
         * @presetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        preSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: postSetOptions
         * @postsetoptions
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        postSetOptions(element: HTMLElement, options: any): void;
        /**
         * constructorMethod: ready
         * @ready
         * @param element The DOM element that will host the control.
         * @param options The set of properties and values to apply to the new AlarmItem control.
        **/
        ready(element: HTMLElement, options: any): void;
        /**
         * style property / option
         * Gets the style of the Control.
         * The style is a free control sub group. It is used for different default options.
         * Datatype: string
         * Defaultvalue: null
        **/
        style: string;
        /**
         * foregroundColor property / option
         * Get and set the css style Property "color" of the corrosponding HTML Element.
         * The color property specifies the color of text.
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | auto | inherit | initial
        **/
        foregroundColor: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        /**
           * width property / option
           * Get and set the css style Property "width" of the corrosponding HTML Element.
           * The width property specifies the content width of boxes.
           * Datatype: string
           * Defaultvalue: auto
           * Valid values: <length> | <percentage> | auto | inherit
          **/
        width: string;
        /**
         * minWidth property / option
         * Get and set the css style Property "minwidth" of the corrosponding HTML Element.
         * The min-width property is used to set the minimum width of an element.
         * This prevents the value of the width property from becoming smaller than min-width.
         * Note: The value of the min-width property overrides both max-width and width.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | initial | inherit
        **/
        minWidth: string;
        /**
         * maxWidth property / option
         * Get and set the css style Property "maxWidth" of the corrosponding HTML Element.
         * The max-width property is used to set the maximum width of an element.
         * This prevents the value of the width property from becoming larger than max-width.
         * Note: The value of the max-width property overrides width.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        maxWidth: string;
        /**
         * height property / option
         * Get and set the css style Property "height" of the corrosponding HTML Element.
         * The height property sets the height of an element.
         * Note: The height property does not include padding, borders, or margins; it sets the height of the area inside the padding, border, and margin of the element!
         * Note: The min-height and max-height properties override height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        height: string;
        /**
         * minHeight property / option
         * Get and set the css style Property "minHeight" of the corrosponding HTML Element.
         * The min-height property is used to set the minimum height of an element.
         * This prevents the value of the height property from becoming smaller than min-height.
         * Note: The value of the min-height property overrides both max-height and height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        minHeight: string;
        /**
         * maxHeight property / option
         * Get and set the css style Property "maxHeight" of the corrosponding HTML Element.
         * The max-height property is used to set the maximum height of an element.
         * This prevents the value of the height property from becoming larger than max-height.
         * Note: The value of the max-height property overrides height.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit < initial
        **/
        maxHeight: string;
        /**
         * left property / option
         * Get and set the css style Property "left" of the corrosponding HTML Element.
         * For absolutely positioned elements, the left property sets the left edge of an element to a unit to the left/right of
         * the left edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is
         * anything except static. For relatively positioned elements, the left property sets the left edge of an element to a
         * unit to the left/right to its normal position. Note: If "position:static", the left property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        left: string;
        /**
         * top property / option
         * Get and set the css style Property "top" of the corrosponding HTML Element.
         * For absolutely positioned elements, the top property sets the top edge of an element to a unit above/below the top edge of
         * its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the document
         * body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except static.
         * For relatively positioned elements, the top property sets the top edge of an element to a unit above/below its normal position.
         * Note: If "position:static", the top property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: 	<length> | <percentage> | auto | inherit
        **/
        top: string;
        /**
         * right property / option
         * Get and set the css style Property "right" of the corrosponding HTML Element.
         * For absolutely positioned elements, the right property sets the right edge of an element to a unit to the left/right
         * of the right edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors,
         * it uses the document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything
         * except static. For relatively positioned elements, the right property sets the right edge of an element to a unit to the
         * left/right to its normal position. Note: If "position:static", the right property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        right: string;
        /**
         * bottom property / option
         * Get and set the css style Property "bottom" of the corrosponding HTML Element.
         * For absolutely positioned elements, the bottom property sets the bottom edge of an element to a unit above/below the bottom
         * edge of its nearest positioned ancestor. Note: If an absolute positioned element has no positioned ancestors, it uses the
         * document body, and moves along with page scrolling. Note: A "positioned" element is one whose position is anything except
         * static. For relatively positioned elements, the bottom property sets the bottom edge of an element to a unit above/below
         * its normal position. Note: If "position:static", the bottom property has no effect.
         * Datatype: string
         * Defaultvalue: auto
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        bottom: string;
        /**
         * margin property / option
         * Get and set the css style Property "margin" of the corrosponding HTML Element.
         * The margin shorthand property sets all the margin properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit
        **/
        margin: string;
        /**
         * padding property / option
         * Get and set the css style Property "padding" of the corrosponding HTML Element.
         * The padding shorthand property sets all the padding properties in one declaration. This property can have from one to four values.
         * The padding Property can have 1, 2 or 4 subpropertys
         * as one property: all for sub properties paddingTop, paddingRight, paddingButtom and paddingLrft will be set with this value
         * as two properies: paddingTop and paddingButtom will set with the first and paddingRight and paddingLeft will set with the second value
         * as for properties: paddingTop will set with firt, paddinLeft withThe second, paddingBottom with the third and PaddingLeft will set with the fourth sub property.
         * Note: Negative values are not allowed.
         * Datatype: string
         * Defaultvalue: 0
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        padding: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class List extends VisiWin.UI.ControlBase {
        private properties;
        private cssStyles;
        listItemsStyle: string;
        selectedIndex: number;
        selectionMode: string;
        selectedValue: string;
        listItemStyle: string;
        dataSource: any;
        template: any;
        backgroundColor: string;
        borderColor: string;
        private _itemsContainer;
        private _inlineItems;
        private _itemsLoaded;
        private _isInDesignMode;
        private _boundItemsLoaded;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        createHandler(): void;
        removeHandler(): void;
        observe: {
            "_itemsContainer.selectedIndex": (args: {
                oldValue: any;
                newValue: any;
            }) => void;
        };
        _onItemsLoaded(): void;
        _updateLayout(changes: {
            changeName: string;
        }): void;
        getListItemFromIndex(index: number): any;
    }
}
declare module VisiWin.UI {
    interface IMenuItem extends IButtonBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class MenuItem extends VisiWin.UI.ButtonBase implements IMenuItem {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            toggle: {
                propertyType: string;
                defaultValue: boolean;
            };
            radio: {
                propertyType: string;
                defaultValue: boolean;
            };
            padding: {
                propertyType: string;
                type: string;
                element: string;
                forceOverwrite: boolean;
            };
            transition: {
                propertyType: string;
                type: string;
            };
            containerBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerTransition: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            textWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            textPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            text: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                defaultValue: string;
            };
            localizableText: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            textAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            lineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            textWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            textTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            fontClass: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            fontSize: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            fontWeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            lineHeight: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
            };
            textContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            uppercase: {
                propertyType: string;
                type: string;
                child: string;
            };
            textPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        padding: string;
        transition: string;
        containerBorderWidth: string;
        containerBorderStyle: string;
        containerBorderRadius: string;
        containerTransition: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        showText: boolean;
        textWidth: string;
        textHeight: string;
        textMargin: string;
        textPadding: string;
        textAlignment: string;
        lineClamp: number;
        textWrapping: string;
        textTrimming: string;
        fontSize: string;
        lineHeight: string;
        textContrast: number;
        uppercase: boolean;
        textPosition: string;
        backgroundColor: string;
        hoverBackgroundColor: string;
        pressedBackgroundColor: string;
        checkedBackgroundColor: string;
        checkedHoverBackgroundColor: string;
        checkedPressedBackgroundColor: string;
        disabledBackgroundColor: string;
        foregroundColor: string;
        hoverForegroundColor: string;
        pressedForegroundColor: string;
        checkedForegroundColor: string;
        checkedHoverForegroundColor: string;
        checkedPressedForegroundColor: string;
        disabledForegroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        checkedBorderColor: string;
        checkedHoverBorderColor: string;
        disabledBorderColor: string;
        private _containerElement;
        private _symbolElement;
        private _textElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ColorIndicator extends VisiWin.UI.VariableBase {
        static namespace: string;
        static controlName: string;
        static classColorIndicator: string;
        static ColorIndicatorPropertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            limits: {
                propertyType: string;
                type: string;
            };
            colorStateCollection: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        borderColor: string;
        disabledBorderColor: string;
        limits: string;
        colorStateCollection: string;
        private limitsCollection;
        private boundLimitsChangedHandler;
        constructor(element: VWElement, options: any);
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        ready(): void;
        private _backgroundColor;
        get backgroundColor(): any;
        set backgroundColor(value: any);
        private _disabledBackgroundColor;
        get disabledBackgroundColor(): any;
        set disabledBackgroundColor(value: any);
        _limitsChangedHandler(args: any): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ColorIndicatorLimit extends VisiWin.UI.ProviderBase {
        static namespace: string;
        static controlName: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            value: {
                propertyType: string;
                type: string;
            };
            fillColor: {
                propertyType: string;
                type: string;
            };
        };
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class BarCore extends VisiWin.UI.VariableBase {
        private properties;
        private cssStyles;
        backgroundColor: string;
        indicatorColor: string;
        rawLimitMin: number;
        rawLimitMax: number;
        limits: any;
        rawReferenceValue: number;
        direction: string;
        private _indicatorElement;
        private _limitsCollection;
        private _clientWidth;
        private _clientHeight;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        registerChild(controlType: string, action: string, limit: VWElement, options: any): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _drawBar(): void;
        _limitsChangedHandler(args: any): void;
    }
}
declare namespace VisiWin.UI {
    class Bar extends VisiWin.UI.VariableBase {
        private properties;
        private cssStyles;
        rawLimitMin: number;
        rawLimitMax: number;
        limits: any;
        rawReferenceValue: number;
        alignItems: string;
        justifyContent: string;
        direction: string;
        barWidth: string;
        barHeight: string;
        barMargin: string;
        barPadding: string;
        showRanges: boolean;
        showAllRanges: boolean;
        showScale: boolean;
        scaleWidth: string;
        scaleHeight: string;
        scaleMargin: string;
        scalePadding: string;
        scaleMode: string;
        scalePosition: string;
        scalePlacement: string;
        showScaleBaseLine: boolean;
        scaleLimitsVisibility: string;
        showMajorTicks: boolean;
        majorStepSize: number;
        majorSteps: number;
        majorTicksLength: number;
        majorTicksWidth: number;
        showMiddleTicks: boolean;
        middleStepSize: number;
        middleSteps: number;
        middleTicksLength: number;
        middleTicksWidth: number;
        showMinorTicks: boolean;
        minorStepSize: number;
        minorSteps: number;
        minorTicksLength: number;
        minorTicksWidth: number;
        showMajorLabels: boolean;
        majorLabelsFontClass: string;
        majorLabelsFontSize: string;
        majorLabelsFontWeight: string;
        majorLabelsLineHeight: string;
        majorLabelsTextContrast: number;
        majorLabelsOffset: number;
        majorLabelsDecimalPlaces: number;
        showValueLabel: boolean;
        valueLabelBorderWidth: string;
        valueLabelBorderStyle: string;
        valueLabelBorderRadius: string;
        valueLabelWidth: string;
        valueLabelHeight: string;
        valueLabelMargin: string;
        valueLabelPadding: string;
        valueLabelPosition: string;
        valueLabelOffset: number;
        showValue: boolean;
        valueWidth: string;
        valueHeight: string;
        valueMargin: string;
        valuePadding: string;
        valueTextAlignment: string;
        valueLineClamp: number;
        valueTextWrapping: string;
        valueTextTrimming: string;
        valueFontClass: string;
        valueFontSize: string;
        valueFontWeight: string;
        valueLineHeight: string;
        valueTextContrast: number;
        showUnit: boolean;
        unitWidth: string;
        unitHeight: string;
        unitMargin: string;
        unitPadding: string;
        unitTextAlignment: string;
        unitLineClamp: number;
        unitTextWrapping: string;
        unitTextTrimming: string;
        unitFontClass: string;
        unitFontSize: string;
        unitFontWeight: string;
        unitLineHeight: string;
        unitTextContrast: number;
        unitPosition: string;
        barBackgroundColor: string;
        valueLabelBackgroundColor: string;
        rangeBackgroundColor: string;
        scaleBackgroundColor: string;
        disabledBarBackgroundColor: string;
        disabledValueLabelBackgroundColor: string;
        disabledRangeBackgroundColor: string;
        disabledScaleBackgroundColor: string;
        valueForegroundColor: string;
        unitForegroundColor: string;
        scaleForegroundColor: string;
        majorTicksColor: string;
        middleTicksColor: string;
        minorTicksColor: string;
        disabledForegroundColor: string;
        valueLabelBorderColor: string;
        disabledBorderColor: string;
        barIndicatorColor: string;
        disabledBarIndicatorColor: string;
        private _containerElement;
        private _scaleControl;
        private _barCoreControl;
        private _rangeControl;
        private _valueLabelControl;
        private _limitsCollection;
        private _valuePresenterUnit;
        private _boundBarIndicatorChangedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        createHandler(): void;
        removeHandler(): void;
        registerChild(controlType: string, action: string, limit: VWElement, options: any): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _showValueToBar(posX: number, posY: number, value: number): void;
        _limitsChangedHandler(args: any): void;
        _barIndicatorChangedHandler(args: {
            detail: {
                posX: number;
                posY: number;
                value: number;
            };
        }): void;
    }
}
declare namespace VisiWin.UI {
    class BarLimit extends VisiWin.UI.ProviderBase {
        static namespace: string;
        static controlName: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            startValue: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            endValue: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            fillColor: {
                propertyType: string;
                type: string;
            };
        };
        constructor(element: VWElement, options: any);
    }
}
declare module VisiWin.UI {
    class PieCore extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static classPieCore: string;
        static PieCorePropertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            centerX: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            centerY: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            innerRadius: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            outerRadius: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            segments: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
        };
        backgroundColor: string;
        disabledBackgroundColor: string;
        centerX: string;
        centerY: string;
        innerRadius: string;
        outerRadius: string;
        segments: any;
        private _svgElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        resizeHandler(): void;
        beforeInit(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _drawPath(centerX: any, centerY: any, startAngle: any, endAngle: any, degreesSegment: any, innerRadius: any, outerRadius: any, color: any): any;
        _getPixelValue(requiredValue: any, totalValue: any): number;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class PieSegment extends VisiWin.UI.VariableBase {
        static namespace: string;
        static controlName: string;
        static PieSegmentPropertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            innerRadius: {
                propertyType: string;
                type: string;
            };
            outerRadius: {
                propertyType: string;
                type: string;
            };
            fillColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            decimalPlaces: {
                propertyType: string;
                type: string;
            };
        };
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class PieChart extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static classPieChart: string;
        static PieChartPropertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            pieWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            pieHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            pieMargin: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            piePadding: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            innerRadius: {
                propertyType: string;
                type: string;
                child: string;
            };
            outerRadius: {
                propertyType: string;
                type: string;
                child: string;
            };
            segments: {
                propertyType: string;
                type: string;
            };
            showLegend: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            legendBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendMargin: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendPadding: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            legendAlignment: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            template: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            legendBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            legendBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledLegendBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledLegendBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        foregroundColor: string;
        backgroundColor: string;
        borderColor: string;
        legendBorderColor: string;
        legendBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBackgroundColor: string;
        disabledBorderColor: string;
        disabledLegendBorderColor: string;
        disabledLegendBackgroundColor: string;
        segments: string;
        showLegend: boolean;
        legendPosition: string;
        legendAlignment: string;
        private _pieElement;
        private _legendElement;
        private segmentsCollection;
        private boundSegmentsChangedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        ready(): void;
        _segmentsChangedHandler(changes: any): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class PieLegend extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static classPieLegend: string;
        static PieLegendPropertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            template: {
                propertyType: string;
                type: string;
            };
            segments: {
                propertyType: string;
                type: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        foregroundColor: string;
        backgroundColor: string;
        borderColor: string;
        disabledForegroundColor: string;
        disabledBackgroundColor: string;
        disabledBorderColor: string;
        segments: any;
        private _repeaterElement;
        private bindingList;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        beforeInit(): void;
        ready(element: VWElement): void;
        private _template;
        get template(): string;
        set template(value: string);
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _setDesignerType(element: any): void;
        dispose(): boolean;
    }
}
/**
*  module VisiWin.UI.Symbol                                UIControl
*
*  Funktion:
*      Darstellung eines Symbols.
*
*  Abgeleitet von:
*      ControlBase
*
*  Constructor Parameter:
*      Bei der Definition von UI.Control üblichen zwei Parameter werden an die Basisklasse
*      weitergegeben:
*      element:HTMLElement     HTML Element auf dem das Control angewendet werden soll.
*      options:any             Object in dem die Options für das Control enthaltensind
*
*/
declare module VisiWin.UI {
    interface ISymbol extends IControlBase {
    }
}
declare namespace VisiWin.UI {
    class Symbol extends VisiWin.UI.ControlBase implements ISymbol {
        private properties;
        private cssStyles;
        show: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        symbolSize: string;
        backgroundColor: string;
        foregroundColor: string;
        borderColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        constructor(element: VWElement, options: any);
        beforeInit(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        private _getSymbolSize;
    }
}
declare module VisiWin.UI {
    interface IRadioButtonGroup extends VisiWin.UI.IControlBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class RadioButtonGroup extends VisiWin.UI.GroupBase implements VisiWin.UI.IRadioButtonGroup {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            orientation: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            wrap: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            showTitle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            titleWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titlePadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableTitleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            titleFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showSubtitle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            subtitleWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitlePadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableSubtitleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            subtitleFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            subtitleUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            titleForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            subtitleForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledTitleForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledSubtitleForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        orientation: string;
        alignItems: string;
        justifyContent: string;
        alignContent: string;
        wrap: boolean;
        showTitle: boolean;
        titleWidth: string;
        titleHeight: string;
        titleMargin: string;
        titlePadding: string;
        titleText: string;
        localizableTitleText: string;
        titleTextAlignment: string;
        titleLineClamp: number;
        titleTextWrapping: string;
        titleTextTrimming: string;
        titleFontClass: string;
        titleFontSize: string;
        titleFontWeight: string;
        titleLineHeight: string;
        titleTextContrast: number;
        titleUppercase: boolean;
        showSubtitle: boolean;
        subtitleWidth: string;
        subtitleHeight: string;
        subtitleMargin: string;
        subtitlePadding: string;
        subtitleText: string;
        localizableSubtitleText: string;
        subtitleTextAlignment: string;
        subtitleLineClamp: number;
        subtitleTextWrapping: string;
        subtitleTextTrimming: string;
        subtitleFontClass: string;
        subtitleFontSize: string;
        subtitleFontWeight: string;
        subtitleLineHeight: string;
        subtitleTextContrast: number;
        subtitleUppercase: boolean;
        backgroundColor: string;
        borderColor: string;
        titleForegroundColor: string;
        subtitleForegroundColor: string;
        disabledBackgroundColor: string;
        disabledBorderColor: string;
        disabledTitleForegroundColor: string;
        disabledSubtitleForegroundColor: string;
        private _containerElement;
        private _titleElement;
        private _subtitleElement;
        constructor(element: any, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    interface ITabBar extends VisiWin.UI.IControlBase {
        /**
        * @description Subset of the css align-items property.
        * @enum AlignItems
        * @see {@link VisiWin.UI.CSSProperties.alignItems|alignItems(Enum)} <br>
        */
        alignItems: string;
        /**
        * @description Subset of the css justify-content property.
        * @enum JustifyContent
        * @see {@link VisiWin.UI.CSSProperties.justifyContent|justifyContent(Enum)} <br>
        */
        justifyContent: string;
        /**
        * @description Subset of the css align-content property.
        * @enum AlignItems
        * @see {@link VisiWin.UI.CSSProperties.AlignItems|AlignItems(Enum)} <br>
        */
        alignContent: string;
        /**
        * @ignore
        */
        wrap: boolean;
        /**
        * @description Orientation of the TabBar: Vertical | Horizontal
        * @enum Orientation
        * @see {@link VisiWin.UI.Enums.Orientation|orientation(Enum)} <br>
        */
        orientation: string;
        /**
        * @description Wether to show the underline
        * @member { boolean } showUnderline
        */
        showUnderline: boolean;
        /**
        * @description Sets the height of the underline
        * @member { string } underlineHeight
        */
        underlineHeight: string;
        /**
        * @ignore
        */
        underlineTransition: string;
        /**
        * @description Wether the underline has the width of the tab or the content
        * @member { string } underlineMode
        */
        underlineMode: string;
        /**
        * @description Sets the page name of the starting tab
        * @member { string } startPageName
        */
        startPageName: string;
        /**
        * @description Sets the view name of the starting tab
        * @member { string } startViewName
        */
        startViewName: string;
        /**
        * @description Sets the ID for the region, in which the page or view should be displayed
        * @member { string } regionId
        */
        regionId: string;
    }
}
declare module VisiWin.UI {
    class TabBar extends VisiWin.UI.ControlBase implements ITabBar {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            wrap: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            orientation: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showUnderline: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            underlineHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            underlineTransition: {
                propertyType: string;
                type: string;
            };
            underlineMode: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            startPageName: {
                propertyType: string;
                type: string;
            };
            startViewName: {
                propertyType: string;
                type: string;
            };
            regionId: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            underlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledUnderlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            showLoadingSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        alignItems: string;
        justifyContent: string;
        alignContent: string;
        wrap: boolean;
        orientation: string;
        showUnderline: boolean;
        underlineHeight: string;
        underlineTransition: string;
        underlineMode: string;
        showLoadingSymbol: boolean;
        startPageName: string;
        startViewName: string;
        regionId: string;
        backgroundColor: string;
        borderColor: string;
        underlineColor: string;
        disabledBackgroundColor: string;
        disabledBorderColor: string;
        disabledUnderlineColor: string;
        private _underlineElement;
        private _regionElement;
        private _pageNavigatorElement;
        private _itemsCollection;
        private _menusCollection;
        private _underlineCollection;
        private _selectedItem;
        private _itemIndex;
        private _minMenuItemIndex;
        private _maxMenuItemIndex;
        private _boundItemsNotifyPropertyChangedHandler;
        private _boundItemsActionHandler;
        private _boundMenusActionHandler;
        private _boundRegionNavigatedHandler;
        private _boundPageNavigatorNavigatedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        resizeHandler(): void;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        ready(): void;
        _updateColors(): void;
        _updateLayout(changes: any): void;
        _registerItem(controlType: string, action: string, element: HTMLElement, options: any): boolean;
        _itemsNotifyPropertyChangedHandler(args: any): void;
        _itemsActionHandler(args: any): void;
        _menusActionHandler(args: any): void;
        _regionNavigatedHandler(args: any): void;
        _pageNavigatorNavigatedHandler(args: any): void;
        _checkIfListContains(csvList: string, target: string): boolean;
        _setNavigation(): void;
        _unselectItems(): void;
        _showHideMenu(): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IDivider extends VisiWin.UI.IControlBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Divider extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Div extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IProgress extends VisiWin.UI.IVariableBase {
        min: number;
        max: number;
        step: number;
        secondaryProgressValue: number;
        indeterminate: boolean;
        activeProgressColor: string;
        secondaryProgressColor: string;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Progress extends VisiWin.UI.VariableBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static ProgressOptionsList: {
            min: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            max: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            step: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            indeterminate: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            secondaryProgressValue: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            activeProgressColor: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
                resourceValue: string[];
            };
            secondaryProgressColor: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
                resourceValue: string[];
            };
        };
        min: number;
        max: number;
        step: number;
        secondaryProgressValue: number;
        indeterminate: boolean;
        activeProgressColor: string;
        secondaryProgressColor: string;
        private _secondaryProgressElement;
        private _activeProgressElement;
        private _secondaryProgress;
        constructor(element: any, options: any);
        createControl(element: HTMLElement, options: any): any;
        _updateLayout(args: any): void;
        private _calcRatio;
        private _clampValue;
        private _calcStep;
        private _transformProgress;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface IRange extends IControlBase {
        value: number;
        min: number;
        max: number;
        step: number;
        ratio: number;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Range extends VisiWin.UI.ControlBase implements IRange {
        static namespace: string;
        static controlName: string;
        static className: string;
        static RangeOptionsList: {
            value: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            min: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            max: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            step: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            ratio: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
        };
        value: number;
        min: number;
        max: number;
        step: number;
        ratio: number;
        private _oldValue;
        constructor(element: any, options: any);
        private _calcRatio;
        private _clampValue;
        private _calcStep;
        private _validateValue;
        _updateLayout(eventArgs: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ExpansionPanel extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ExpansionPanelHeader extends VisiWin.UI.ToggleButtonBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                defaultValue: string;
            };
            checked: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                forceOverwrite: boolean;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                forceOverwrite: boolean;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showDescriptionText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            descriptionTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableDescriptionText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            descriptionTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: number;
            };
            descriptionTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            collapsedSymbol: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            expandedSymbol: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            descriptionTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            symbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        showDescriptionText: boolean;
        descriptionTextWidth: string;
        descriptionTextHeight: string;
        descriptionTextMargin: string;
        descriptionTextPadding: string;
        descriptionText: string;
        localizableDescriptionText: string;
        descriptionTextAlignment: string;
        descriptionTextLineClamp: number;
        descriptionTextWrapping: string;
        descriptionTextTrimming: string;
        descriptionTextFontClass: string;
        descriptionTextFontSize: string;
        descriptionTextFontWeight: string;
        descriptionTextLineHeight: string;
        descriptionTextContrast: number;
        descriptionTextUppercase: boolean;
        showSymbol: boolean;
        iconFont: string;
        collapsedSymbol: string;
        expandedSymbol: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        backgroundColor: string;
        labelForegroundColor: string;
        descriptionTextForegroundColor: string;
        symbolForegroundColor: string;
        borderColor: string;
        private _labelElement;
        private _descriptionTextElement;
        private _symbolElement;
        constructor(element: any, options: any);
        createTemplate(): any;
        ready(): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ExpansionPanelContent extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            checked: {
                propertyType: string;
                type: string;
            };
            maxHeight: {
                propertyType: string;
                type: string;
                defaultValue: string;
                forceOverwrite: boolean;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        checked: boolean;
        maxHeight: string;
        overflow: string;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ExpansionPanelGroup extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            selectedIndex: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        selectedIndex: number;
        backgroundColor: string;
        borderColor: string;
        private _itemsCollection;
        private _selectedItem;
        private _itemIndex;
        private _boundItemsActionHandler;
        constructor(element: VWElement, options: any);
        ready(): void;
        registerChild(controlType: string, action: string, element: HTMLElement, options: any): any;
        _itemsActionHandler(control: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Limit extends VisiWin.UI.ProviderBase {
        static namespace: string;
        static controlName: string;
        static LimitPropertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            value: {
                propertyType: string;
                type: string;
            };
            startValue: {
                propertyType: string;
                type: string;
            };
            endValue: {
                propertyType: string;
                type: string;
            };
            iconFont: {
                propertyType: string;
                type: string;
            };
            symbol: {
                propertyType: string;
                type: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
            };
            fillColor: {
                propertyType: string;
                type: string;
            };
        };
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class SymbolPresenter extends VisiWin.UI.VariableBase {
        static namespace: string;
        static controlName: string;
        static classSymbolPresenter: string;
        static SymbolPresenterPropertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            bitCalculation: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            bitNumbering: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            limits: {
                propertyType: string;
                type: string;
            };
            iconFont: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbol: {
                propertyType: string;
                type: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        foregroundColor: string;
        borderColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        bitCalculation: boolean;
        bitNumbering: string;
        limits: string;
        iconFont: string;
        symbol: string;
        symbolType: string;
        private _symbolElement;
        private limitsCollection;
        private boundLimitsChangedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        _limitsChangedHandler(args: any): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
}
declare module VisiWin.UI {
    class TextVarOut extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            variableName: {
                propertyType: string;
                type: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showLeadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            leadingIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelContainerWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            valueContainerWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showValue: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            valuePadding: {
                propertyType: string;
                type: string;
                child: string;
            };
            value: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            valueTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            valueLineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueFontClass: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueFontSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueFontWeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueLineHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueTextContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelContainerBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            valueContainerBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            leadingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            symbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            valueForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelContainerBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            valueContainerBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        variableName: string;
        alignItems: string;
        justifyContent: string;
        showLeadingSymbol: boolean;
        leadingIconFont: string;
        leadingSymbol: string;
        leadingSymbolType: string;
        leadingSymbolSize: string;
        leadingSymbolMargin: string;
        leadingSymbolPosition: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        labelContainerWidth: string;
        labelContainerHeight: string;
        labelContainerMargin: string;
        labelContainerPadding: string;
        labelContainerBorderWidth: string;
        labelContainerBorderStyle: string;
        labelContainerBorderRadius: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        useVariableText: boolean;
        labelText: string;
        localizableLabelText: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        valueContainerWidth: string;
        valueContainerHeight: string;
        valueContainerMargin: string;
        valueContainerPadding: string;
        valueContainerBorderWidth: string;
        valueContainerBorderStyle: string;
        valueContainerBorderRadius: string;
        showValue: boolean;
        valueWidth: string;
        valueHeight: string;
        valueMargin: string;
        valuePadding: string;
        value: number;
        valueTextAlignment: string;
        valueLineClamp: number;
        valueTextWrapping: string;
        valueTextTrimming: string;
        valueFontClass: string;
        valueFontSize: string;
        valueFontWeight: string;
        valueLineHeight: string;
        valueTextContrast: number;
        backgroundColor: string;
        labelContainerBackgroundColor: string;
        valueContainerBackgroundColor: string;
        leadingSymbolForegroundColor: string;
        symbolForegroundColor: string;
        labelForegroundColor: string;
        valueForegroundColor: string;
        borderColor: string;
        labelContainerBorderColor: string;
        valueContainerBorderColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        private _leadingSymbolElement;
        private _labelValueContainerElement;
        private _labelElement;
        private _valueElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface INumericVarOut extends VisiWin.UI.IControlBase {
        /**
         * value property / option
         * Get and set the property "value".
         * Der Wert von value wird automatisch einer angemeldeten Variablen nachgeführt.
         * In Ihr wird der Einheiten Umgerechnete Wert durch den Variablen Event Handler eingetragen.
         * Zusätzlich wird der option angegebene formatString zur darstellung ausgewertet.
         * Ein aufruf des Setters von value beschreibt NICHT automatisch die VisiWin Variable.
         * Je nach Datentype der Variabe kann sich der Datentype von value ändern.
         * Datatype: any
         * Defaultvalue: null
        **/
        value: string;
        variableName: string;
        decimalPlaces: number;
        labelText: string;
        locLabelText: string;
        useVariableText: boolean;
        unitText: string;
        locUnitText: string;
        useVariableUnitText: boolean;
        valueWidth: string;
        valueAlignment: string;
        valueMargin: string;
        valueBorderWidth: string;
        valueBorderRadius: string;
        valueFontClass: string;
        valueFontFamily: string;
        valueFontSize: string;
        valueFontWeight: string;
        valueLineHeight: string;
        showUnit: string;
        unitWidth: string;
        unitMargin: string;
        unitAlignment: string;
        unitFontClass: string;
        unitFontFamily: string;
        unitFontSize: string;
        unitFontWeight: string;
        unitLineHeight: string;
        /**
         * showLabel property / option
         * Get and set the property "showLabel".
         * The property showLabel shows or hides the Label element.
         * Datatype: boolean
         * Defaultvalue: true
         * Valid values: true | false
        **/
        showLabel: boolean;
        labelAlignment: string;
        labelMargin: string;
        labelLineClamp: string;
        labelFontClass: string;
        labelFontFamily: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        /**
         * showSymbol property / option
         * Get and set the property "showSymbol".
         * The property showSymbol shows or hides the Symbol element.
         * Datatype: boolean
         * Defaultvalue: false
         * Valid values: true | false
        **/
        showSymbol: boolean;
        /**
         * symbol property / option
         * Get and set the property "symbol".
         * Legt des Quelle des Symbols fest, bei
         *  "icon"        : der Name des Icons im Font.
         *  "image", "svg": der Name der Datei die dargestellt werden soll.
         * Datatype: string
         * Defaultvalue: null
         * Valid values: Iconname aus Font oder Path auf eine gültuge Image oder Svg Datei
        **/
        symbol: string;
        /**
         * symbolType property / option
         * Get and set the property "symbolType".
         * Es gibt drei gültige Werte:
         *  "icon" : Ein Zeichen aus einem Iconfont dargestellt. Es wird ein <I> Tag verwebdet.
         *  "image": Eine Bitmap Grafig in dem Format "PNG" oder "JPG" wird ausgegeben. Es wird ein "IMG" Tag verwendet.
         *  "svg"  : Eine SVF Grafig wird ausgegeben. Es wird ein <IMG> Tag verwendet.
         * Datatype: string
         * Defaultvalue: "icon"
         * Valid values: "icon", "image", svg"
        **/
        symbolType: string;
        /**
         * symbolSize property / option
         * Get and set the property "symbolSize".
         * Größe des dargestellten Symbols.
         * Dieses Property muss immer in Zusammenhang mit den den Style Propertys "with" und "height" gesehen werden.
         * Der Wert auto besagt, die größe wird über die "width" und "height" Properties festgelegt.
         * Ist ein Wert angegeben, so wird damit die Breite und Höhe des Symbols angegeben. Sind die "width" und height"
         * Properties nicht auf "auto" eingestellt, sie wird hierdurch die größe des umgebenden Containers eingestellt,
         * andernfalls wird der Container an die größe des Symbols angepasst.
         * Datatype: string
         * Defaultvalue: "auto" -  symbolType="image" and symbolType="svg"
         *               "24px" -  symbolType="icon"
         * Valid values: <length> | <percentage> | auto | inherit | initial
        **/
        symbolSize: string;
        symbolMargin: string;
        /**
         * backgroundColor property / option
         * Get and set the css style Property "backgroundColor" of the corrosponding HTML Element.
         * The background-color property sets the background color of an element.
         * The background of an element is the total size of the element, including padding and border (but not the margin).
         * Tip: Use a background color and a text color that makes the text easy to read.
         * Datatype: string
         * Defaultvalue: none
         * Valid values: color | transparent | inherit | initial
        **/
        backgroundColor: string;
        valueBackgroundColor: string;
        valueForegroundColor: string;
        valueBorderColor: string;
        labelBackgroundColor: string;
        labelForegroundColor: string;
        symbolBackgroundColor: string;
        symbolForegroundColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledValueBorderColor: string;
        /**
         * public method: dispose destroy the control
         * @dispose
         * @return:bool is true, dispose subtree will be call after dispose
        **/
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class NumericVarOut extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            variableName: {
                propertyType: string;
                type: string;
            };
            decimalPlaces: {
                propertyType: string;
                type: string;
                child: string;
            };
            useRawValue: {
                propertyType: string;
                type: string;
                child: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showLeadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            leadingIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            leadingSymbolPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelContainerWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
                child: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            valueContainerWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            valueContainerBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showValue: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            valuePadding: {
                propertyType: string;
                type: string;
                child: string;
            };
            value: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            valueLineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueFontClass: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueFontSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueFontWeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueLineHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            valueTextContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            showUnit: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitWidth: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitMargin: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitPadding: {
                propertyType: string;
                type: string;
                child: string;
            };
            useVariableUnitText: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitText: {
                propertyType: string;
                type: string;
                child: string;
            };
            localizableUnitText: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitLineClamp: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitFontClass: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitFontSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitFontWeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitLineHeight: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitTextContrast: {
                propertyType: string;
                type: string;
                child: string;
            };
            unitPosition: {
                propertyType: string;
                type: string;
                child: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelContainerBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            valueContainerBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            leadingSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            symbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            valueForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            unitForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelContainerBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            valueContainerBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        variableName: string;
        decimalPlaces: number;
        alignItems: string;
        justifyContent: string;
        showLeadingSymbol: boolean;
        leadingIconFont: string;
        leadingSymbol: string;
        leadingSymbolType: string;
        leadingSymbolSize: string;
        leadingSymbolMargin: string;
        leadingSymbolPosition: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        labelContainerWidth: string;
        labelContainerHeight: string;
        labelContainerMargin: string;
        labelContainerPadding: string;
        labelContainerBorderWidth: string;
        labelContainerBorderStyle: string;
        labelContainerBorderRadius: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        useVariableText: boolean;
        labelText: string;
        localizableLabelText: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        valueContainerWidth: string;
        valueContainerHeight: string;
        valueContainerMargin: string;
        valueContainerPadding: string;
        valueContainerBorderWidth: string;
        valueContainerBorderStyle: string;
        valueContainerBorderRadius: string;
        showValue: boolean;
        valueWidth: string;
        valueHeight: string;
        valueMargin: string;
        valuePadding: string;
        value: number;
        valueTextAlignment: string;
        valueLineClamp: number;
        valueTextWrapping: string;
        valueTextTrimming: string;
        valueFontClass: string;
        valueFontSize: string;
        valueFontWeight: string;
        valueLineHeight: string;
        valueTextContrast: number;
        showUnit: boolean;
        unitWidth: string;
        unitHeight: string;
        unitMargin: string;
        unitPadding: string;
        useVariableUnitText: boolean;
        unitText: string;
        localizableUnitText: string;
        unitTextAlignment: string;
        unitLineClamp: number;
        unitTextWrapping: string;
        unitTextTrimming: string;
        unitFontClass: string;
        unitFontSize: string;
        unitFontWeight: string;
        unitLineHeight: string;
        unitTextContrast: number;
        unitPosition: string;
        backgroundColor: string;
        labelContainerBackgroundColor: string;
        valueContainerBackgroundColor: string;
        leadingSymbolForegroundColor: string;
        symbolForegroundColor: string;
        labelForegroundColor: string;
        valueForegroundColor: string;
        unitForegroundColor: string;
        borderColor: string;
        labelContainerBorderColor: string;
        valueContainerBorderColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        private _leadingSymbolElement;
        private _labelValueContainerElement;
        private _labelElement;
        private _valueElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Image extends VisiWin.UI.VariableBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            iconFont: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            image: {
                propertyType: string;
                type: string;
            };
            imageType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            imageSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            imageList: {
                propertyType: string;
                type: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        overflow: string;
        iconFont: string;
        image: string;
        imageType: string;
        imageSize: string;
        imageList: string;
        backgroundColor: string;
        foregroundColor: string;
        borderColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        private _imageElement;
        private imagesCollection;
        private boundImagesChangedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        _imagesChangedHandler(args: any): void;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ImageState extends VisiWin.UI.ProviderBase {
        static namespace: string;
        static controlName: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            value: {
                propertyType: string;
                type: string;
            };
            iconFont: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            image: {
                propertyType: string;
                type: string;
            };
            imageType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        value: string;
        iconFont: string;
        image: string;
        imageType: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AlarmList extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            desiredClasses: {
                propertyType: string;
                type: string;
                child: string;
            };
            desiredGroups: {
                propertyType: string;
                type: string;
                child: string;
            };
            desiredStates: {
                propertyType: string;
                type: string;
                child: string;
            };
            maxPriority: {
                propertyType: string;
                type: string;
                child: string;
            };
            minPriority: {
                propertyType: string;
                type: string;
                child: string;
            };
            sortMode: {
                propertyType: string;
                type: string;
                child: string;
            };
            sampleData: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
            template: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        template: string;
        backgroundColor: string;
        private _listViewElement;
        private _alarmItemTemplateElement;
        private _alarmsProvider;
        private _isListViewLoaded;
        private _isSampleDataLoaded;
        private _boundListViewChangeHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        afterInit(): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        _initListView(): void;
        _onSampleDataLoaded(): void;
        _listViewChangeHandler(args: any): void;
        ready(element: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class GroupPanel extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static classGroupPanel: string;
        static GroupPanelPropertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue_DM: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        disabledBackgroundColor: string;
        disabledBorderColor: string;
        constructor(element: VWElement, options: any);
        _updateColors(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Select extends VisiWin.UI.ButtonBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            selectedIndexChanged: {
                propertyType: string;
            };
            checkedChanged: {
                propertyType: string;
            };
            checked: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            open: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            errorMode: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            borderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
                forceOverwrite: boolean;
            };
            borderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
                forceOverwrite: boolean;
            };
            borderRadius: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
            };
            selectedValue: {
                propertyType: string;
                type: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            outlined: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            listType: {
                propertyType: string;
                type: string;
            };
            watermarkText: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            localizableWatermarkText: {
                propertyType: string;
                type: string;
            };
            showLabelSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            labelIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            labelSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            labelSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelSymbolPosition: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelContainerPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            labelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                forceOverwrite: boolean;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                forceOverwrite: boolean;
            };
            labelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            labelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            labelPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            containerWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            textContainerWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            textContainerHeight: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            textContainerMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            textContainerPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showPrimaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizablePrimaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showSecondaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            secondaryTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableSecondaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFieldMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showFloatingLabel: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            floatingLabelWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableFloatingLabelText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            floatingLabelFixed: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            floatingLabelTransition: {
                propertyType: string;
                type: string;
            };
            floatingLabelOutlineWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            floatingLabelOutlineStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showStateSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            stateSymbolIconFont: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            openedStateSymbol: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            closedStateSymbol: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            stateSymbolType: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            stateSymbolSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            stateSymbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showUnderline: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            underlineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            underlineOpacity: {
                propertyType: string;
                type: string;
            };
            checkedUnderlineOpacity: {
                propertyType: string;
                type: string;
            };
            underlineTransition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            underlineTransform: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            checkedUnderlineTransform: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                type: string;
                child: string;
                forceOverwrite: boolean;
                defaultValue: string;
            };
            menuItems: {
                propertyType: string;
                type: string;
                child: string;
            };
            menuWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            menuHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            menuMargin: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            menuPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            menuBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            menuBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            menuBorderRadius: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            menuShadow: {
                propertyType: string;
                type: string;
            };
            menuPlacement: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            selectedIndex: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: number;
            };
            popoverId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showHelperText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            helperTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableHelperText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            helperTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            helperTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showErrorText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            errorTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableErrorText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            errorTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            errorTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            labelSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            primaryTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            secondaryTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            symbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedFloatingLabelForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            stateSymbolForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            helperTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            errorColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            underlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedUnderlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            menuBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            menuBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            floatingLabelOutlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledFloatingLabelOutlineColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        borderStyle: Enums.BorderStyle;
        borderRadius: string;
        selectedValue: string;
        alignItems: string;
        justifyContent: string;
        outlined: boolean;
        listType: string;
        watermarkText: string;
        localizableWatermarkText: string;
        showLabelSymbol: boolean;
        labelIconFont: string;
        labelSymbol: string;
        labelSymbolType: string;
        labelSymbolSize: string;
        labelSymbolMargin: string;
        labelSymbolPosition: string;
        labelContainerWidth: string;
        labelContainerHeight: string;
        labelContainerMargin: string;
        labelContainerPadding: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        containerWidth: string;
        containerHeight: string;
        containerMargin: string;
        containerPadding: string;
        textContainerWidth: string;
        textContainerHeight: string;
        textContainerMargin: string;
        textContainerPadding: string;
        showPrimaryText: boolean;
        primaryTextWidth: string;
        primaryTextHeight: string;
        primaryTextMargin: string;
        primaryTextPadding: string;
        primaryText: string;
        localizablePrimaryText: string;
        primaryTextAlignment: string;
        primaryTextLineClamp: number;
        primaryTextWrapping: string;
        primaryTextTrimming: string;
        primaryTextFontClass: string;
        primaryTextFontSize: string;
        primaryTextFontWeight: string;
        primaryTextLineHeight: string;
        primaryTextContrast: number;
        primaryTextUppercase: boolean;
        showSecondaryText: boolean;
        secondaryTextWidth: string;
        secondaryTextHeight: string;
        secondaryTextMargin: string;
        secondaryTextPadding: string;
        secondaryText: string;
        localizableSecondaryText: string;
        secondaryTextAlignment: string;
        secondaryTextLineClamp: number;
        secondaryTextWrapping: string;
        secondaryTextTrimming: string;
        secondaryTextFontClass: string;
        secondaryTextFontSize: string;
        secondaryTextFontWeight: string;
        secondaryTextLineHeight: string;
        secondaryTextContrast: number;
        secondaryTextUppercase: boolean;
        showSymbol: boolean;
        iconFont: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        floatingLabelFieldMargin: string;
        showFloatingLabel: boolean;
        floatingLabelWidth: string;
        floatingLabelHeight: string;
        floatingLabelMargin: string;
        floatingLabelPadding: string;
        floatingLabelText: string;
        localizableFloatingLabelText: string;
        floatingLabelTextAlignment: string;
        floatingLabelLineClamp: number;
        floatingLabelTextWrapping: string;
        floatingLabelTextTrimming: string;
        floatingLabelFontClass: string;
        floatingLabelFontSize: string;
        floatingLabelFontWeight: string;
        floatingLabelLineHeight: string;
        floatingLabelTextContrast: number;
        floatingLabelUppercase: boolean;
        floatingLabelFixed: boolean;
        floatingLabelTransition: string;
        floatingLabelOutlineWidth: string;
        floatingLabelOutlineStyle: string;
        showStateSymbol: boolean;
        stateSymbolIconFont: string;
        openedStateSymbol: string;
        closedStateSymbol: string;
        stateSymbolType: string;
        stateSymbolSize: string;
        stateSymbolMargin: string;
        showUnderline: boolean;
        underlineHeight: string;
        underlineOpacity: number;
        checkedUnderlineOpacity: number;
        underlineTransition: string;
        underlineTransform: string;
        checkedUnderlineTransform: string;
        menuItems: string;
        menuWidth: string;
        menuHeight: string;
        menuMargin: string;
        menuPadding: string;
        menuBorderWidth: string;
        menuBorderStyle: string;
        menuBorderRadius: string;
        menuShadow: string;
        menuPlacement: string;
        selectedIndex: number;
        popoverId: string;
        showHelperText: boolean;
        helperTextWidth: string;
        helperTextHeight: string;
        helperTextMargin: string;
        helperTextPadding: string;
        helperText: string;
        localizableHelperText: string;
        helperTextAlignment: string;
        helperTextLineClamp: number;
        helperTextWrapping: string;
        helperTextTrimming: string;
        helperTextFontClass: string;
        helperTextFontSize: string;
        helperTextFontWeight: string;
        helperTextLineHeight: string;
        helperTextContrast: number;
        helperTextUppercase: boolean;
        showErrorText: boolean;
        errorTextWidth: string;
        errorTextHeight: string;
        errorTextMargin: string;
        errorTextPadding: string;
        errorText: string;
        localizableErrorText: string;
        errorTextAlignment: string;
        errorTextLineClamp: number;
        errorTextWrapping: string;
        errorTextTrimming: string;
        errorTextFontClass: string;
        errorTextFontSize: string;
        errorTextFontWeight: string;
        errorTextLineHeight: string;
        errorTextContrast: number;
        errorTextUppercase: boolean;
        backgroundColor: string;
        hoverBackgroundColor: string;
        checkedBackgroundColor: string;
        floatingLabelBackgroundColor: string;
        labelForegroundColor: string;
        labelSymbolForegroundColor: string;
        primaryTextForegroundColor: string;
        secondaryTextForegroundColor: string;
        symbolForegroundColor: string;
        floatingLabelForegroundColor: string;
        checkedFloatingLabelForegroundColor: string;
        stateSymbolForegroundColor: string;
        helperTextForegroundColor: string;
        errorColor: string;
        borderColor: string;
        hoverBorderColor: string;
        checkedBorderColor: string;
        underlineColor: string;
        checkedUnderlineColor: string;
        menuBackgroundColor: string;
        menuBorderColor: string;
        floatingLabelOutlineColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        disabledFloatingLabelOutlineColor: string;
        private _labelElement;
        private _containerElement;
        private _fieldContainerElement;
        private _textContainerElement;
        private _primaryTextElement;
        private _secondaryTextElement;
        private _symbolElement;
        private _floatingLabelFieldElement;
        private _floatingLabelElement;
        private _stateSymbolElement;
        private _underlineElement;
        private _menuElement;
        private _helperTextElement;
        private _errorTextElement;
        private _popoverElement;
        private _boundPopoverHandler;
        private _boundHoverInHandler;
        private _boundHoverOutHandler;
        private _boundBeforeShowChangedHandler;
        private _boundBeforeHideChangedHandler;
        observe: any;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        createHandler(): void;
        removeHandler(): void;
        afterInit(): void;
        private _serviceValue;
        set serviceValue(value: string);
        get serviceValue(): string;
        private __checked;
        get checked(): boolean;
        set checked(value: boolean);
        set open(value: boolean);
        private _errorMode;
        get errorMode(): boolean;
        set errorMode(value: boolean);
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        _setSelectOptions(): void;
        _getBindingList(list: any, valueFilter?: any, primaryTextFilter?: any, secondaryTextFilter?: any): any;
        _popoverHandler(args: any): void;
        _hoverInHandler(args: any): void;
        _hoverOutHandler(args: any): void;
        _beforeShowChangedHandler(args: any): void;
        _beforeHideChangedHandler(args: any): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Option extends VisiWin.UI.ToggleButtonBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            padding: {
                propertyType: string;
                type: string;
                element: string;
                forceOverwrite: boolean;
            };
            transition: {
                propertyType: string;
                type: string;
            };
            value: {
                propertyType: string;
                type: string;
                forceOverwrite: boolean;
            };
            containerBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            containerTransition: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbol: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                child: string;
            };
            symbolMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            symbolPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            showPrimaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            primaryTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizablePrimaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            primaryTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showSecondaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            secondaryTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableSecondaryText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            secondaryTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            pressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedPressedForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            hoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            checkedHoverBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        padding: string;
        transition: string;
        containerBorderWidth: string;
        containerBorderStyle: string;
        containerBorderRadius: string;
        containerTransition: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        showPrimaryText: boolean;
        primaryTextWidth: string;
        primaryTextHeight: string;
        primaryTextMargin: string;
        primaryTextPadding: string;
        primaryText: string;
        localizablePrimaryText: string;
        primaryTextAlignment: string;
        primaryTextLineClamp: number;
        primaryTextWrapping: string;
        primaryTextTrimming: string;
        primaryTextFontClass: string;
        primaryTextFontSize: string;
        primaryTextFontWeight: string;
        primaryTextLineHeight: string;
        primaryTextContrast: number;
        primaryTextUppercase: boolean;
        showSecondaryText: boolean;
        secondaryTextWidth: string;
        secondaryTextHeight: string;
        secondaryTextMargin: string;
        secondaryTextPadding: string;
        secondaryText: string;
        localizableSecondaryText: string;
        secondaryTextAlignment: string;
        secondaryTextLineClamp: number;
        secondaryTextWrapping: string;
        secondaryTextTrimming: string;
        secondaryTextFontClass: string;
        secondaryTextFontSize: string;
        secondaryTextFontWeight: string;
        secondaryTextLineHeight: string;
        secondaryTextContrast: number;
        secondaryTextUppercase: boolean;
        backgroundColor: string;
        hoverBackgroundColor: string;
        pressedBackgroundColor: string;
        checkedBackgroundColor: string;
        checkedHoverBackgroundColor: string;
        checkedPressedBackgroundColor: string;
        disabledBackgroundColor: string;
        foregroundColor: string;
        pressedForegroundColor: string;
        checkedForegroundColor: string;
        checkedPressedForegroundColor: string;
        disabledForegroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        checkedBorderColor: string;
        checkedHoverBorderColor: string;
        disabledBorderColor: string;
        private _containerElement;
        private _symbolElement;
        private _textContainerElement;
        private _primaryTextElement;
        private _secondaryTextElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        attach(): Promise<any>;
        detach(): Promise<any>;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Dialog extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            result: {
                propertyType: string;
            };
            beforeShow: {
                propertyType: string;
            };
            beforeHide: {
                propertyType: string;
            };
            afterShow: {
                propertyType: string;
            };
            afterHide: {
                propertyType: string;
            };
            anchor: {
                propertyType: string;
                type: string;
            };
            placement: {
                propertyType: string;
                type: string;
            };
            alignment: {
                propertyType: string;
                type: string;
            };
            mode: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            dialogName: {
                propertyType: string;
                type: string;
            };
            showAtX: {
                propertyType: string;
                type: string;
            };
            showAtY: {
                propertyType: string;
                type: string;
            };
            style: {
                propertyType: string;
                type: string;
            };
            titleText: {
                propertyType: string;
                type: string;
            };
            localizableTitleText: {
                propertyType: string;
                type: string;
            };
            titleVisibility: {
                propertyType: string;
                type: string;
            };
            contentText: {
                propertyType: string;
                type: string;
            };
            localizableContentText: {
                propertyType: string;
                type: string;
            };
            action1ButtonText: {
                propertyType: string;
                type: string;
            };
            localizableAction1ButtonText: {
                propertyType: string;
                type: string;
            };
            action2ButtonText: {
                propertyType: string;
                type: string;
            };
            localizableAction2ButtonText: {
                propertyType: string;
                type: string;
            };
            action2ButtonVisibility: {
                propertyType: string;
                type: string;
            };
            showAction1Button: {
                propertyType: string;
                type: string;
            };
            showAction2Button: {
                propertyType: string;
                type: string;
            };
            dialogScrimColor: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        anchor: any;
        placement: string;
        alignment: string;
        mode: string;
        dialogName: string;
        showAtX: string;
        showAtY: string;
        titleText: string;
        localizableTitleText: string;
        titleVisibility: string;
        contentText: string;
        localizableContentText: string;
        action1ButtonText: string;
        localizableAction1ButtonText: string;
        action2ButtonText: string;
        localizableAction2ButtonText: string;
        action2ButtonVisibility: string;
        showAction1Button: boolean;
        showAction2Button: boolean;
        private _popupElement;
        private _popupControl;
        private _regionControl;
        private _boundResultHandler;
        private _boundBeforeShowChangedHandler;
        private _boundBeforeHideChangedHandler;
        private _boundAfterShowChangedHandler;
        private _boundAfterHideChangedHandler;
        private _boundKeyDownHandler;
        viewModel: any;
        bindingData: any;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        private _dialogScrimColor;
        get dialogScrimColor(): string;
        set dialogScrimColor(value: string);
        _createDialog(): any;
        _resultHandler(args: any): void;
        _beforeShowChangedHandler(args: any): void;
        _beforeHideChangedHandler(args: any): void;
        _afterShowChangedHandler(args: any): void;
        _afterHideChangedHandler(args: any): void;
        _keyDownHandler(event: any): void;
        show(): void;
        hide(result: any): void;
        showAt(xPos: number, yPos: number): void;
        result(result: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class AlertDialog extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            headerBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            headerBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            headerBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            headerWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            headerMinWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            headerMaxWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            headerHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            headerMinHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            headerMaxHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            headerMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            headerPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showTitle: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            titleWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titlePadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableTitleText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            titleTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            titleFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            titleUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            contentBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            contentBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            contentWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            contentMinWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            contentMaxWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            contentHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            contentMinHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            contentMaxHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            contentMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            contentPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showContentText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: boolean;
            };
            contentTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableContentText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            contentTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            contentTextFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            contentTextUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            actionBarBorderWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            actionBarBorderStyle: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            actionBarBorderRadius: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            actionBarWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            actionBarMinWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            actionBarMaxWidth: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            actionBarHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            actionBarMinHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            actionBarMaxHeight: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            actionBarMargin: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            actionBarPadding: {
                propertyType: string;
                type: string;
                element: string;
                style: string;
            };
            showAction1Button: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            action1ButtonWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            action1ButtonHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableAction1ButtonText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action1ButtonUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            showAction2Button: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            action2ButtonWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            action2ButtonHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonMargin: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonPadding: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonTextWidth: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonTextHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
                defaultValue: string;
            };
            localizableAction2ButtonText: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonTextAlignment: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonLineClamp: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonTextWrapping: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonTextTrimming: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonFontClass: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonFontSize: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonFontWeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonLineHeight: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonTextContrast: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            action2ButtonUppercase: {
                propertyType: string;
                type: string;
                child: string;
                childProperty: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            headerBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            contentBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            actionBarBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            titleForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            contentTextForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            action1ButtonForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            action2ButtonForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        headerBorderWidth: string;
        headerBorderStyle: string;
        headerBorderRadius: string;
        headerWidth: string;
        headerMinWidth: string;
        headerMaxWidth: string;
        headerHeight: string;
        headerMinHeight: string;
        headerMaxHeight: string;
        headerMargin: string;
        headerPadding: string;
        showTitle: boolean;
        titleWidth: string;
        titleHeight: string;
        titleMargin: string;
        titlePadding: string;
        titleText: string;
        localizableTitleText: string;
        titleTextAlignment: string;
        titleLineClamp: number;
        titleTextWrapping: string;
        titleTextTrimming: string;
        titleFontClass: string;
        titleFontSize: string;
        titleFontWeight: string;
        titleLineHeight: string;
        titleTextContrast: number;
        titleUppercase: boolean;
        contentBorderWidth: string;
        contentBorderStyle: string;
        contentBorderRadius: string;
        contentWidth: string;
        contentMinWidth: string;
        contentMaxWidth: string;
        contentHeight: string;
        contentMinHeight: string;
        contentMaxHeight: string;
        contentMargin: string;
        contentPadding: string;
        showContentText: boolean;
        contentTextWidth: string;
        contentTextHeight: string;
        contentTextMargin: string;
        contentTextPadding: string;
        contentText: string;
        localizableContentText: string;
        contentTextAlignment: string;
        contentTextLineClamp: number;
        contentTextWrapping: string;
        contentTextTrimming: string;
        contentTextFontClass: string;
        contentTextFontSize: string;
        contentTextFontWeight: string;
        contentTextLineHeight: string;
        contentTextContrast: number;
        contentTextUppercase: boolean;
        actionBarBorderWidth: string;
        actionBarBorderStyle: string;
        actionBarBorderRadius: string;
        actionBarWidth: string;
        actionBarMinWidth: string;
        actionBarMaxWidth: string;
        actionBarHeight: string;
        actionBarMinHeight: string;
        actionBarMaxHeight: string;
        actionBarMargin: string;
        actionBarPadding: string;
        showAction1Button: boolean;
        action1ButtonWidth: string;
        action1ButtonHeight: string;
        action1ButtonMargin: string;
        action1ButtonPadding: string;
        action1ButtonTextWidth: string;
        action1ButtonTextHeight: string;
        action1ButtonText: string;
        localizableAction1ButtonText: string;
        action1ButtonTextAlignment: string;
        action1ButtonLineClamp: number;
        action1ButtonTextWrapping: string;
        action1ButtonTextTrimming: string;
        action1ButtonFontClass: string;
        action1ButtonFontSize: string;
        action1ButtonFontWeight: string;
        action1ButtonLineHeight: string;
        action1ButtonTextContrast: number;
        action1ButtonUppercase: boolean;
        showAction2Button: boolean;
        action2ButtonWidth: string;
        action2ButtonHeight: string;
        action2ButtonMargin: string;
        action2ButtonPadding: string;
        action2ButtonTextWidth: string;
        action2ButtonTextHeight: string;
        action2ButtonText: string;
        localizableAction2ButtonText: string;
        action2ButtonTextAlignment: string;
        action2ButtonLineClamp: number;
        action2ButtonTextWrapping: string;
        action2ButtonTextTrimming: string;
        action2ButtonFontClass: string;
        action2ButtonFontSize: string;
        action2ButtonFontWeight: string;
        action2ButtonLineHeight: string;
        action2ButtonTextContrast: number;
        action2ButtonUppercase: boolean;
        backgroundColor: string;
        headerBackgroundColor: string;
        contentBackgroundColor: string;
        actionBarBackgroundColor: string;
        titleForegroundColor: string;
        contentTextForegroundColor: string;
        action1ButtonForegroundColor: string;
        action2ButtonForegroundColor: string;
        borderColor: string;
        private _headerElement;
        private _titleElement;
        private _contentElement;
        private _contentTextElement;
        private _actionBarElement;
        private _action1ButtonElement;
        private _action2ButtonElement;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ContentDialog extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            shadow: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ContentDialogHeader extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        alignItems: string;
        justifyContent: string;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ContentDialogContent extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            overflow: {
                propertyType: string;
                type: string;
            };
            orientation: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            wrap: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        overflow: string;
        orientation: string;
        alignItems: string;
        justifyContent: string;
        alignContent: string;
        wrap: boolean;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class ContentDialogActionBar extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        alignItems: string;
        justifyContent: string;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
        _updateLayout(changes: any): void;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class TemplateContainer extends VisiWin.UI.ControlBase implements ITemplateContainer {
        static namespace: string;
        static controlName: string;
        static classAbsoluteLayout: string;
        static TemplateContainerOptionsList: {
            designerType: {
                propertyType: string;
                defaultValue_DM: string;
            };
        };
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ITemplateContainer extends IControlBase {
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class Unknown extends VisiWin.UI.ControlBase {
        static namespace: string;
        static controlName: string;
        static className: string;
        static propertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            error: {
                propertyType: string;
                type: string;
            };
        };
        error: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class StackedDonutGaugeCore extends VisiWin.UI.ControlBase implements IStackedDonutGaugeCore {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            radialBarWidth: {
                propertyType: string;
                type: string;
            };
            radialBarSpacing: {
                propertyType: string;
                type: string;
            };
            innerRadius: {
                propertyType: string;
                type: string;
            };
            radialBarBackground: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            radialBarFillColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            minValue: {
                propertyType: string;
                type: string;
            };
            maxValue: {
                propertyType: string;
                type: string;
            };
            startAngle: {
                propertyType: string;
                type: string;
            };
            endAngle: {
                propertyType: string;
                type: string;
            };
            clockwise: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            animation: {
                propertyType: string;
                type: string;
            };
            autoAdjustment: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            segments: {
                propertyType: string;
                type: string;
            };
        };
        cssStyles: {
            css: string;
        };
        private segments;
        radialBarWidth: string;
        private _radialBarWidthTemp;
        private _radialBarWidthF;
        radialBarSpacing: string;
        private _radialBarSpacingTemp;
        private _radialBarSpacingF;
        innerRadius: string;
        private _innerRadiusTemp;
        private _innerRadiusF;
        radialBarBackground: string;
        radialBarFillColor: string;
        minValue: number;
        maxValue: number;
        startAngle: string;
        endAngle: string;
        clockwise: boolean;
        animation: string;
        autoAdjustment: boolean;
        private faktor;
        private controlID;
        private myVariableService;
        private myVariable;
        private centerX;
        private centerY;
        private svgSize;
        private _svgElement;
        private svgns;
        private xlinkns;
        private isInStylingMode;
        constructor(element: VWElement, options: any);
        createTemplate(): any;
        resizeHandler(): void;
        beforeInit(): void;
        ready(): void;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        private registerVariable;
        private removeVariable;
        private _changeHandlerVariable;
        private mVariableChanged;
        drawDonut(svgSize: number, segment: any, id: number, faktor: number): void;
        drawLabel(psegment: any): void;
        polarToCartesian(centerX: number, centerY: number, radius: number, angleInDegrees: number): {
            x: number;
            y: number;
        };
        describeArc(x: number, y: number, radius: number, startAngle: number, endAngle: number): string;
        getPixelValue(requiredValue: string, totalValue: number): number;
        attach(): Promise<any> | null;
        detach(): Promise<any> | null;
        dispose(): boolean;
        removeHandler(): void;
    }
}
declare module VisiWin.UI {
    class StackedDonutGaugeLegend extends VisiWin.UI.ControlBase implements IStackedDonutGaugeLegend {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            template: {
                propertyType: string;
                type: string;
            };
            segments: {
                propertyType: string;
                type: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
        };
        private segments;
        private _repeaterElement;
        private bindingList;
        private myVariableService;
        private myVariable;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        beforeInit(): void;
        ready(element: VWElement): void;
        private _template;
        get template(): string;
        set template(value: string);
        _updateColors(changes: VisiWin.UI.IUpdateLayout): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        _setDesignerType(element: any): void;
        private registerVariable;
        private removeVariable;
        private _changeHandlerVariable;
        private mVariableChanged;
        attach(): Promise<any> | null;
        detach(): Promise<any> | null;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    class StackedDonutGaugeSegment extends VisiWin.UI.VariableBase implements IStackedDonutGaugeSegment {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            labelText: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            localizableLabelText: {
                propertyType: string;
                type: string;
            };
            textWidth: {
                propertyType: string;
                type: string;
            };
            textHeight: {
                propertyType: string;
                type: string;
            };
            textColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            uppercase: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            showLabel: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            textAlignment: {
                propertyType: string;
                type: string;
            };
            textContrast: {
                propertyType: string;
                type: string;
            };
            radialBarWidth: {
                propertyType: string;
                type: string;
            };
            capForm: {
                propertyType: string;
                type: string;
            };
            fillColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            startColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            endColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            decimalPlaces: {
                propertyType: string;
                type: string;
            };
        };
        fillColor: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class StackedDonutGauge extends VisiWin.UI.ControlBase implements IStackedDonutGauge {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            showText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            textWidth: {
                propertyType: string;
                type: string;
            };
            textHeight: {
                propertyType: string;
                type: string;
            };
            textMargin: {
                propertyType: string;
                type: string;
            };
            textPadding: {
                propertyType: string;
                type: string;
            };
            useVariableText: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            text: {
                propertyType: string;
                type: string;
            };
            localizableText: {
                propertyType: string;
                type: string;
            };
            positionInDonut: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            textAlignment: {
                propertyType: string;
                type: string;
            };
            lineClamp: {
                propertyType: string;
                type: string;
            };
            textWrapping: {
                propertyType: string;
                type: string;
            };
            textTrimming: {
                propertyType: string;
                type: string;
            };
            fontClass: {
                propertyType: string;
                type: string;
            };
            fontSize: {
                propertyType: string;
                type: string;
            };
            textContrast: {
                propertyType: string;
                type: string;
            };
            textColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            uppercase: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            disabledBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            gaugeWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            gaugeHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            innerRadius: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: string;
            };
            radialBarWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: string;
            };
            radialBarSpacing: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: string;
            };
            radialBarBackground: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
                child: string;
                childOption: string;
            };
            radialBarFillColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
                child: string;
                childOption: string;
            };
            minValue: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: string;
            };
            maxValue: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: string;
            };
            startAngle: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            endAngle: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            clockwise: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
                child: string;
                childOption: string;
            };
            localizableUnitText: {
                propertyType: string;
                type: string;
            };
            unitText: {
                propertyType: string;
                type: string;
            };
            animation: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            autoAdjustment: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
                child: string;
                childOption: string;
            };
            segments: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            showLegend: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            legendBorderWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendBorderStyle: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendBorderRadius: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendWidth: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: string;
            };
            legendHeight: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
                defaultValue: string;
            };
            legendMargin: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendPadding: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            legendPosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            legendAlignment: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            fontClassLegend: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            fontSizeLegend: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            textColorLegend: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
                child: string;
                childOption: string;
            };
            uppercaseLegend: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            showColorLegend: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            showTextLegend: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            showValueLegend: {
                propertyType: string;
                type: string;
                child: string;
                childOption: string;
            };
            template: {
                propertyType: string;
                type: string;
                child: string;
                defaultValue: string;
            };
        };
        cssStyles: {
            css: string;
        };
        private radialBarWidth;
        private radialBarSpacing;
        private innerRadius;
        private autoAdjustment;
        private maxValue;
        private minValue;
        showText: boolean;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.width|width}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textWidth
        **/
        textWidth: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.height|height}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textHeight
        **/
        textHeight: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.margin|margin}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textMargin
        **/
        textMargin: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.padding|padding}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textPadding
        **/
        textPadding: string;
        useVariableText: boolean;
        text: string;
        localizableText: string;
        positionInDonut: boolean;
        /**
        * CSS property
        * @see {@link VisiWin.UI.Enums.AlignItems|textAlignment}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textAlignment
        **/
        textAlignment: string;
        lineClamp: number;
        textWrapping: string;
        textTrimming: string;
        fontClass: string;
        fontSize: string;
        textContrast: number;
        textColor: string;
        uppercase: boolean;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.backgroundColor|backgroundColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } backgroundColor
        **/
        backgroundColor: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.foregroundColor|foregroundColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } foregroundColor
        **/
        foregroundColor: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.borderColor|borderColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } borderColor
        **/
        borderColor: string;
        /**
        * The background-color CSS property sets the disableBackgroundColor for a disabled element.<br>
        * @see {@link VisiWin.UI.CSSProperties.backgroundColor|backgroundColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } disableBackgroundColor
        **/
        disabledBackgroundColor: string;
        /**
        * The color CSS property sets the foreground color value of a disabled element's text.<br>
        * @see {@link VisiWin.UI.CSSProperties.foregroundColor|foregroundColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } disableForegroundColor
        **/
        disabledForegroundColor: string;
        /**
        * The border-color shorthand CSS property sets the color of a disabled element's border.
        * @see {@link VisiWin.UI.CSSProperties.borderColor|borderColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } disableBorderColor
        **/
        disabledBorderColor: string;
        localizableUnitText: string;
        unitText: string;
        private _stackeddonutgaugecore;
        private _legendElement;
        showLegend: boolean;
        legendPosition: string;
        legendAlignment: string;
        private segmentsCollection;
        private boundSegmentsChangedHandler;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        ready(): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        _segmentsChangedHandler(changes: any): void;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    interface IStackedDonutGaugeCore extends VisiWin.UI.IControlBase {
        /**
       * @ignore
       */
        winControl?: any;
        /**
         * radialBarWidth property / option
         * Bar width of a single donut gauge segment.
         * Datatype: string
         * Defaultvalue: 16px
         */
        radialBarWidth: string;
        /**
         * radialBarSpacing property / option
         * Space between one and another radial bar.
         * Datatype: string
         * Defaultvalue: 3px
         */
        radialBarSpacing: string;
        /**
         * innerRadius property / option
         * Distance between the center and the first donut gauge segment.
         * Datatype: string
         * Defaultvalue: 3px
         */
        innerRadius: string;
        /**
         * radialBarBackground property / option
         * Background color of the donut gauges segment.
         * Datatype: string
         * @ignore
         */
        radialBarBackground: string;
        /**
         * radialBarFillColor property / option
         * Fill color of the donut gauges segment.
         * Datatype: string
         * @ignore
         */
        radialBarFillColor: string;
        /**
         * minValue property / option
         * The smallest value that the StackedDonutGauge can represent. Defines the start value of the gauge.
         * Datatype: number
         * Defaultvalue: 0
         */
        minValue: number;
        /**
        * maxValue property / option
        * The biggest value that the StackedDonutGauge can represent. Defines the end value of the gauge.
        * Datatype: number
        * Defaultvalue: 100
        */
        maxValue: number;
        /**@ignore */
        startAngle: string;
        /**@ignore */
        endAngle: string;
        /**@ignore */
        clockwise: boolean;
        /**@ignore */
        animation: string;
        /**@ignore */
        autoAdjustment: boolean;
        /**
        * createTemplate
        * This method is called after the constructor.
        * You can set up your DOM elements here.
        * If you need reference to one of these elements, use the data-ref-element attribute.
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        createTemplate(): Promise<any> | null;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        /**
         * Update Layout from Page on Resize
         * and call the updateLayout function on the currently loaded page.
         * @resizeHandler (automatic call by resize the current element)
        **/
        resizeHandler(): void;
        /**
         * Configuration of the start size for the svg element. Default values
         */
        beforeInit(): void;
        /**
         * Creates svg elements and generates the associated svg paths with the given attributes from the segments
         * @param svgSize Size of the svg element, biggest side
         * @param segment Segment specific values to be drawn
         * @param id Position id, to assign the path to the dataset. Beginning with 0 for the inner path
         */
        drawDonut(svgSize: number, segment: any, id: number, faktor: number): void;
        /**
         * Draws only the label of the segment
         * @param segment Segment specific values to be drawn
         */
        drawLabel(psegment: any): void;
        /**
         * Converts a polar coordiante to a cartesian coordinate. Used in _drawDonut for calculating the svg paths
         * @param centerX Cartesian x value to identify the center of the svg element
         * @param centerY Cartesian y value to identify the center of the svg element
         * @param radius Radius of the path from the center of the svg element
         * @param angleInDegrees Angle in degrees 0 - 360
         */
        polarToCartesian(centerX: number, centerY: number, radius: number, angleInDegrees: number): void;
        /**
         * Creates the svg path attribute "d", which defines the path to be drawn
         * @param x CenterX of the svg element
         * @param y CenterY of the svg element
         * @param radius Radius of the path from the center
         * @param startAngle StartAngle of the path. Start of the drawing
         * @param endAngle EndAngle of the path. End of the drawing
         */
        describeArc(x: number, y: number, radius: number, startAngle: number, endAngle: number): void;
        /**
         * Calculate the percentage value in absoulute value from a total value
         * @param requiredValue Percentual Value. Can contain "%" to start the percentual calculation. If it does not contian "%", the calculation will return the absolute value
         * @param totalValue Value to be calculated percentual
         */
        getPixelValue(requiredValue: string, totalValue: number): void;
        /**
         * Remove the StackedDonutGaugeCore control and the connected VariableChangeHandlers
         * The work is done in the dispose super class.
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    interface IStackedDonutGaugeLegend extends VisiWin.UI.IControlBase {
        /**
         * @ignore
         */
        winControl?: any;
        /**
        * createTemplate
        * This method is called after the constructor.
        * You can set up your DOM elements here.
        * If you need reference to one of these elements, use the data-ref-element attribute.
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        createTemplate(): Promise<any> | null;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        /**
         * Assigns the data of the RepeaterElement with the bindingList
         */
        beforeInit(): void;
        /**
        * Sets the designerType to the repeaterElement, when the control initialization is completed
        */
        ready(element: VWElement): void;
        /**
        * Sets the designerType of the element to "Child", if the child is a winControl element
        */
        _setDesignerType(element: void): void;
        /**
         * Remove the StackedDonutGaugeLegend control and the connected VariableChangeHandlers
         * The work is done in the dispose super class.
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    interface IStackedDonutGaugeSegment extends VisiWin.UI.IVariableBase {
        /**
         * @ignore
         */
        fillColor: any;
        /**
         * @ignore
         */
        labelText: any;
        /**
         * @ignore
         */
        decimalPlaces: number;
        /**
         * Remove the StackedDonutGaugeLegend control and the connected VariableChangeHandlers
         * The work is done in the dispose super class.
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    interface IStackedDonutGauge extends VisiWin.UI.IControlBase {
        /**@ignore */
        showText: boolean;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.width|width}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textWidth
        **/
        textWidth: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.height|height}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textHeight
        **/
        textHeight: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.margin|margin}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textMargin
        **/
        textMargin: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.padding|padding}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textPadding
        **/
        textPadding: string;
        /**@ignore */
        useVariableText: boolean;
        /**@ignore */
        text: string;
        /**@ignore */
        localizableText: string;
        /**@ignore */
        positionInDonut: boolean;
        /**
        * CSS property
        * @see {@link VisiWin.UI.Enums.AlignItems|textAlignment}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } textAlignment
        **/
        textAlignment: string;
        /**@ignore */
        lineClamp: number;
        /**@ignore */
        textWrapping: string;
        /**@ignore */
        textTrimming: string;
        /**@ignore */
        fontClass: string;
        /**@ignore */
        fontSize: string;
        /**@ignore */
        textContrast: number;
        /**@ignore */
        textColor: string;
        /**@ignore */
        uppercase: boolean;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.backgroundColor|backgroundColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } backgroundColor
        **/
        backgroundColor: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.foregroundColor|foregroundColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } foregroundColor
        **/
        foregroundColor: string;
        /**
        * CSS property
        * @see {@link VisiWin.UI.CSSProperties.borderColor|borderColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } borderColor
        **/
        borderColor: string;
        /**
        * The background-color CSS property sets the disabledBackgroundColor for a disabled element.<br>
        * @see {@link VisiWin.UI.CSSProperties.backgroundColor|backgroundColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } disabledBackgroundColor
        **/
        disabledBackgroundColor: string;
        /**
        * The color CSS property sets the foreground color value of a disabled element's text.<br>
        * @see {@link VisiWin.UI.CSSProperties.foregroundColor|foregroundColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } disabledForegroundColor
        **/
        disabledForegroundColor: string;
        /**
        * The border-color shorthand CSS property sets the color of a disabled element's border.
        * @see {@link VisiWin.UI.CSSProperties.borderColor|borderColor}.
        * @member { {@link VisiWin.UI.JSPrimitives.String|string} } disabledBorderColor
        **/
        disabledBorderColor: string;
        /**
         * localizableUnitText property / option
         * Localizable unit of the variable for the representation.
         * Datatype: string
         * Defaultvalue: null
         */
        localizableUnitText: string;
        /**
         * unitText property / option
         * Unit of the variable for the representation.
         * Datatype: string
         * Defaultvalue: null
         */
        unitText: string;
        /**
         * showLegend property / option
         * Property to define if the legend is visible or not.
         * Datatype: boolean
         * Defaultvalue: true
         */
        showLegend: boolean;
        /**
        * legendPosition property / option
        * Position of the legend in the control
        * Datatype: string
        * Defaultvalue: right
        *  Valid values: Left | Top | Right | Bottom
        */
        legendPosition: string;
        /**
        * showLegend property / option
        * Alignment of the legend in the specified position
        * Datatype: string
        * Defaultvalue: Center
        * Valid values: Left | Top | Right | Bottom | Center
        */
        legendAlignment: string;
        /**
        * createTemplate
        * This method is called after the constructor.
        * You can set up your DOM elements here.
        * If you need reference to one of these elements, use the data-ref-element attribute.
        * @returns {Promise} null if template is ready, or a promise to processElements
        */
        createTemplate(): Promise<any> | null;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        /**
         * Registers the segments which are definded in the super element.
         * Adds event listener for layout changes
         * @param controlType
         * @param action ActionEvent from the html element will be registered
         * @param element html element which will be registered
         * @param options
         */
        registerChild(controlType: string, action: string, element: VWElement, options: any): boolean;
        /**
         * Activates the segmentsChangedHandler with "ready", when the control initialization is completed
         */
        ready(): void;
        /**
         * Handles value changes in the segments collection and forwards them to the StackedDonutGaugeCore and Legend
         * @param changes Type of the change event
         */
        _segmentsChangedHandler(changes: void): void;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        /**
         * Remove the StackedDonutGauge control.
         * The work is done in the dispose super class.
        **/
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class VideoPlayer extends VisiWin.UI.ControlBase implements IVideoPlayer {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            source: {
                propertyType: string;
                type: string;
            };
            autoplay: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            controls: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            loop: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            muted: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            preload: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            previewImage: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            altSource: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        source: string;
        private videoItemCollection;
        controls: boolean;
        autoplay: boolean;
        loop: boolean;
        muted: boolean;
        private _videoElement;
        private elementWidth;
        private elementHeight;
        private _SOURCETAG;
        private cssStyles;
        constructor(element: VWElement, options: any);
        /** @ignore */
        createTemplate(): Promise<any>;
        /** @ignore */
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        isValidSource(src: string): boolean;
        getSourceType(src: string): string;
        private _updateVideoElement;
        /** @ignore */
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    interface IVideoPlayer extends VisiWin.UI.IControlBase {
        /**
        * @description Contains the source file.
        * @member { string } source
        */
        source: string;
        /**
        * @description Wether to show the video controls: Start/Stop, Scroll, Mute.
        * @member { boolean } controls
        */
        controls: boolean;
        /**
        * @description Wether to show the video plays automatically after loading.
        * @member { boolean } autoplay
        */
        autoplay: boolean;
        /**
        * @description Wether to show the video starts again after the end.
        * @member { boolean } loop
        */
        loop: boolean;
        /**
        * @description Wether to show the video video plays with sound.
        * @member { boolean } loop
        */
        muted: boolean;
        /**
        * @method Checks if the source corresponds to the correct format: mp4 | webm | ogg
        * @name isValidSource
        * @param {string} src Source string to be checked
        * @returns boolean
        */
        isValidSource(src: string): boolean;
        /**
        * @method Returns the format type of the given source.
        * @name getSourceType
        * @param {string}  Source string to be checked
        * @returns string
        */
        getSourceType(src: string): string;
    }
}
declare module VisiWin.UI {
    /** @ignore */
    class VideoItem extends VisiWin.UI.ControlBase implements IVideoItem {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alternativeSource: {
                propertyType: string;
                type: string;
            };
            minRes: {
                propertyType: string;
                type: string;
            };
            maxRes: {
                propertyType: string;
                type: string;
            };
            resolution: {
                propertyType: string;
                type: string;
            };
            type: {
                propertyType: string;
                type: string;
            };
        };
        alternativeSource: string;
        minRes: string;
        maxRes: string;
        resolution: string;
        type: string;
        constructor(element: VWElement, options: any);
        /** @ignore */
        _updateLayout(changes: any): void;
        /** @ignore */
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    interface IVideoItem extends VisiWin.UI.IControlBase {
        /** @ignore */
        alternativeSource: string;
        /** @ignore */
        minRes: string;
        /** @ignore */
        maxRes: string;
        /**
         * @ignore
         */
        resolution: string;
        /**
         * @ignore
         */
        type: string;
    }
}
declare namespace VisiWin.UI.Video {
    const VIDEOTYPES: {
        readonly MP4: "mp4";
        readonly WEBM: "webm";
        readonly OGG: "ogg";
        readonly UNKNOWN: "unknown";
    };
    type VIDEOTYPES = typeof VIDEOTYPES[keyof typeof VIDEOTYPES];
}
declare namespace VisiWin.UI {
    class PDFViewer extends VisiWin.UI.ControlBase {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            source: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            navpanes: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            toolbar: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            statusbar: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            scrollbar: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            zoom: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            startpage: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
        };
        source: string;
        toolbar: boolean;
        startpage: number;
        zoom: number;
        private _embedPdfElement;
        private _objectPdfElement;
        private navpanes;
        private statusbar;
        private scrollbar;
        private cssStyles;
        constructor(element: VWElement, options: any);
        /** @ignore */
        createTemplate(): Promise<any>;
        /** @ignore */
        _updateLayout(changes: any): void;
        isValidSource(src: string): boolean;
    }
}
declare namespace VisiWin.UI {
    interface IPDFViewer extends VisiWin.UI.IControlBase {
        /**
        * @description Contains the source filename, which will be loaded in the pdf viewer.
        * @member { string } source
        */
        source: string;
        /**
        * @description attribute Should the toolbar of the PDF viewer built into the browser be displayed?
        * @member { boolean } toolbar
        */
        toolbar: boolean;
        /**
        * @description Number of the page to which the PDF file should jump when it is first loaded.
        * @member { number } startpage
        */
        startpage: number;
        /**
        * @description The zoom property specifies the scaling factor for the PDF control.
        * 0 : full page width, standard, automatic.
        * 1 to infinite : percentage of the zoom.
        * @member { number } zoom
        */
        zoom: number;
        /**
        * @method Checks if the source name corresponds to the correct format: 'pdf'.
        * @name isValidSource
        * @param {string} src Source string to be checked
        * @returns boolean
        */
        isValidSource(src: string): boolean;
        /**
         * @ignore
         */
        navpanes: boolean;
        /**
         * @ignore
         */
        statusbar: boolean;
        /**
        * @ignore
        */
        scrollbar: boolean;
    }
}
declare namespace VisiWin.UI {
    class AlarmIndicator extends VisiWin.UI.ControlBase implements IAlarmIndicator {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            iconFont: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbolSize: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            autoScale: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            showDefaultSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            defaultSymbol: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            badgeForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            badgeBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            defaultForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            defaultBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            badgeSize: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            autoScaleBadge: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            showBadge: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            autoScaleBadgeTextSize: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            badgeTextSize: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            badgePosition: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            circularBackground: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            showBackground: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            alarmIndicatorItems: {
                propertyType: string;
                type: string;
            };
            desiredGroups: {
                propertyType: string;
                type: string;
            };
        };
        cssStyles: {
            css: string;
        };
        iconFont: string;
        symbolType: string;
        symbolSize: string;
        autoScale: boolean;
        showDefaultSymbol: boolean;
        defaultSymbol: string;
        badgeForegroundColor: string;
        badgeBackgroundColor: string;
        defaultForegroundColor: string;
        defaultBackgroundColor: string;
        autoScaleBadge: boolean;
        badgeSize: string;
        showBadge: boolean;
        autoScaleBadgeTextSize: boolean;
        badgeTextSize: string;
        badgePosition: string;
        circularBackground: boolean;
        showBackground: boolean;
        desiredGroups: string;
        alarmIndicatorItems: string;
        private alarmIndicatorItemsCollection;
        private myCurrentAlarms;
        private myAlarmService;
        private initHandler;
        private changeHandler;
        private newHandler;
        private clearHandler;
        private _containerElement;
        private _counterElement;
        private _newElement;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        updateAlarmIndicator(): any;
        InitAlarm(e: VisiWin.System.Alarm.IAlarmItem): void;
        NewAlarm(e: VisiWin.System.Alarm.IAlarmItem): void;
        ChangeAlarm(e: VisiWin.System.Alarm.IAlarmItem): void;
        ClearAlarm(e: VisiWin.System.Alarm.IAlarmItem): void;
        attach(): Promise<any> | null;
        detach(): Promise<any> | null;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
    }
}
interface AlarmCountObj {
    alarmClassName: string;
    count: number;
    countActive: number;
    countInactive: number;
    symbolActive: string;
    symbolInactive: string;
    foregroundColor: string;
    backgroundColor: string;
    foregroundColorInactive: string;
    backgroundColorInactive: string;
    priority: number;
    iconFont: string;
    symbolType: string;
}
interface CurrentAlarmObj {
    alarmClassName: string;
    alarmState: number;
    alarmPriority: number;
    backColor: string;
    foreColor: string;
}
declare namespace VisiWin.UI {
    interface IAlarmIndicator extends VisiWin.UI.IControlBase {
        /**
        * @ignore
        */
        iconFont: string;
        /**
        * @ignore
        */
        symbolType: string;
        /**
        * @ignore
        */
        symbolSize: string;
        /**
        * @description Wether to automatically scale the symbol according to the control size.
        * @member { boolean } autoScale
        */
        autoScale: boolean;
        /**
        * @description Wether to show the default symbol, when no other symbol is specified.
        * @member { boolean } showDefaultSymbol
        */
        showDefaultSymbol: boolean;
        /**
        * @description Selected symbol that is shown, when no other symbol is specified.
        * @member { string } defaultSymbol
        */
        defaultSymbol: string;
        /**
        * @description  Color of the number inside of the badge.
        * @member { string } badgeForegroundColor
        */
        badgeForegroundColor: string;
        /**
        * @description  Color of the background of the badge.
        * @member { string } badgeBackgroundColor
        */
        badgeBackgroundColor: string;
        /**
        * @description Color of the symbol which is used, when no foreground color is specified.
        * @member { string } defaultForegroundColor
        */
        defaultForegroundColor: string;
        /**
        * @description Color of the background which is used, when no background color is specified.
        * @member { string } defaultBackgroundColor
        */
        defaultBackgroundColor: string;
        /**
        * @description  Wether to automatically scale the badge according to the control size.
        * @member { boolean } autoScaleBadge
        */
        autoScaleBadge: boolean;
        /**
        * @description  Size of the badge, when autoscale is disabled.
        * @member { string } badgeSize
        */
        badgeSize: string;
        /**
        * @description  Wether to show the badge.
        * @member { boolean } showBadge
        */
        showBadge: boolean;
        /**
        * @description  Wether to automatically scale the number inside of the badge according to the badge size.
        * @member { boolean } autoScaleBadgeTextSize
        */
        autoScaleBadgeTextSize: boolean;
        /**
        * @description  Size of the number inside of the badge, when autoscale is disabled.
        * @member { string } badgeTextSize
        */
        badgeTextSize: string;
        /**
        * @ignore
        */
        badgePosition: string;
        /**
        * @description Wether to make the background circular or as full control background.
        * @member { boolean } circularBackground
        */
        circularBackground: boolean;
        /**
        * @description Wether to show the colored background.
        * @member { boolean } showBackground
        */
        showBackground: boolean;
        /**
        * @description Filter for alarm groups. When specifying multiple groups, the alarm group names must be separated by a comma. No specification means that alarms of all groups are displayed.
        * @member { string } desiredGroups
        */
        desiredGroups: string;
        /**
        * @method Updates the alarm indicator to show the alarm with the highes priority.
        * @name updateAlarmIndicator
        */
        updateAlarmIndicator(): void;
    }
}
declare module VisiWin.UI {
    class AlarmIndicatorItem extends VisiWin.UI.ControlBase implements IAlarmIndicatorItem {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            className: {
                propertyType: string;
                type: string;
            };
            symbolActive: {
                propertyType: string;
                type: string;
            };
            symbolInactive: {
                propertyType: string;
                type: string;
            };
            foregroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            foregroundColorInactive: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            backgroundColorInactive: {
                propertyType: string;
                type: string;
                resourceValue: string[];
            };
            iconFont: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            priority: {
                propertyType: string;
                type: string;
            };
            useCustomPriority: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            alarmClassName: {
                propertyType: string;
                type: string;
            };
        };
        className: string;
        symbolActive: string;
        symbolInactive: string;
        foregroundColor: string;
        backgroundColor: string;
        foregroundColorInactive: string;
        backgroundColorInactive: string;
        iconFont: string;
        symbolType: string;
        alarmClassName: string;
        priority: number;
        useCustomPriority: boolean;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    interface IAlarmIndicatorItem extends VisiWin.UI.IControlBase {
        /**
        * @description Class name of the alarmclass defined in the server.
        * @member { string } className
        */
        alarmClassName: string;
        /**
        * @description Symbol which is shown, when the alarmclass has an active alarm.
        * @member { string } symbolActive
        */
        symbolActive: string;
        /**
        * @description Symbol which is shown, when the alarmclass has an inactive alarm.
        * @member { string } symbolInactive
        */
        symbolInactive: string;
        /**
        * @description Color of the symbol which is shown, when the alarmclass has an active alarm.
        * @member { string } foregroundColor
        */
        foregroundColor: string;
        /**
        * @description Color of the background which is shown, when the alarmclass has an active alarm.
        * @member { string } backgroundColor
        */
        backgroundColor: string;
        /**
        * @description Color of the symbol which is shown, when the alarmclass has an inactive alarm.
        * @member { string } foregroundColorInactive
        */
        foregroundColorInactive: string;
        /**
        * @description Color of the background which is shown, when the alarmclass has an inactive alarm.
        * @member { string } backgroundColorInactive
        */
        backgroundColorInactive: string;
        /**
        * @description Priority of the alarmclass, when the useCustomPriority property is checked.
        * @member { number } priority
        */
        priority: number;
        /**
        * @description Wether to use the priority definded in the priority property instead of the system priority.
        * @member { boolean } useCustomPriority
        */
        useCustomPriority: boolean;
        /**
        * @ignore
        */
        className: string;
        /**
        * @ignore
        */
        iconFont: string;
        /**
        * @ignore
        */
        symbolType: string;
    }
}
declare namespace VisiWin.UI {
    enum sandbox {
        "allowForms" = "allow-forms",
        "allowModals" = "allow-modals",
        "allowOrientationLock" = "allow-orientation-lock",
        "allowPointerLock" = "allow-pointer-lock",
        "allowPopups" = "allow-popups",
        "allowPopupsToEscapeSandbox" = "allow-popups-to-escape-sandbox",
        "allowPresentation" = "allow-presentation",
        "allowSameOrigin" = "allow-same-origin",
        "allowScripts" = "allow-scripts",
        "allowTopNavigation" = "allow-top-navigation",
        "allowTopNavigationByUserActivation" = "allow-top-navigation-by-user-activation"
    }
    class EmbeddedWebsite extends VisiWin.UI.ControlBase {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            src: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            srcdoc: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            referrerPolicy: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            useSandbox: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowForms: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowModals: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowOrientationLock: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowPointerLock: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowPopups: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowPopupsToEscapeSandbox: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowPresentation: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowSameOrigin: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowScripts: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowTopNavigation: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowTopNavigationByUserActivation: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allow: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            allowfullscreen: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            allowpaymentrequest: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            loading: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            name: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            variableName: {
                propertyType: string;
                type: string;
            };
            runtimeOnly: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        src: string;
        srcdoc: string;
        allow: string;
        allowfullscreen: boolean;
        allowpaymentrequest: boolean;
        loading: string;
        name: string;
        referrerPolicy: string;
        runtimeOnly: boolean;
        useSandbox: boolean;
        allowForms: boolean;
        allowModals: boolean;
        allowOrientationLock: boolean;
        allowPointerLock: boolean;
        allowPopups: boolean;
        allowPopupsToEscapeSandbox: boolean;
        allowPresentation: boolean;
        allowSameOrigin: boolean;
        allowScripts: boolean;
        allowTopNavigation: boolean;
        allowTopNavigationByUserActivation: boolean;
        variableName: string;
        private myVariableService;
        private myVariable;
        private _iFrameElement;
        constructor(element: VWElement, options: any);
        /** @ignore */
        createTemplate(): Promise<any>;
        /** @ignore */
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        private isValidSource;
        private updateIFrame;
        private setIFrameSource;
        private setIFrameSrcDoc;
        private setIFrameSandbox;
        private htmlDecode;
        private registerVariable;
        private removeVariable;
        private _changeHandlerVariable;
        private mVariableChanged;
        attach(): Promise<any> | null;
        detach(): Promise<any> | null;
        removeHandler(): void;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    interface IEmbeddedWebsite extends VisiWin.UI.IControlBase {
        /**
        * @description Specifies the address of the document to embed in the iframe
        * @member { string } src
        */
        src: string;
        /**
        * @description Specifies the HTML content of the page to show in the iframe
        * @member { string } srcdoc
        */
        srcdoc: string;
        /**
        * @description Specifies a feature policy for the iframe
        * @member { string } allow
        */
        allow: string;
        /**
        * @description Set to true if the iframe can activate fullscreen mode by calling the requestFullscreen() method
        * @description The default value is "false".
        * @member { boolean } allowfullscreen
        */
        allowfullscreen: boolean;
        /**
        * @description Set to true if a cross - origin iframe should be allowed to invoke the Payment Request API
        * @description The default value is "false".
        * @member { boolean } allowpaymentrequest
        */
        allowpaymentrequest: boolean;
        /**
        * @description Specifies whether a browser should load an iframe immediately or to defer loading of iframes until some conditions are met
        * @description The default value is "eager".
        * @member { string } loading
        */
        loading: string;
        /**
        * @description Specifies the name of an iframe
        * @member { string } name
        */
        name: string;
        /**
        * @description Specifies which referrer information to send when fetching the iframe
        * @description The default value is "strict-origin-when-cross-origin".
        * @member { string } referrerPolicy
        */
        referrerPolicy: string;
        /**
        * @description Enables an extra set of restrictions for the content in an iframe
        * @description The default value is "false".
        * @member { boolean } useSandbox
        */
        useSandbox: boolean;
        /**
        * @description Allows form submission
        * @description The default value is "false".
        * @member { boolean } allowForms
        */
        allowForms: boolean;
        /**
        * @description Allows to open modal windows
        * @description The default value is "false".
        * @member { boolean } allowModals
        */
        allowModals: boolean;
        /**
        * @description Allows to lock the screen orientation
        * @description The default value is "false".
        * @member { boolean } allowOrientationLock
        */
        allowOrientationLock: boolean;
        /**
        * @description Allows to use the Pointer Lock API
        * @description The default value is "false".
        * @member { boolean } allowPointerLock
        */
        allowPointerLock: boolean;
        /**
        * @description Allows popups
        * @description The default value is "false".
        * @member { boolean } allowPopups
        */
        allowPopups: boolean;
        /**
        * @description Allows popups to open new windows without inheriting the sandboxing
        * @description The default value is "false".
        * @member { boolean } allowPopupsToEscapeSandbox
        */
        allowPopupsToEscapeSandbox: boolean;
        /**
        * @description Allows to start a presentation session
        * @description The default value is "false".
        * @member { boolean } allowPresentation
        */
        allowPresentation: boolean;
        /**
        * @description Allows the iframe content to be treated as being from the same origin
        * @description The default value is "false".
        * @member { boolean } allowSameOrigin
        */
        allowSameOrigin: boolean;
        /**
        * @description Allows to run scripts
        * @description The default value is "false".
        * @member { boolean } allowScripts
        */
        allowScripts: boolean;
        /**
        * @description Allows the iframe content to navigate its top-level browsing context
        * @description The default value is "false".
        * @member { boolean } allowTopNavigation
        */
        allowTopNavigation: boolean;
        /**
        * @description Allows the iframe content to navigate its top-level browsing context, but only if initiated by user
        * @description The default value is "false".
        * @member { boolean } allowTopNavigationByUserActivation
        */
        allowTopNavigationByUserActivation: boolean;
        /**
        * @description Sets the VisiWin Variable, which contains the src content.
        * @member { string } variableName
        */
        variableName: string;
    }
}
declare module VisiWin.UI {
    class KeyStyleItem extends VisiWin.UI.ControlBase {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerSourceId: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            keyIdentifier: {
                propertyType: string;
                type: string;
            };
            keyWidth: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            keyHeight: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            keyMargin: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            keyBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyActiveBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyActiveForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyActiveBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyBorderRadius: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            keyBorderStyle: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            keyBorderWidth: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            fontClass: {
                propertyType: string;
                defaultValue: string;
            };
            fontSize: {
                propertyType: string;
                defaultValue: string;
            };
            fontWeight: {
                propertyType: string;
                defaultValue: string;
            };
            showSymbol: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
            iconFont: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            symbol: {
                propertyType: string;
                type: string;
            };
            symbolType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
        };
        keyWidth: string;
        keyHeight: string;
        keyMargin: string;
        keyIdentifier: string;
        keyBackgroundColor: string;
        keyForegroundColor: string;
        keyBorderColor: string;
        keyActiveBackgroundColor: string;
        keyActiveForegroundColor: string;
        keyActiveBorderColor: string;
        keyBorderRadius: string;
        keyBorderStyle: string;
        keyBorderWidth: string;
        fontClass: string;
        fontSize: string;
        fontWeight: string;
        showSymbol: boolean;
        iconFont: string;
        symbol: string;
        symbolType: string;
        constructor(element: VWElement, options: any);
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class TouchKeyboard extends VisiWin.UI.ControlBase implements ITouchKeyboard {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            registerTargetId: {
                propertyType: string;
                defaultValue: string;
            };
            touchKeyboardType: {
                propertyType: string;
                type: string;
                defaultValue: Enums.TouchKeyboardType;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyActiveBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyActiveForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyActiveBorderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            keyBorderRadius: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            keyBorderStyle: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            keyBorderWidth: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            fontClass: {
                propertyType: string;
                defaultValue: string;
            };
            fontSize: {
                propertyType: string;
                defaultValue: string;
            };
            fontWeight: {
                propertyType: string;
                defaultValue: string;
            };
            keyStyleItems: {
                propertyType: string;
            };
        };
        cssStyles: {
            css: string;
        };
        private _inputElement;
        private _touchKeyboard;
        private keyboard;
        private keyboardresource;
        private _boundInputHandler;
        private _boundFocusHandler;
        private _boundKeyDownHandler;
        private _boundDocumentClickHandler;
        private dataSource;
        private limitmaxIdentifier;
        private limitminIdentifier;
        private numericVarInIdentifier;
        private textVarInIdentifier;
        private dialogViewIdentifier;
        private keyboardCaretPosition;
        touchKeyboardType: Enums.TouchKeyboardType;
        backgroundColor: string;
        borderColor: string;
        keyBackgroundColor: string;
        keyForegroundColor: string;
        keyBorderColor: string;
        keyActiveBackgroundColor: string;
        keyActiveForegroundColor: string;
        keyActiveBorderColor: string;
        keyBorderRadius: string;
        keyBorderStyle: string;
        keyBorderWidth: string;
        fontClass: string;
        fontSize: string;
        fontWeight: string;
        private keyStyleItemsCollection;
        constructor(element: VWElement, options: any);
        /** @ignore */
        createTemplate(): Promise<any>;
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        /** @ignore */
        _updateLayout(changes: any): void;
        /** @ignore */
        _updateColors(changes: any): void;
        _documentClickHandler(e: any): void;
        _inputHandler(e: any): void;
        _focusHandler(e: any): void;
        getDataContext(): any;
        getFontWeight(value: string): string;
        addClassToKeys(classNew: string, classOld: string): void;
        findCssRule(selector: string): CSSStyleRule | null;
        initKeyboard(): void;
        adoptButtonStyleItems(): void;
        removeCSSRulesBySelectors(selectorList: any): void;
        initMinMax(): void;
        toggleDecPoint(): void;
        onChange(input: any): void;
        inputPyhsicalChange(input: any): void;
        checkDecimalPlaces(input: any): boolean;
        checkLimits(input: any): void;
        setInputCaretPosition(elem: any, pos: any): void;
        hideSoftKeyboard(element: any): void;
        onKeyPress(button: any): void;
        onKeyReleased(button: any): void;
        setDecimalPoint(keyboardinput: string): void;
        setPosNeg(keyboardinput: string): void;
        isLayoutExistingInJson(layoutname: string): boolean;
        handleLayoutSwitch(layoutid: string): void;
        replaceStringAt(value: string, index: number, replacement: any): string;
        initializeButtonStylesJson(): void;
        adoptStyleFromJson(stylejson: any): void;
        onLanguageChanged(args: any): void;
        _keyDownHandler(event: KeyboardEvent): void;
        closeAndWrite(): void;
        getDialogControl(element: any): VWElement;
        createHandler(): void;
        removeHandler(): void;
        attach(): Promise<any>;
        detach(): Promise<any> | null;
    }
}
declare namespace VisiWin.UI {
    interface ITouchKeyboard extends VisiWin.UI.IControlBase {
        /**
        * @ignore
        */
        touchKeyboardType: Enums.TouchKeyboardType;
    }
}
declare namespace VisiWin.UI {
    class DataTemplateSelector extends VisiWin.UI.VariableBase {
        private properties;
        private cssStyles;
        private dataTemplateEditMode;
        private dataTemplateString;
        private dataTemplateNumber;
        private dataTemplateBoolean;
        private dataTemplateDate;
        private dataTemplate;
        private isInitalized;
        private dataSource;
        private index;
        constructor(element: VWElement, options: any);
        createTemplate(): void;
        _updateLayout(changes: any): void;
        loadTemplate(element: HTMLElement, dataSource: any, index: number): void;
        _boundDataTemplateReady: any;
        dataTemplateReady(dataTemp: any): void;
        getDataTemplate(myProperty: any): void;
    }
}
declare namespace VisiWin.UI {
    class ItemsContainer extends VisiWin.UI.RepeaterBase implements IItemsContainer {
        private properties;
        private cssStyles;
        private _orientation;
        get orientation(): VisiWin.UI.Enums.Orientation;
        set orientation(value: VisiWin.UI.Enums.Orientation);
        private _alignItems;
        get alignItems(): string;
        set alignItems(value: string);
        private _justifyContent;
        get justifyContent(): string;
        set justifyContent(value: string);
        private _itemCount;
        private _itemsCollection;
        private _checkedChangedEventType;
        constructor(element: VWElement, options: any);
        registerItem(controlType: string, action: string, item: VWElement, options: any): any;
        _updateLayout(changes: any): void;
        _setDesignerType(item: VWElement): void;
        itemFromIndex(index: number): any;
        dispose(): boolean;
        private indexUpdated;
        setSelectedValue(selectedValue: string): void;
        setSelectedIndex(selectedIndex: number): void;
        setOrientation(orientation: VisiWin.UI.Enums.Orientation): void;
        setAlignItems(alignItems: string): void;
        setJustifyContent(justifyContent: string): void;
    }
}
declare module VisiWin.UI {
    interface IItemsContainer extends VisiWin.UI.IControlBase {
        /**
        * @description Subset of the css flex-direction property.
        * @enum Orientation
        * @see {@link VisiWin.UI.Enums.Orientation|orientation(Enum)} <br>
        * defaultValue: VisiWin.UI.Enums.Orientation.Vertical
        */
        orientation: any;
        /**
        * @description Subset of the css align-items property.
        * @enum AlignItems
        * @see {@link VisiWin.UI.CSSProperties.alignItems|alignItems(Enum)} <br>
        * defaultValue: "Start"
        */
        alignItems: any;
        /**
        * @description Subset of the css justify-content property.
        * @enum JustifyContent
        * @see {@link VisiWin.UI.CSSProperties.justifyContent|justifyContent(Enum)} <br>
        * defaultValue: "Start"
        */
        justifyContent: any;
        /**
        * @method Registers an inlineItem to the itemsCollection and attaches eventListener
        * @name registerItem
        * @param {string} controlType unused
        * @param {string} action determines if the item should be registered
        * @param {VWElement} item item to be registered
        * @param {any} options unused
        */
        registerItem(controlType: string, action: string, item: VWElement, options: any): any;
        /**
        * @method Gets the ListItem from the index
        * @name itemFromIndex
        * @param {number} index new selected index
        */
        itemFromIndex(index: number): any;
        /**
        * @method Sets the selectedIndexof the itemsContainer
        * @name setSelectedIndex
        * @param {number} selectedIndex new selected index
        */
        setSelectedIndex(selectedIndex: number, selectedIndexOld: number): any;
        /**
        * @method Sets the selectedValue of the itemsContainer
        * @name setSelectedValue
        * @param {any} selectedValue new selectedValue
        */
        setSelectedValue(selectedValue: string): any;
        /**
        * @method Sets the orientation property
        * @name setSelectedValue
        * @param {VisiWin.UI.Enums.Orientation} orientation
        */
        setOrientation(orientation: VisiWin.UI.Enums.Orientation): any;
        /**
        * @method Sets the alignItems property
        * @name setAlignItems
        * @param {string} alignItems
        */
        setAlignItems(alignItems: string): any;
        /**
        * @method Sets the justifyContent property
        * @name setJustifyContent
        * @param {string} justifyContent
        */
        setJustifyContent(justifyContent: string): any;
        /**
        * public method: dispose destroy the control
        * @name dispose
        * @return:bool is true, dispose subtree will be call after dispose
        */
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    class ListBox extends VisiWin.UI.ControlBase implements IListBox {
        private properties;
        private cssStyles;
        private _itemsContainer;
        private _inlineItems;
        private _itemsLoaded;
        private _boundItemsLoaded;
        private _boundItemInserted;
        private _boundSelectedIndexChangedHandler;
        private _dataListeners;
        private _itemsLoadedEventType;
        private _itemInsertedEventType;
        private _itemChangedEventType;
        private _itemMovedEventType;
        private _itemRemovedEventType;
        private _itemsReloadedEventType;
        private observe;
        private selectedItem;
        private triggerData;
        private itemInsertedTriggerData;
        private itemChangedTriggerData;
        private itemMovedTriggerData;
        private itemRemovedTriggerData;
        private itemsReloadedTriggerData;
        selectedIndex: number;
        selectedValue: string;
        selectionMode: VisiWin.UI.Enums.SelectionMode;
        renderMode: VisiWin.UI.Enums.RenderMode;
        listItemStyle: string;
        dataSource: any;
        dataTemplate: any;
        orientation: VisiWin.UI.Enums.Orientation;
        alignItems: any;
        justifyContent: any;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        createHandler(): void;
        removeHandler(): void;
        _addDataListeners(): void;
        _removeDataListeners(): void;
        private createObserver;
        _onSelectedIndexChangedHandler(args: any): void;
        _onItemsLoaded(): void;
        _onItemInserted(args: any): void;
        _onItemChanged(args: any): void;
        _onItemMoved(args: any): void;
        _onItemRemoved(args: any): void;
        _onItemsReloaded(args: any): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        private _setListItemStyle;
        getSelectedItemData(): any;
        getListItemFromIndex(index: number): any;
        setAuthorization(disabled: boolean, authorizationMode: VisiWin.UI.Enums.AuthorizationMode, authorizationRight: string): void;
        getListItemFromKey(key: string): any;
        getListItemCloneFromIndex(index: number): any;
        setItemsContainerSelectedIndex(selectedIndex: number, selectedIndexOld: number): void;
        setItemsContainerDataSource(dataSource: any): void;
        setItemsContainerDataTemplate(dataTemplate: any): void;
        setSelectionMode(selectionMode: any): void;
        setItemsContainerSelectedValue(selectedValue: string, selectedValueOld: string): void;
    }
}
/**
* @namespace
* @name VisiWin.UI
*/
declare namespace VisiWin.UI {
    /**
    * @class
    * @name VisiWin.UI.IListBox
    * @description UI Control that provides the ability to create ListItems from a datasource or inline items
    * @memberof VisiWin.UI
    */
    interface IListBox extends VisiWin.UI.IControlBase {
        /**
        * @description Represents the position (index) of the selected/checked ListItem
        * @member { number } selectedIndex
        * defaultValue: -1
        */
        selectedIndex: number;
        /**
        * @description Represents the value of the selected/checked ListItem
        * @member { string } selectedValue
        * defaultValue: ""
        */
        selectedValue: string;
        /**
        * @description Defines the selection mode, which indicates whether a ListItem can be selected or not.
        * @enum VisiWin.UI.Enums.SelectionMode
        * defaultValue: VisiWin.UI.Enum.SelectionMode.None
        */
        selectionMode: VisiWin.UI.Enums.SelectionMode;
        /**
        * @description Defines the selection mode, which indicates whether a ListItem can be selected or not.
        * @enum VisiWin.UI.Enums.SelectionMode
        * defaultValue: VisiWin.UI.Enum.SelectionMode.None
        */
        renderMode: VisiWin.UI.Enums.RenderMode;
        /**
        * @description Sets the styling for all inline ListItems
        * @member { string } listItemStyle
        * defaultValue: "Default"
        */
        listItemStyle: string;
        /**
        * @description Sets the dataSource, which is used to generate ListItems
        * @member { any } dataSource
        * defaultValue:
        */
        dataSource: any;
        /**
        * @description Sets the dataTemplate, which is used as a Template to generate ListItems
        * @member { any } dataTemplate
        * defaultValue:
        */
        dataTemplate: any;
        /**
        * @description Subset of the css flex-direction property.
        * @enum Orientation
        * @see {@link VisiWin.UI.Enums.Orientation|orientation(Enum)} <br>
        * defaultValue: VisiWin.UI.Enums.Orientation.Vertical
        */
        orientation: any;
        /**
        * @description Subset of the css align-items property.
        * @enum AlignItems
        * @see {@link VisiWin.UI.CSSProperties.alignItems|alignItems(Enum)} <br>
        * defaultValue: "Start"
        */
        alignItems: any;
        /**
        * @description Subset of the css justify-content property.
        * @enum JustifyContent
        * @see {@link VisiWin.UI.CSSProperties.justifyContent|justifyContent(Enum)} <br>
        * defaultValue: "Start"
        */
        justifyContent: any;
        /**
        * @method Returns a copy of the ListItem of the selected index from the itemsContainer
        * @name getListItemFromIndex
        * @param {number}  index selected index
        * @returns ListItem
        */
        getListItemFromIndex(index: number): any;
        /**
        * @method Returns the ListItem of the selected key from the itemsContainer
        * @name getListItemFromKey
        * @param {string}  key selected key
        * @returns ListItem
        */
        getListItemFromKey(key: string): any;
        /**
        * @method Returns the ListItem of the selected key from the itemsContainer
        * @name getListItemCloneFromIndex
        * @param {number}  index selected index
        * @returns ListItem
        */
        getListItemCloneFromIndex(index: number): any;
        /**
        * @method Sets the authorization for the itemsContainer
        * @name setAuthorization
        * @param {boolean} disabled disabled
        * @param {VisiWin.UI.Enums.AuthorizationMode} authorizationMode authorizationMode
        * @param {string} authorizationRight authorizationRight
        */
        setAuthorization(disabled: boolean, authorizationMode: VisiWin.UI.Enums.AuthorizationMode, authorizationRight: string): any;
        /**
        * @method Sets the selectedIndex of the itemsContainer depending on the selection mode
        * @name setItemsContainerSelectedIndex
        * @param {number} selectedIndex new selected index
        * @param {number} selectedIndexOld old selected index
        */
        setItemsContainerSelectedIndex(selectedIndex: number, selectedIndexOld: number): any;
        /**
        * @method Sets the dataSource of the itemsContainer
        * @name setItemsContainerDataSource
        * @param {any} dataSource datasource
        */
        setItemsContainerDataSource(dataSource: any): any;
        /**
        * @method Sets the dataTemplate of the itemsContainer
        * @name setItemsContainerDataTemplate
        * @param {any} dataTemplate dataTemplate
        */
        setItemsContainerDataTemplate(dataTemplate: any): any;
        /**
        * @method Sets the selectionMode of each child
        * @name setSelectionMode
        * @param {any} selectionMode selectionMode
        */
        setSelectionMode(selectionMode: any): any;
        /**
        * @method Sets the selectedValue of the itemsContainer depending on the selection mode
        * @name setItemsContainerSelectedValue
        * @param {any} selectedValue new selectedValue
        * @param {any} selectedValueOld old selectedValue
        */
        setItemsContainerSelectedValue(selectedValue: string, selectedValueOld: string): any;
    }
}
declare namespace VisiWin.UI {
    class ListItem extends VisiWin.UI.ItemBase implements IListItem {
        private properties;
        private cssStyles;
        private _symbolControl;
        private _primaryTextControl;
        private _secondaryTextControl;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        _updateColors(changes: any): void;
        _updateLayout(changes: any): void;
    }
}
declare module VisiWin.UI {
    interface IListItem extends VisiWin.UI.IControlBase {
    }
}
/**
* @namespace
* @name VisiWin.UI
*/
declare namespace VisiWin.UI {
    /**
    * @class
    * @name VisiWin.UI.ISelectBox
    * @description UI Control that provides the ability to create SelectBoxItem from a datasource or inline items
    * @memberof VisiWin.UI
    */
    interface ISelectBox extends VisiWin.UI.IControlBase {
        /**
        * @description Represents the position (index) of the selected/checked SelectBoxItem
        * @member { number } selectedIndex
        * defaultValue: -1
        */
        selectedIndex: number;
        /**
        * @description Represents the value of the selected/checked SelectBoxItem
        * @member { string } selectedValue
        * defaultValue: ""
        */
        selectedValue: string;
        /**
        * @description Sets the dataSource, which is used to generate SelectBoxItem
        * @member { any } dataSource
        * defaultValue:
        */
        dataSource: any;
        /**
        * @description Sets the dataTemplate, which is used as a Template to generate SelectBoxItem
        * @member { any } dataTemplate
        * defaultValue:
        */
        dataTemplate: any;
    }
}
declare namespace VisiWin.UI {
    class SelectBox extends VisiWin.UI.ControlBase implements ISelectBox {
        private properties;
        private cssStyles;
        variant: string;
        borderRadius: string;
        selectedValue: string;
        alignItems: string;
        justifyContent: string;
        outlined: boolean;
        error: boolean;
        itemStyle: string;
        listType: string;
        dataSource: string;
        dataTemplate: string;
        watermarkText: string;
        localizableWatermarkText: string;
        showLabelSymbol: boolean;
        labelIconFont: string;
        labelSymbol: string;
        labelSymbolType: string;
        labelSymbolSize: string;
        labelSymbolMargin: string;
        labelSymbolPosition: string;
        labelContainerWidth: string;
        labelContainerHeight: string;
        labelContainerMargin: string;
        labelContainerPadding: string;
        showLabel: boolean;
        labelWidth: string;
        labelHeight: string;
        labelMargin: string;
        labelPadding: string;
        labelTextAlignment: string;
        labelLineClamp: number;
        labelTextWrapping: string;
        labelTextTrimming: string;
        labelFontClass: string;
        labelFontSize: string;
        labelFontWeight: string;
        labelLineHeight: string;
        labelTextContrast: number;
        labelUppercase: boolean;
        labelPosition: string;
        containerWidth: string;
        containerHeight: string;
        containerMargin: string;
        containerPadding: string;
        textContainerWidth: string;
        textContainerHeight: string;
        textContainerMargin: string;
        textContainerPadding: string;
        showPrimaryText: boolean;
        primaryTextWidth: string;
        primaryTextHeight: string;
        primaryTextMargin: string;
        primaryTextPadding: string;
        primaryText: string;
        localizablePrimaryText: string;
        primaryTextAlignment: string;
        primaryTextLineClamp: number;
        primaryTextWrapping: string;
        primaryTextTrimming: string;
        primaryTextFontClass: string;
        primaryTextFontSize: string;
        primaryTextFontWeight: string;
        primaryTextLineHeight: string;
        primaryTextContrast: number;
        primaryTextUppercase: boolean;
        showSecondaryText: boolean;
        secondaryTextWidth: string;
        secondaryTextHeight: string;
        secondaryTextMargin: string;
        secondaryTextPadding: string;
        secondaryText: string;
        localizableSecondaryText: string;
        secondaryTextAlignment: string;
        secondaryTextLineClamp: number;
        secondaryTextWrapping: string;
        secondaryTextTrimming: string;
        secondaryTextFontClass: string;
        secondaryTextFontSize: string;
        secondaryTextFontWeight: string;
        secondaryTextLineHeight: string;
        secondaryTextContrast: number;
        secondaryTextUppercase: boolean;
        showSymbol: boolean;
        iconFont: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        floatingLabelFieldMargin: string;
        showFloatingLabel: boolean;
        floatingLabelWidth: string;
        floatingLabelHeight: string;
        floatingLabelMargin: string;
        floatingLabelPadding: string;
        floatingLabelText: string;
        localizableFloatingLabelText: string;
        floatingLabelTextAlignment: string;
        floatingLabelLineClamp: number;
        floatingLabelTextWrapping: string;
        floatingLabelTextTrimming: string;
        floatingLabelFontClass: string;
        floatingLabelFontSize: string;
        floatingLabelFontWeight: string;
        floatingLabelLineHeight: string;
        floatingLabelTextContrast: number;
        floatingLabelUppercase: boolean;
        floatingLabelFixed: boolean;
        floatingLabelTransform: string;
        floatingLabelTransition: string;
        floatingLabelOutlineWidth: string;
        floatingLabelOutlineStyle: string;
        checkedFloatingLabelTransform: string;
        uncheckedFloatingLabelTransform: string;
        showStateSymbol: boolean;
        stateSymbolIconFont: string;
        openedStateSymbol: string;
        closedStateSymbol: string;
        stateSymbolType: string;
        stateSymbolSize: string;
        stateSymbolMargin: string;
        showUnderline: boolean;
        underlineOpacity: number;
        checkedUnderlineOpacity: number;
        underlineTransition: string;
        underlineTransform: string;
        checkedUnderlineTransform: string;
        menuItems: string;
        menuWidth: string;
        menuHeight: string;
        menuMargin: string;
        menuPadding: string;
        menuBorderWidth: string;
        menuBorderStyle: string;
        menuBorderRadius: string;
        menuShadow: string;
        menuPlacement: string;
        selectedIndex: number;
        popoverId: string;
        showHelperText: boolean;
        helperTextWidth: string;
        helperTextHeight: string;
        helperTextMargin: string;
        helperTextPadding: string;
        helperText: string;
        localizableHelperText: string;
        helperTextAlignment: string;
        helperTextLineClamp: number;
        helperTextWrapping: string;
        helperTextTrimming: string;
        helperTextFontClass: string;
        helperTextFontSize: string;
        helperTextFontWeight: string;
        helperTextLineHeight: string;
        helperTextContrast: number;
        helperTextUppercase: boolean;
        showErrorText: boolean;
        errorTextWidth: string;
        errorTextHeight: string;
        errorTextMargin: string;
        errorTextPadding: string;
        errorText: string;
        localizableErrorText: string;
        errorTextAlignment: string;
        errorTextLineClamp: number;
        errorTextWrapping: string;
        errorTextTrimming: string;
        errorTextFontClass: string;
        errorTextFontSize: string;
        errorTextFontWeight: string;
        errorTextLineHeight: string;
        errorTextContrast: number;
        errorTextUppercase: boolean;
        overflowErrorText: boolean;
        backgroundColor: string;
        hoverBackgroundColor: string;
        checkedBackgroundColor: string;
        floatingLabelBackgroundColor: string;
        labelForegroundColor: string;
        labelSymbolForegroundColor: string;
        primaryTextForegroundColor: string;
        secondaryTextForegroundColor: string;
        symbolForegroundColor: string;
        floatingLabelForegroundColor: string;
        checkedFloatingLabelForegroundColor: string;
        stateSymbolForegroundColor: string;
        helperTextForegroundColor: string;
        errorColor: string;
        borderColor: string;
        hoverBorderColor: string;
        checkedBorderColor: string;
        underlineColor: string;
        checkedUnderlineColor: string;
        menuBackgroundColor: string;
        menuBorderColor: string;
        containerBackgroundColor: string;
        floatingLabelOutlineColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        disabledFloatingLabelOutlineColor: string;
        private _itemsLoaded;
        private _labelControl;
        private _containerElement;
        private _fieldContainerElement;
        private _textContainerElement;
        private _primaryTextControl;
        private _secondaryTextControl;
        private _symbolControl;
        private _floatingLabelFieldElement;
        private _floatingLabelControl;
        private _stateSymbolControl;
        private _underlineElement;
        private _menuElement;
        private _helperTextControl;
        private _errorTextControl;
        private _popoverElement;
        private _renderItem;
        private _notchElement;
        private selectedItem;
        private _inlineItems;
        private _clone;
        private _itemsCache;
        private _showSymbolSelectBox;
        private triggerData;
        private observe;
        private _boundPopoverHandler;
        private _boundHoverInHandler;
        private _boundHoverOutHandler;
        private _boundBeforeShowChangedHandler;
        private _boundBeforeHideChangedHandler;
        private _boundItemsLoaded;
        private _boundSelectedIndexChangedHandler;
        private _dataListeners;
        private _itemsLoadedEventType;
        private _itemInsertedEventType;
        private _itemChangedEventType;
        private _itemMovedEventType;
        private _itemRemovedEventType;
        private _itemsReloadedEventType;
        private itemInsertedTriggerData;
        private itemChangedTriggerData;
        private itemMovedTriggerData;
        private itemRemovedTriggerData;
        private itemsReloadedTriggerData;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        createHandler(): void;
        removeHandler(): void;
        _addDataListeners(): void;
        _removeDataListeners(): void;
        _onSelectedIndexChangedHandler(args: any): void;
        _onItemInserted(args: any): void;
        _onItemChanged(args: any): void;
        _onItemMoved(args: any): void;
        _onItemRemoved(args: any): void;
        _onItemsReloaded(args: any): void;
        getSelectedItemData(): any;
        _onItemsLoaded(): void;
        private __checked;
        get checked(): boolean;
        set checked(value: boolean);
        set open(value: boolean);
        private _errorMode;
        get errorMode(): boolean;
        set errorMode(value: boolean);
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        _setVariant(style: any): void;
        _setSelectOptions(item: any): void;
        _popoverHandler(args: any): void;
        _setFloatingLabelPosition(position: string): void;
        _hoverInHandler(args: any): void;
        _hoverOutHandler(args: any): void;
        _beforeShowChangedHandler(args: any): void;
        _beforeHideChangedHandler(args: any): void;
        _setitemStyle(container: any): void;
        getItemFromIndex(index: number): any;
        getItemCloneFromIndex(index: number): any;
        dispose(): boolean;
    }
}
declare module VisiWin.UI {
    interface ISelectBoxItem extends VisiWin.UI.IItemBase {
    }
}
declare namespace VisiWin.UI {
    class SelectBoxItem extends VisiWin.UI.ItemBase implements ISelectBoxItem {
        private properties;
        private cssStyles;
        symbolType: string;
        bitmapFit: string;
        backgroundColor: string;
        hoverBackgroundColor: string;
        checkedBackgroundColor: string;
        checkedHoverBackgroundColor: string;
        disabledBackgroundColor: string;
        foregroundColor: string;
        disabledForegroundColor: string;
        checkedForegroundColor: string;
        primaryText: string;
        private _symbolControl;
        private _primaryTextControl;
        private _secondaryTextControl;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        _updateColors(changes: any): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
    }
}
/**
* @namespace
* @name VisiWin.UI
*/
declare namespace VisiWin.UI {
    /**
    * @class
    * @name VisiWin.UI.ISelectBox
    * @description UI Control that provides the ability to create SelectBoxItems from a datasource or inline items
    * @memberof VisiWin.UI
    */
    interface IPopoverMenu extends VisiWin.UI.IControlBase {
        /**
        * @description Represents the position (index) of the selected/checked SelectBoxItem
        * @member { number } selectedIndex
        * defaultValue: -1
        */
        selectedIndex: number;
        /**
        * @description Represents the value of the selected/checked SelectBoxItem
        * @member { string } selectedValue
        * defaultValue: ""
        */
        selectedValue: string;
        /**
        * @description Sets the dataSource, which is used to generate SelectBoxItem
        * @member { any } dataSource
        * defaultValue:
        */
        dataSource: any;
        /**
        * @description Sets the dataTemplate, which is used as a Template to generate SelectBoxItem
        * @member { any } dataTemplate
        * defaultValue:
        */
        dataTemplate: any;
    }
}
declare namespace VisiWin.UI {
    class PopoverMenu extends VisiWin.UI.ControlBase implements IPopoverMenu {
        private properties;
        private cssStyles;
        selectedIndex: number;
        selectionMode: VisiWin.UI.Enums.SelectionMode;
        selectedValue: string;
        selectedItem: any;
        menuItemStyle: string;
        dataSource: any;
        dataTemplate: any;
        private _itemsContainer;
        private _inlineItems;
        private _itemsLoaded;
        private _boundItemsLoaded;
        private _boundSelectedIndexChanged;
        private _dataListeners;
        private _itemsLoadedEventType;
        private _itemInsertedEventType;
        private _itemChangedEventType;
        private _itemMovedEventType;
        private _itemRemovedEventType;
        private _itemsReloadedEventType;
        private itemInsertedTriggerData;
        private itemChangedTriggerData;
        private itemMovedTriggerData;
        private itemRemovedTriggerData;
        private itemsReloadedTriggerData;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        createHandler(): void;
        removeHandler(): void;
        _addDataListeners(): void;
        _removeDataListeners(): void;
        _onSelectedIndexChanged(args: any): void;
        _onItemInserted(args: any): void;
        _onItemChanged(args: any): void;
        _onItemMoved(args: any): void;
        _onItemRemoved(args: any): void;
        _onItemsReloaded(args: any): void;
        getSelectedItemData(): any;
        _onItemsLoaded(): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        _setMenuItemStyle(): void;
        getMenuItemFromIndex(index: number): any;
        getMenuItemFromKey(key: string): any;
        getMenuItemCloneFromIndex(index: number): any;
    }
}
declare namespace VisiWin.UI {
    class Table extends VisiWin.UI.ControlBase implements ITable {
        private properties;
        private cssStyles;
        dataTemplate: string;
        private headerTemplate;
        stickyHeader: boolean;
        selectedIndex: number;
        selectionMode: VisiWin.UI.Enums.SelectionMode;
        selectedValue: string;
        headerHeight: string;
        backgroundColor: string;
        borderColor: string;
        private headerCellBackgroundColor;
        private headerCellForegroundColor;
        private headerCellBorderColor;
        private headerCellHoverBackgroundColor;
        private headerCellHoverForegroundColor;
        private headerCellPressedBackgroundColor;
        private headerCellPressedForegroundColor;
        private headerCellBorderWidth;
        private headerCellBorderStyle;
        private headerCellBorderRadius;
        private headerCellStyle;
        private _tableElement;
        private _tableHeaderRowControl;
        private _tableHeaderControl;
        private _headerRowElement;
        private _tableBodyControl;
        private _boundSortedModeChanged;
        private _boundSelectedIndexChangedHandler;
        private _headerCells;
        private triggerData;
        private selectedItem;
        private _dataSource;
        private dataSourceName;
        private _itemsLoadedEventType;
        private _itemInsertedEventType;
        private _itemChangedEventType;
        private _itemMovedEventType;
        private _itemRemovedEventType;
        private _itemsReloadedEventType;
        private itemInsertedTriggerData;
        private itemChangedTriggerData;
        private itemMovedTriggerData;
        private itemRemovedTriggerData;
        private itemsReloadedTriggerData;
        private _dataListeners;
        private _boundItemsLoaded;
        private _itemsLoaded;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        get dataSource(): any;
        set dataSource(data: any);
        createHandler(): void;
        removeHandler(): void;
        _onSelectedIndexChangedHandler(args: any): void;
        _onItemInserted(args: any): void;
        _onItemChanged(args: any): void;
        _onItemMoved(args: any): void;
        _onItemRemoved(args: any): void;
        _onItemsReloaded(args: any): void;
        _onItemsLoaded(): void;
        _addDataListeners(): void;
        _removeDataListeners(): void;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        private _calculateTableHeaderCells;
        private _onSortedModeChanged;
        private getLocalizableText;
        private sortAlphabeticalWithLocalizableTexts;
        private hasItemStartingWith;
        private firstElement;
        private removeSortValue;
        private sortDataTypes;
        private sortAlphabetical;
        private sortNumeric;
        private sortDate;
        private sortBoolean;
        private createHeaderCellHandler;
    }
}
declare namespace VisiWin.UI {
    interface ITable extends VisiWin.UI.IControlBase {
        /**
        * @name dataTemplate
        * @description Sets the name of the dataTemplate, which is used as a Template to generate TableRows
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } dataTemplate
        * @defaultValue: ""
        **/
        dataTemplate: string;
        /**
        * @name stickyHeader
        * @description Wether the header is sticky at the top
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } stickyHeader
        * @defaultValue: true
        */
        stickyHeader: boolean;
        /**
        * @name selectedIndex
        * @description Represents the position (index) of the selected/checked TableRow
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } selectedIndex
        * @defaultValue: -1
        */
        selectedIndex: number;
        /**
        * @name selectionMode
        * @description Defines the selection mode, which indicates whether a TableRow can be selected or not.
        * @enum VisiWin.UI.Enums.SelectionMode
        * defaultValue: VisiWin.UI.Enum.SelectionMode.None
        */
        selectionMode: VisiWin.UI.Enums.SelectionMode;
        /**
        * @name selectedValue
        * @description Represents the value of the selected/checked TableRow
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } selectedValue
        * defaultValue: ""
        */
        selectedValue: string;
        /**
        * @name headerHeight
        * @description Sets the height of the TableHeaderRow and TableHeaderCells
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } headerHeight
        * defaultValue: "50px"
        */
        headerHeight: string;
        /**
        * @name backgroundColor
        * @description Sets the color of the background
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } backgroundColor
        * defaultValue: "@BackgroundColor"
        */
        backgroundColor: string;
        /**
        * @name backgroundColor
        * @description Sets the color of the border
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } borderColor
        * defaultValue: "@BorderColor"
        */
        borderColor: string;
    }
}
declare namespace VisiWin.UI {
    class TableHeader extends VisiWin.UI.ControlBase implements ITableHeader {
        private properties;
        private cssStyles;
        backgroundColor: string;
        borderColor: string;
        headerCells: any;
        headerTemplate: string;
        dataSource: string;
        dataTemplate: string;
        dataTemplateRow: any;
        private templateLoaded;
        private hasInlineHeaderCells;
        constructor(element: VWElement, options: any);
        registerChild(controlType: string, action: string, element: VWElement, options: any): any;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        _boundDataTemplateReadyRow: any;
        dataTemplateReadyRow(dataTemp: any): Promise<void>;
        _boundDataTemplateReadyHeader: any;
        dataTemplateReadyHeader(dataTemp: any): Promise<void>;
        getKeyAsString(obj: {
            [key: string]: any;
        }, position: number): string | undefined;
    }
}
declare namespace VisiWin.UI {
    interface ITableHeader extends VisiWin.UI.IControlBase {
        /**@ignore */
        backgroundColor: string;
        /**@ignore */
        borderColor: string;
        /**@ignore */
        headerCells: any;
        /**@ignore */
        headerTemplate: string;
        /**@ignore */
        dataSource: string;
        /**@ignore */
        dataTemplate: string;
        /**@ignore */
        dataTemplateRow: any;
    }
}
declare namespace VisiWin.UI {
    class TableBody extends VisiWin.UI.RepeaterBase implements ITableBody {
        private properties;
        private cssStyles;
        private _headerCells;
        private _columnCollapseList;
        constructor(element: VWElement, options: any);
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
    }
}
declare namespace VisiWin.UI {
    interface ITableBody extends IRepeaterBase {
    }
}
declare module VisiWin.UI {
    class TableFooter extends VisiWin.UI.ToggleButtonBase implements ITableFooter {
        static namespace: string;
        static controlName: string;
        static classTableFooter: string;
        static TableFooterPropertyList: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            dataMode: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            repeaterTemplate: {
                propertyType: string;
                type: string;
            };
            bindingData: {
                propertyType: string;
                type: string;
            };
            dataSource: {
                propertyType: string;
                type: string;
            };
        };
        dataIndex: number;
        dataMode: string;
        repeaterTemplate: string;
        selectMode: string;
        bindingData: any;
        dataSource: any;
        private _trElement;
        private _trControl;
        private _bindingList;
        private _dataSource;
        private _repeaterControl;
        constructor(element: VWElement, options: any);
        createTemplate(element: VWElement, options: any): any;
        createHandler(): void;
        removeHandler(): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        dispose(): boolean;
    }
}
declare namespace VisiWin.UI {
    interface ITableFooter extends VisiWin.UI.IToggleButtonBase {
    }
}
declare namespace VisiWin.UI {
    class TableRow extends VisiWin.UI.ItemBase implements ITableRow {
        private properties;
        private cssStyles;
        backgroundColor: string;
        hoverBackgroundColor: string;
        pressedBackgroundColor: string;
        selectedBackgroundColor: string;
        selectedHoverBackgroundColor: string;
        selectedPressedBackgroundColor: string;
        borderColor: string;
        hoverBorderColor: string;
        selectedBorderColor: string;
        selectedHoverBorderColor: string;
        constructor(element: VWElement, options: any);
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
    }
}
declare namespace VisiWin.UI {
    interface ITableRow extends VisiWin.UI.IItemBase {
        /**
        * @name backgroundColor
        * @description Sets the color of the background
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } backgroundColor
        * defaultValue: "@BackgroundColor"
        */
        backgroundColor: string;
        /**
        * @name hoverBackgroundColor
        * @description Sets the color of the background when the control is hovered
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } hoverBackgroundColor
        * defaultValue: "@BackgroundColor"
        */
        hoverBackgroundColor: string;
        /**
        * @name pressedBackgroundColor
        * @description Sets the color of the background when the control is pressed
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } pressedBackgroundColor
        * defaultValue: "@PressedBackgroundColor"
        */
        pressedBackgroundColor: string;
        /**
        * @name selectedBackgroundColor
        * @description Sets the color of the background when the control is selected
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } selectedBackgroundColor
        * defaultValue: "@PressedBackgroundColor"
        */
        selectedBackgroundColor: string;
        /**
        * @name selectedHoverBackgroundColor
        * @description Sets the color of the background when the control is selected and hovered
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } selectedHoverBackgroundColor
        * defaultValue: "@CheckedBackgroundColor"
        */
        selectedHoverBackgroundColor: string;
        /**
        * @name selectedPressedBackgroundColor
        * @description Sets the color of the background when the control is selected and pressed
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } selectedPressedBackgroundColor
        * defaultValue: "@CheckedPressedBackgroundColor"
        */
        selectedPressedBackgroundColor: string;
        /**
        * @name borderColor
        * @description Sets the color of the border
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } borderColor
        * defaultValue: "@BorderColor"
        */
        borderColor: string;
        /**
        * @name hoverBorderColor
        * @description Sets the color of the border when the control is hovered
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } hoverBorderColor
        * defaultValue: "@HoverBorderColor"
        */
        hoverBorderColor: string;
        /**
        * @name selectedBorderColor
        * @description Sets the color of the border when the control is selected
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } selectedBorderColor
        * defaultValue: "@CheckedBorderColor"
        */
        selectedBorderColor: string;
        /**
        * @name selectedHoverBorderColor
        * @description Sets the color of the border when the control is selected and hovered
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } selectedHoverBorderColor
        * defaultValue: "@CheckedHoverBorderColor"
        */
        selectedHoverBorderColor: string;
    }
}
declare namespace VisiWin.UI {
    class TableCell extends VisiWin.UI.ControlBase implements ITableCell {
        private properties;
        private cssStyles;
        private _flexElement;
        backgroundColor: string;
        foregroundColor: string;
        borderColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        constructor(element: VWElement, options: any);
        private __alignItems;
        get alignItems(): string;
        set alignItems(value: string);
        private __justifyContent;
        get justifyContent(): string;
        set justifyContent(value: string);
        createTemplate(): Promise<any>;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
    }
}
declare namespace VisiWin.UI {
    interface ITableCell extends VisiWin.UI.IControlBase {
        /**
        * @name backgroundColor
        * @description Sets the color of the background
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } backgroundColor
        * defaultValue: "@BackgroundColor"
        */
        backgroundColor: string;
        /**
        * @name foregroundColor
        * @description Sets the color of the foreground
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } foregroundColor
        * defaultValue: "@None"
        */
        foregroundColor: string;
        /**
        * @name borderColor
        * @description Sets the color of the border
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } borderColor
        * defaultValue: "@BorderColor"
        */
        borderColor: string;
        /**
        * @name disabledBackgroundColor
        * @description Sets the color of the background when the control is disabled
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } disabledBackgroundColor
        * defaultValue: "@DisabledBackgroundColor"
        */
        disabledBackgroundColor: string;
        /**
        * @name disabledForegroundColor
        * @description Sets the color of the foreground when the control is disabled
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } disabledForegroundColor
        * defaultValue: "@DisabledForegroundColor"
        */
        disabledForegroundColor: string;
        /**
        * @name disabledBorderColor
        * @description Sets the color of the border when the control is disabled
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } disabledBorderColor
        * defaultValue: "@DisabledBorderColor"
        */
        disabledBorderColor: string;
    }
}
declare namespace VisiWin.UI {
    class TableHeaderCell extends VisiWin.UI.ButtonBase implements ITableHeaderCell {
        private properties;
        private cssStyles;
        backgroundColor: string;
        foregroundColor: string;
        borderColor: string;
        disabledBackgroundColor: string;
        disabledForegroundColor: string;
        disabledBorderColor: string;
        hoverForegroundColor: string;
        hoverBackgroundColor: string;
        private columnIndex;
        private _containerElement;
        private _containerElementLeft;
        private _containerElementRight;
        private _tableElement;
        private _symbolControl;
        private _textControl;
        private _sortedMode;
        private sorted;
        private _boundbuttonclick;
        private isInlineHeaderCell;
        private containerBorderWidth;
        private containerBorderStyle;
        private containerBorderRadius;
        private containerTransition;
        showSymbol: boolean;
        sortUpSymbol: string;
        sortDownSymbol: string;
        symbol: string;
        iconFont: string;
        symbolType: string;
        symbolSize: string;
        symbolMargin: string;
        symbolPosition: string;
        showText: boolean;
        textWidth: string;
        textHeight: string;
        textMargin: string;
        textPadding: string;
        textAlignment: string;
        lineClamp: number;
        textWrapping: string;
        textTrimming: string;
        lineHeight: string;
        textContrast: number;
        uppercase: boolean;
        textPosition: string;
        canUserSort: boolean;
        private _symbolControlSort;
        sortType: VisiWin.UI.Enums.SortType;
        sortMode: VisiWin.UI.Enums.SortMode;
        dataSourceItemMember: string;
        private _dragContainer;
        private _boundPointerDownHandlerResize;
        private _boundPointerMoveHandlerResize;
        private _boundPointerUpHandlerResize;
        private _boundPointerLeaveHandlerResize;
        private _boundPointerCancelHandlerResize;
        private isResizing;
        private lastX;
        canUserResize: boolean;
        resizeContainerWidth: string;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        createHandler(): void;
        removeHandler(): void;
        _pointerDownHandlerResize(e: any): void;
        _pointerUpHandlerResize(e: any): void;
        _pointerMoveHandlerResize(e: any): void;
        private calculateMinWidth;
        _pointerLeaveHandlerResize(e: any): void;
        _pointerCancelHandlerResize(inEvent: PointerEvent): void;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        _updateLayout(changes: VisiWin.UI.IUpdateLayout): void;
        _onSortedModeChanged(args: any): void;
    }
}
declare namespace VisiWin.UI {
    interface ITableHeaderCell extends VisiWin.UI.IButtonBase {
        /**
        * @name backgroundColor
        * @description Sets the color of the background
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } backgroundColor
        * defaultValue: "@BackgroundColor"
        */
        backgroundColor: string;
        /**
        * @name foregroundColor
        * @description Sets the color of the foreround
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } foregroundColor
        * defaultValue: "@ForegroundColor"
        */
        foregroundColor: string;
        /**
        * @name borderColor
        * @description Sets the color of the border
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } borderColor
        * defaultValue: "@BorderColor"
        */
        borderColor: string;
        /**
        * @name disabledBackgroundColor
        * @description Sets the color of the background when the control is disabled
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } disabledBackgroundColor
        * defaultValue: "@DisabledBackgroundColor"
        */
        disabledBackgroundColor: string;
        /**
        * @name disabledForegroundColor
        * @description Sets the color of the foreground when the control is disabled
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } disabledForegroundColor
        * defaultValue: "@DisabledForegroundColor"
        */
        disabledForegroundColor: string;
        /**
        * @name disabledBorderColor
        * @description Sets the color of the border when the control is disabled
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } disabledBorderColor
        * defaultValue: "@DisabledBorderColor"
        */
        disabledBorderColor: string;
        /**
        * @name hoverBackgroundColor
        * @description Sets the color of the background when the control is hovered
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } hoverBackgroundColor
        * defaultValue: "@BackgroundColor"
        */
        hoverBackgroundColor: string;
        /**
        * @name hoverForegroundColor
        * @description Sets the color of the foreground when the control is hovered
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } hoverForegroundColor
        * defaultValue: "@ForegroundColor"
        */
        hoverForegroundColor: string;
        /**
        * @name showSymbol
        * @description Wether the symbol is shown
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } showSymbol
        * @defaultValue: false
        */
        showSymbol: boolean;
        /**
        * @name sortUpSymbol
        * @description Sets the symbol which is shown, when the table is sorted ascending
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } sortUpSymbol
        * @defaultValue: "arrow_upward"
        **/
        sortUpSymbol: string;
        /**
        * @name sortDownSymbol
        * @description Sets the symbol which is shown, when the table is sorted descending
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } sortDownSymbol
        * @defaultValue: "arrow_downward"
        **/
        sortDownSymbol: string;
        /**
        * @name symbol
        * @description Sets the symbol, which is shown as a leading symbol
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } symbol
        * @defaultValue: ""
        **/
        symbol: string;
        /**
        * @name iconFont
        * @description Sets the fontclass from which the icon is selected
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } iconFont
        * @defaultValue: "material-icons"
        **/
        iconFont: string;
        /**
        * @name symbolType
        * @description Sets the type of the symbol
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } symbolType
        * @defaultValue: "Icon"
        **/
        symbolType: string;
        /**
        * @name symbolSize
        * @description Sets the size of the symbol
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } symbolSize
        * @defaultValue: "24px"
        **/
        symbolSize: string;
        /**
        * @name symbolMargin
        * @description Sets the margin of the symbol
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } symbolMargin
        * @defaultValue: "0px 0px 0px 0px"
        **/
        symbolMargin: string;
        /**
        * @name symbolPosition
        * @description Sets the position of the symbol
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } symbolPosition
        * @defaultValue: "Left"
        **/
        symbolPosition: string;
        /**
        * @name showText
        * @description Wether the text is shown
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } showText
        * @defaultValue: true
        */
        showText: boolean;
        /**
        * @name textWidth
        * @description Sets the width of the text
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } textWidth
        * @defaultValue: "auto"
        **/
        textWidth: string;
        /**
        * @name textHeight
        * @description Sets the height of the text
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } textHeight
        * @defaultValue: "20px"
        **/
        textHeight: string;
        /**
        * @name textMargin
        * @description Sets the margin of the text
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } textMargin
        * @defaultValue: "0px 0px 0px 0px"
        **/
        textMargin: string;
        /**
        * @name textPadding
        * @description Sets the padding of the text
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } textPadding
        * @defaultValue: "0px 0px 0px 0px"
        **/
        textPadding: string;
        /**
        * @name textAlignment
        * @description Sets the alignment of the text
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } textAlignment
        * @defaultValue: "Left"
        **/
        textAlignment: string;
        /**
        * @name lineClamp
        * @description Indicates the maximum number of lines the specified text can occupy
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } lineClamp
        * @defaultValue: "Left"
        **/
        lineClamp: number;
        /**@ignore **/
        textWrapping: string;
        /**@ignore **/
        textTrimming: string;
        /**
        * @name lineHeight
        * @description Sets the lineheight of the text
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } lineHeight
        * @defaultValue: ""
        **/
        lineHeight: string;
        /**@ignore **/
        textContrast: number;
        /**@ignore **/
        uppercase: boolean;
        /**@ignore **/
        textPosition: string;
        /**
        * @name canUserSort
        * @description Wether the user can sort the table by the clicked column
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } canUserSort
        * @defaultValue: false
        */
        canUserSort: boolean;
        /**
        * @name sortType
        * @description Defines the sort type, by which the entries of the datasource should be sorted
        * @enum VisiWin.UI.Enums.sortType
        * defaultValue: VisiWin.UI.Enum.SortType.Auto
        */
        sortType: VisiWin.UI.Enums.SortType;
        /**
        * @name sortMode
        * @description Sets the sort mode, which defines if the table should handle the sorting or an event will be dispatched
        * @enum VisiWin.UI.Enums.SortMode
        * defaultValue: VisiWin.UI.Enum.SortMode.Internal
        */
        sortMode: VisiWin.UI.Enums.SortMode;
        /**
        * @name dataSourceItemMember
        * @description Sets the item member of the datasource, which will be used for sorting
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } dataSourceItemMember
        * @defaultValue: ""
        **/
        dataSourceItemMember: string;
        /**
        * @name canUserResize
        * @description Wether the user can resize the table header cell
        * @member { {@link VisiWin.UI.JSPrimitives.Boolean|boolean } } canUserResize
        * @defaultValue: false
        */
        canUserResize: boolean;
        /**
        * @name resizeContainerWidth
        * @description Sets the size of the resizeContainer, which allows the user to click and drag to resize the table header cell
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } resizeContainerWidth
        * @defaultValue: "40px"
        **/
        resizeContainerWidth: string;
    }
}
declare module VisiWin.UI {
    class TableHeaderRow extends VisiWin.UI.ControlBase implements ITableHeaderRow {
        private properties;
        private cssStyles;
        backgroundColor: string;
        borderColor: string;
        constructor(element: VWElement, options: any);
    }
}
declare namespace VisiWin.UI {
    interface ITableHeaderRow extends VisiWin.UI.IControlBase {
        /**@ignore **/
        backgroundColor: string;
        /**@ignore **/
        borderColor: string;
    }
}
declare namespace VisiWin.UI {
    interface ISortedModeChangedEventDetail {
        /**
        * @name sortDirection
        * @description Sets the sort direction, which defines if the table should be sorted ascending or descending
        * @enum VisiWin.UI.Enums.SortDirection
        * defaultValue:
        */
        sortDirection: VisiWin.UI.Enums.SortDirection;
        /**
        * @name columnIndex
        * @description Represents the index of the clicked column
        * @member { {@link VisiWin.UI.JSPrimitives.Number|number } } columnIndex
        * @defaultValue: ""
        **/
        columnIndex: number;
        /**
        * @name sortMode
        * @description Sets the sort mode, which defines if the table should handle the sorting or an event will be dispatched
        * @enum VisiWin.UI.Enums.SortMode
        * defaultValue: VisiWin.UI.Enum.SortMode.Internal
        */
        sortMode: VisiWin.UI.Enums.SortMode;
        /**
        * @name dataSourceItemMember
        * @description Sets the item member of the datasource, which will be used for sorting
        * @member { {@link VisiWin.UI.JSPrimitives.String|string } } dataSourceItemMember
        * @defaultValue: ""
        **/
        dataSourceItemMember: string;
    }
}
declare namespace VisiWin.UI {
    class LoadingSpinner extends VisiWin.UI.ControlBase {
        properties: {
            designerType: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            width: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            height: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            orientation: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            alignItems: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            justifyContent: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            background: {
                propertyType: string;
                type: string;
            };
            borderWidth: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            borderStyle: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            borderRadius: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            opacity: {
                propertyType: string;
                type: string;
                defaultValue: number;
            };
            visibility: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            shadow: {
                propertyType: string;
                type: string;
            };
            spinnerWidth: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            spinnerHeight: {
                propertyType: string;
                type: string;
                defaultValue: string;
            };
            backgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            spinnerBackgroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            spinnerForegroundColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            borderColor: {
                propertyType: string;
                type: string;
                resourceValue: string[];
                defaultValue: string;
            };
            loadingSpinner: {
                type: string;
                defaultValue: string;
            };
            playAnimation: {
                propertyType: string;
                type: string;
                defaultValue: boolean;
            };
        };
        orientation: string;
        alignItems: string;
        justifyContent: string;
        spinnerWidth: string;
        spinnerHeight: string;
        backgroundColor: string;
        borderColor: string;
        spinnerBackgroundColor: string;
        spinnerForegroundColor: string;
        loadingSpinner: string;
        playAnimation: boolean;
        private mainContainerElement;
        private spinnerElement;
        constructor(element: VWElement, options: any);
        createTemplate(): Promise<any>;
        _updateLayout(change: VisiWin.UI.IUpdateLayout): void;
        _updateColors(changes: VisiWin.UI.IUpdateColors): void;
        private _setsSpinnerElementWidthHeight;
    }
}
interface Window {
    clearImmediate(handle: number): void;
    setImmediate(handler: (...args: any[]) => void): number;
    setImmediate(handler: any, ...args: any[]): number;
}

declare module 'simple-keyboard/components/CandidateBox' {
    
    import Utilities from "simple-keyboard/services/Utilities";
    import { CandidateBoxParams, CandidateBoxRenderParams, CandidateBoxShowParams } from "simple-keyboard/interfaces";
    export class CandidateBox {
        utilities: Utilities;
        candidateBoxElement: HTMLDivElement;
        pageIndex: number;
        pageSize: number;
        constructor({ utilities }: CandidateBoxParams);
        destroy(): void;
        show({ candidateValue, targetElement, onSelect, }: CandidateBoxShowParams): void;
        renderPage({ candidateListPages, targetElement, pageIndex, nbPages, onItemSelected, }: CandidateBoxRenderParams): void;
    }
    export default CandidateBox;

}
declare module 'simple-keyboard/components/Keyboard' {
   
    import PhysicalKeyboard from "simple-keyboard/services/PhysicalKeyboard";
    import { KeyboardOptions, KeyboardInput, KeyboardButtonElements, KeyboardHandlerEvent, KeyboardElement } from "simple-keyboard/interfaces";
    import CandidateBox from "simple-keyboard/components/CandidateBox";
    /**
     * Root class for simple-keyboard.
     * This class:
     * - Parses the options
     * - Renders the rows and buttons
     * - Handles button functionality
     */
    export class SimpleKeyboard {
        input: KeyboardInput;
        options: KeyboardOptions;
        utilities: any;
        caretPosition: number | null;
        caretPositionEnd: number | null;
        keyboardDOM: KeyboardElement;
        keyboardPluginClasses: string;
        keyboardDOMClass: string;
        buttonElements: KeyboardButtonElements;
        currentInstanceName: string;
        allKeyboardInstances: {
            [key: string]: SimpleKeyboard;
        };
        keyboardInstanceNames: string[];
        isFirstKeyboardInstance: boolean;
        physicalKeyboard: PhysicalKeyboard;
        modules: {
            [key: string]: any;
        };
        activeButtonClass: string;
        holdInteractionTimeout: number;
        holdTimeout: number;
        isMouseHold: boolean;
        initialized: boolean;
        candidateBox: CandidateBox | null;
        keyboardRowsDOM: KeyboardElement;
        defaultName: string;
        activeInputElement: HTMLInputElement | HTMLTextAreaElement | null;
        /**
         * Creates an instance of SimpleKeyboard
         * @param {Array} params If first parameter is a string, it is considered the container class. The second parameter is then considered the options object. If first parameter is an object, it is considered the options object.
         */
        constructor(selectorOrOptions?: string | HTMLDivElement | KeyboardOptions, keyboardOptions?: KeyboardOptions);
        /**
         * parseParams
         */
        handleParams: (selectorOrOptions?: string | HTMLDivElement | KeyboardOptions | undefined, keyboardOptions?: KeyboardOptions | undefined) => {
            keyboardDOMClass: string;
            keyboardDOM: KeyboardElement;
            options: Partial<KeyboardOptions | undefined>;
        };
        /**
         * Getters
         */
        getOptions: () => KeyboardOptions;
        getCaretPosition: () => number | null;
        getCaretPositionEnd: () => number | null;
        /**
         * Changes the internal caret position
         * @param {number} position The caret's start position
         * @param {number} positionEnd The caret's end position
         */
        setCaretPosition(position: number | null, endPosition?: number | null): void;
        /**
         * Retrieve the candidates for a given input
         * @param input The input string to check
         */
        getInputCandidates(input: string): {
            candidateKey: string;
            candidateValue: string;
        } | Record<string, never>;
        /**
         * Shows a suggestion box with a list of candidate words
         * @param candidates The chosen candidates string as defined in the layoutCandidates option
         * @param targetElement The element next to which the candidates box will be shown
         */
        showCandidatesBox(candidateKey: string, candidateValue: string, targetElement: KeyboardElement): void;
        /**
         * Handles clicks made to keyboard buttons
         * @param  {string} button The button's layout name.
         */
        handleButtonClicked(button: string, e?: KeyboardHandlerEvent): void;
        /**
         * Get mouse hold state
         */
        getMouseHold(): boolean;
        /**
         * Mark mouse hold state as set
         */
        setMouseHold(value: boolean): void;
        /**
         * Handles button mousedown
         */
        handleButtonMouseDown(button: string, e: KeyboardHandlerEvent): void;
        /**
         * Handles button mouseup
         */
        handleButtonMouseUp(button?: string, e?: KeyboardHandlerEvent): void;
        /**
         * Handles container mousedown
         */
        handleKeyboardContainerMouseDown(e: KeyboardHandlerEvent): void;
        /**
         * Handles button hold
         */
        handleButtonHold(button: string): void;
        /**
         * Send a command to all simple-keyboard instances (if you have several instances).
         */
        syncInstanceInputs(): void;
        /**
         * Clear the keyboard’s input.
         * @param {string} [inputName] optional - the internal input to select
         */
        clearInput(inputName?: string): void;
        /**
         * Get the keyboard’s input (You can also get it from the onChange prop).
         * @param  {string} [inputName] optional - the internal input to select
         */
        getInput(inputName?: string, skipSync?: boolean): string;
        /**
         * Get all simple-keyboard inputs
         */
        getAllInputs(): KeyboardInput;
        /**
         * Set the keyboard’s input.
         * @param  {string} input the input value
         * @param  {string} inputName optional - the internal input to select
         */
        setInput(input: string, inputName?: string, skipSync?: boolean): void;
        /**
         * Replace the input object (`keyboard.input`)
         * @param  {object} inputObj The input object
         */
        replaceInput(inputObj: KeyboardInput): void;
        /**
         * Set new option or modify existing ones after initialization.
         * @param  {object} options The options to set
         */
        setOptions(options?: {}): void;
        /**
         * Detecting changes to non-function options
         * This allows us to ascertain whether a button re-render is needed
         */
        changedOptions(newOptions: Partial<KeyboardOptions>): string[];
        /**
         * Executing actions depending on changed options
         * @param  {object} options The options to set
         */
        onSetOptions(changedOptions?: string[]): void;
        /**
         * Remove all keyboard rows and reset keyboard values.
         * Used internally between re-renders.
         */
        resetRows(): void;
        /**
         * Send a command to all simple-keyboard instances at once (if you have multiple instances).
         * @param  {function(instance: object, key: string)} callback Function to run on every instance
         */
        dispatch(callback: (instance: SimpleKeyboard, key?: string) => void): void;
        /**
         * Adds/Modifies an entry to the `buttonTheme`. Basically a way to add a class to a button.
         * @param  {string} buttons List of buttons to select (separated by a space).
         * @param  {string} className Classes to give to the selected buttons (separated by space).
         */
        addButtonTheme(buttons: string, className: string): void;
        /**
         * Removes/Amends an entry to the `buttonTheme`. Basically a way to remove a class previously added to a button through buttonTheme or addButtonTheme.
         * @param  {string} buttons List of buttons to select (separated by a space).
         * @param  {string} className Classes to give to the selected buttons (separated by space).
         */
        removeButtonTheme(buttons: string, className: string): void;
        /**
         * Get the DOM Element of a button. If there are several buttons with the same name, an array of the DOM Elements is returned.
         * @param  {string} button The button layout name to select
         */
        getButtonElement(button: string): KeyboardElement | KeyboardElement[] | undefined;
        /**
         * This handles the "inputPattern" option
         * by checking if the provided inputPattern passes
         */
        inputPatternIsValid(inputVal: string): boolean;
        /**
         * Handles simple-keyboard event listeners
         */
        setEventListeners(): void;
        /**
         * Event Handler: KeyUp
         */
        handleKeyUp(event: KeyboardHandlerEvent): void;
        /**
         * Event Handler: KeyDown
         */
        handleKeyDown(event: KeyboardHandlerEvent): void;
        /**
         * Event Handler: MouseUp
         */
        handleMouseUp(event: KeyboardHandlerEvent): void;
        /**
         * Event Handler: TouchEnd
         */
        handleTouchEnd(event: KeyboardHandlerEvent): void;
        /**
         * Event Handler: Select
         */
        handleSelect(event: KeyboardHandlerEvent): void;
        /**
         * Event Handler: SelectionChange
         */
        handleSelectionChange(event: KeyboardHandlerEvent): void;
        /**
         * Called by {@link setEventListeners} when an event that warrants a cursor position update is triggered
         */
        caretEventHandler(event: KeyboardHandlerEvent): void;
        /**
         * Execute an operation on each button
         */
        recurseButtons(fn: any): void;
        /**
         * Destroy keyboard listeners and DOM elements
         */
        destroy(): void;
        /**
         * Process buttonTheme option
         */
        getButtonThemeClasses(button: string): string[];
        /**
         * Process buttonAttributes option
         */
        setDOMButtonAttributes(button: string, callback: any): void;
        onTouchDeviceDetected(): void;
        /**
         * Disabling contextual window for hg-button
         */
        disableContextualWindow(): void;
        /**
         * Process autoTouchEvents option
         */
        processAutoTouchEvents(): void;
        /**
         * Executes the callback function once simple-keyboard is rendered for the first time (on initialization).
         */
        onInit(): void;
        /**
         * Executes the callback function before a simple-keyboard render.
         */
        beforeFirstRender(): void;
        /**
         * Executes the callback function before a simple-keyboard render.
         */
        beforeRender(): void;
        /**
         * Executes the callback function every time simple-keyboard is rendered (e.g: when you change layouts).
         */
        onRender(): void;
        /**
         * Executes the callback function once all modules have been loaded
         */
        onModulesLoaded(): void;
        /**
         * Register module
         */
        registerModule: (name: string, initCallback: any) => void;
        /**
         * Load modules
         */
        loadModules(): void;
        /**
         * Get module prop
         */
        getModuleProp(name: string, prop: string): any;
        /**
         * getModulesList
         */
        getModulesList(): string[];
        /**
         * Parse Row DOM containers
         */
        parseRowDOMContainers(rowDOM: HTMLDivElement, rowIndex: number, containerStartIndexes: number[], containerEndIndexes: number[]): HTMLDivElement;
        /**
         * getKeyboardClassString
         */
        getKeyboardClassString: (...baseDOMClasses: any[]) => string;
        /**
         * Renders rows and buttons as per options
         */
        render(): void;
    }
    export default SimpleKeyboard;

}
declare module 'simple-keyboard/index' {
    
    import SimpleKeyboard from "simple-keyboard/components/Keyboard";
    export default SimpleKeyboard;

}
declare module 'simple-keyboard/index.modern' {
    import SimpleKeyboard from "simple-keyboard/components/Keyboard";
    export default SimpleKeyboard;

}
declare module 'simple-keyboard/interfaces' {
    import SimpleKeyboard from "simple-keyboard/components/Keyboard";
    import Utilities from "simple-keyboard/services/Utilities";
    export interface KeyboardLayoutObject {
        [key: string]: string[];
    }
    export type KeyboardButtonTheme = {
        class: string;
        buttons: string;
    } | null;
    export interface KeyboardButtonAttributes {
        attribute: string;
        value: string;
        buttons: string;
    }
    export interface KeyboardInput {
        [key: string]: string;
    }
    export type CandidateBoxParams = {
        utilities: Utilities;
    };
    export type CandidateBoxShowParams = {
        candidateValue: string;
        targetElement: KeyboardElement;
        onSelect: (selectedCandidate: string, e: MouseEvent) => void;
    };
    export type CandidateBoxRenderParams = {
        candidateListPages: string[][];
        targetElement: KeyboardElement;
        pageIndex: number;
        nbPages: number;
        onItemSelected: (selectedCandidate: string, e: MouseEvent) => void;
    };
    export type KeyboardElement = HTMLDivElement | HTMLButtonElement;
    export type KeyboardHandlerEvent = any;
    export interface KeyboardButtonElements {
        [key: string]: KeyboardElement[];
    }
    export interface UtilitiesParams {
        getOptions: () => KeyboardOptions;
        getCaretPosition: () => number | null;
        getCaretPositionEnd: () => number | null;
        dispatch: any;
    }
    export interface PhysicalKeyboardParams {
        getOptions: () => KeyboardOptions;
        dispatch: any;
    }
    export interface KeyboardOptions {
        /**
         * Modify the keyboard layout.
         */
        layout?: KeyboardLayoutObject;
        /**
         * Specifies which layout should be used.
         */
        layoutName?: string;
        /**
         * Replaces variable buttons (such as `{bksp}`) with a human-friendly name (e.g.: `backspace`).
         */
        display?: {
            [button: string]: string;
        };
        /**
         * By default, when you set the display property, you replace the default one. This setting merges them instead.
         */
        mergeDisplay?: boolean;
        /**
         * A prop to add your own css classes to the keyboard wrapper. You can add multiple classes separated by a space.
         */
        theme?: string;
        /**
         * A prop to add your own css classes to one or several buttons.
         */
        buttonTheme?: KeyboardButtonTheme[];
        /**
         * A prop to add your own attributes to one or several buttons.
         */
        buttonAttributes?: KeyboardButtonAttributes[];
        /**
         * Runs a `console.log` every time a key is pressed. Displays the buttons pressed and the current input.
         */
        debug?: boolean;
        /**
         * Specifies whether clicking the "ENTER" button will input a newline (`\n`) or not.
         */
        newLineOnEnter?: boolean;
        /**
         * Specifies whether clicking the "TAB" button will input a tab character (`\t`) or not.
         */
        tabCharOnTab?: boolean;
        /**
         * Allows you to use a single simple-keyboard instance for several inputs.
         */
        inputName?: string;
        /**
         * `number`: Restrains all of simple-keyboard inputs to a certain length. This should be used in addition to the input element’s maxlengthattribute.
         *
         * `{ [inputName: string]: number }`: Restrains simple-keyboard’s individual inputs to a certain length. This should be used in addition to the input element’s maxlengthattribute.
         */
        maxLength?: any;
        /**
         * When set to true, this option synchronizes the internal input of every simple-keyboard instance.
         */
        syncInstanceInputs?: boolean;
        /**
         * Enable highlighting of keys pressed on physical keyboard.
         */
        physicalKeyboardHighlight?: boolean;
        /**
         * Calls handler for a button highlighted by physicalKeyboardHighlight
         * In other words, this calls keyboard.handleButtonClicked(buttonName) on the highlighted button
         */
        physicalKeyboardHighlightPress?: boolean;
        /**
         * Trigger click on a button's element when using physicalKeyboardHighlightPress
         * In other words, this calls button.click() on the highlighted button
         */
        physicalKeyboardHighlightPressUseClick?: boolean;
        /**
         * Whether physicalKeyboardHighlightPress should use pointer events to trigger buttons.
         */
        physicalKeyboardHighlightPressUsePointerEvents?: boolean;
        /**
         * Define the text color that the physical keyboard highlighted key should have.
         */
        physicalKeyboardHighlightTextColor?: string;
        /**
         * Define the background color that the physical keyboard highlighted key should have.
         */
        physicalKeyboardHighlightBgColor?: string;
        /**
         * Calling preventDefault for the mousedown events keeps the focus on the input.
         */
        preventMouseDownDefault?: boolean;
        /**
         * Calling preventDefault for the mouseup events.
         */
        preventMouseUpDefault?: boolean;
        /**
         * Stops pointer down events on simple-keyboard buttons from bubbling to parent elements.
         */
        stopMouseDownPropagation?: boolean;
        /**
         * Stops pointer up events on simple-keyboard buttons from bubbling to parent elements.
         */
        stopMouseUpPropagation?: boolean;
        /**
         * Render buttons as a button element instead of a div element.
         */
        useButtonTag?: boolean;
        /**
         * A prop to ensure characters are always be added/removed at the end of the string.
         */
        disableCaretPositioning?: boolean;
        /**
         * Restrains input(s) change to the defined regular expression pattern.
         */
        inputPattern?: any;
        /**
         * Instructs simple-keyboard to use touch events instead of click events.
         */
        useTouchEvents?: boolean;
        /**
         * Enable useTouchEvents automatically when touch device is detected.
         */
        autoUseTouchEvents?: boolean;
        /**
         * Opt out of PointerEvents handling, falling back to the prior mouse event logic.
         */
        useMouseEvents?: boolean;
        /**
         * Disable button hold action.
         */
        disableButtonHold?: boolean;
        /**
         * Adds unicode right-to-left control characters to input return values.
         */
        rtl?: boolean;
        /**
         * Enable input method editor candidate list support.
         */
        enableLayoutCandidates?: boolean;
        /**
         * Character suggestions to be shown on certain key presses
         */
        layoutCandidates?: {
            [key: string]: string;
        };
        /**
         * Exclude buttons from layout
         */
        excludeFromLayout?: {
            [key: string]: string[];
        };
        /**
         * Determines size of layout candidate list
         */
        layoutCandidatesPageSize?: number;
        /**
         * Determines whether layout candidate match should be case sensitive.
         */
        layoutCandidatesCaseSensitiveMatch?: boolean;
        /**
         * Executes the callback function every time simple-keyboard is rendered (e.g: when you change layouts).
         */
        onRender?: (instance?: SimpleKeyboard) => void;
        /**
         * Executes the callback function once simple-keyboard is rendered for the first time (on initialization).
         */
        onInit?: (instance?: SimpleKeyboard) => void;
        /**
         * Retrieves the current input
         */
        onChange?: (input: string, e?: MouseEvent) => any;
        /**
         * Retrieves all inputs
         */
        onChangeAll?: (inputObj: KeyboardInput, e?: MouseEvent) => any;
        /**
         * Module options can have any format
         */
        [name: string]: any;
    }

}
declare module 'simple-keyboard/polyfills' {

}
declare module 'simple-keyboard/services/KeyboardLayout' {
    export const getDefaultLayout: () => {
        default: string[];
        shift: string[];
    };

}
declare module 'simple-keyboard/services/PhysicalKeyboard' {
    import { KeyboardOptions, PhysicalKeyboardParams } from "simple-keyboard/interfaces";
    /**
     * Physical Keyboard Service
     */
    class PhysicalKeyboard {
        getOptions: () => KeyboardOptions;
        dispatch: any;
        /**
         * Creates an instance of the PhysicalKeyboard service
         */
        constructor({ dispatch, getOptions }: PhysicalKeyboardParams);
        handleHighlightKeyDown(event: KeyboardEvent): void;
        handleHighlightKeyUp(event: KeyboardEvent): void;
        /**
         * Transforms a KeyboardEvent's "key.code" string into a simple-keyboard layout format
         * @param  {object} event The KeyboardEvent
         */
        getSimpleKeyboardLayoutKey(event: KeyboardEvent): string;
        /**
         * Retrieve key from keyCode
         */
        keyCodeToKey(keyCode: number): string | undefined;
    }
    export default PhysicalKeyboard;

}
declare module 'simple-keyboard/services/Utilities' {
    import { KeyboardInput } from "simple-keyboard/interfaces";
    import { KeyboardOptions, UtilitiesParams } from "simple-keyboard/interfaces";
    /**
     * Utility Service
     */
    class Utilities {
        getOptions: () => KeyboardOptions;
        getCaretPosition: () => number | null;
        getCaretPositionEnd: () => number | null;
        dispatch: any;
        maxLengthReached: boolean;
        /**
         * Creates an instance of the Utility service
         */
        constructor({ getOptions, getCaretPosition, getCaretPositionEnd, dispatch, }: UtilitiesParams);
        /**
         * Retrieve button type
         *
         * @param  {string} button The button's layout name
         * @return {string} The button type
         */
        getButtonType(button: string): string;
        /**
         * Adds default classes to a given button
         *
         * @param  {string} button The button's layout name
         * @return {string} The classes to be added to the button
         */
        getButtonClass(button: string): string;
        /**
         * Default button display labels
         */
        getDefaultDiplay(): {
            "{bksp}": string;
            "{backspace}": string;
            "{enter}": string;
            "{shift}": string;
            "{shiftleft}": string;
            "{shiftright}": string;
            "{alt}": string;
            "{s}": string;
            "{tab}": string;
            "{lock}": string;
            "{capslock}": string;
            "{accept}": string;
            "{space}": string;
            "{//}": string;
            "{esc}": string;
            "{escape}": string;
            "{f1}": string;
            "{f2}": string;
            "{f3}": string;
            "{f4}": string;
            "{f5}": string;
            "{f6}": string;
            "{f7}": string;
            "{f8}": string;
            "{f9}": string;
            "{f10}": string;
            "{f11}": string;
            "{f12}": string;
            "{numpaddivide}": string;
            "{numlock}": string;
            "{arrowup}": string;
            "{arrowleft}": string;
            "{arrowdown}": string;
            "{arrowright}": string;
            "{prtscr}": string;
            "{scrolllock}": string;
            "{pause}": string;
            "{insert}": string;
            "{home}": string;
            "{pageup}": string;
            "{delete}": string;
            "{forwarddelete}": string;
            "{end}": string;
            "{pagedown}": string;
            "{numpadmultiply}": string;
            "{numpadsubtract}": string;
            "{numpadadd}": string;
            "{numpadenter}": string;
            "{period}": string;
            "{numpaddecimal}": string;
            "{numpad0}": string;
            "{numpad1}": string;
            "{numpad2}": string;
            "{numpad3}": string;
            "{numpad4}": string;
            "{numpad5}": string;
            "{numpad6}": string;
            "{numpad7}": string;
            "{numpad8}": string;
            "{numpad9}": string;
        };
        /**
         * Returns the display (label) name for a given button
         *
         * @param  {string} button The button's layout name
         * @param  {object} display The provided display option
         * @param  {boolean} mergeDisplay Whether the provided param value should be merged with the default one.
         */
        getButtonDisplayName(button: string, display: KeyboardOptions["display"], mergeDisplay: boolean): string;
        /**
         * Returns the updated input resulting from clicking a given button
         *
         * @param  {string} button The button's layout name
         * @param  {string} input The input string
         * @param  {number} caretPos The cursor's current position
         * @param  {number} caretPosEnd The cursor's current end position
         * @param  {boolean} moveCaret Whether to update simple-keyboard's cursor
         */
        getUpdatedInput(button: string, input: string, caretPos: number, caretPosEnd?: number, moveCaret?: boolean): string;
        /**
         * Moves the cursor position by a given amount
         *
         * @param  {number} length Represents by how many characters the input should be moved
         * @param  {boolean} minus Whether the cursor should be moved to the left or not.
         */
        updateCaretPos(length: number, minus?: boolean): void;
        /**
         * Action method of updateCaretPos
         *
         * @param  {number} length Represents by how many characters the input should be moved
         * @param  {boolean} minus Whether the cursor should be moved to the left or not.
         */
        updateCaretPosAction(length: number, minus?: boolean): number | null;
        /**
         * Adds a string to the input at a given position
         *
         * @param  {string} source The source input
         * @param  {string} str The string to add
         * @param  {number} position The (cursor) position where the string should be added
         * @param  {boolean} moveCaret Whether to update simple-keyboard's cursor
         */
        addStringAt(source: string, str: string, position?: number, positionEnd?: number, moveCaret?: boolean): string;
        /**
         * Check whether the button is a standard button
         */
        isStandardButton: (button: string) => boolean | "";
        /**
         * Removes an amount of characters before a given position
         *
         * @param  {string} source The source input
         * @param  {number} position The (cursor) position from where the characters should be removed
         * @param  {boolean} moveCaret Whether to update simple-keyboard's cursor
         */
        removeAt(source: string, position?: number, positionEnd?: number, moveCaret?: boolean): string;
        /**
         * Removes an amount of characters after a given position
         *
         * @param  {string} source The source input
         * @param  {number} position The (cursor) position from where the characters should be removed
         */
        removeForwardsAt(source: string, position?: number, positionEnd?: number, moveCaret?: boolean): string;
        /**
         * Determines whether the maxLength has been reached. This function is called when the maxLength option it set.
         *
         * @param  {object} inputObj
         * @param  {string} updatedInput
         */
        handleMaxLength(inputObj: KeyboardInput, updatedInput: string): boolean | undefined;
        /**
         * Gets the current value of maxLengthReached
         */
        isMaxLengthReached(): boolean;
        /**
         * Determines whether a touch device is being used
         */
        isTouchDevice(): number | true;
        /**
         * Determines whether pointer events are supported
         */
        pointerEventsSupported(): boolean;
        /**
         * Bind all methods in a given class
         */
        static bindMethods(myClass: any, instance: any): void;
        /**
         * Transforms an arbitrary string to camelCase
         *
         * @param  {string} str The string to transform.
         */
        camelCase(str: string): string;
        /**
         * Split array into chunks
         */
        chunkArray<T>(arr: T[], size: number): T[][];
        /**
         * Reusable empty function
         */
        static noop: () => void;
    }
    export default Utilities;

}
declare module 'simple-keyboard' {
    import main = require('simple-keyboard/index');
    export = main;
}
// VisiWin.Application.modulEnd("VisiWinJS.js");
